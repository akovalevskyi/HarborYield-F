{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/base-x/src/index.js"],"sourcesContent":["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/bs58/index.js"],"sourcesContent":["var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n"],"names":[],"mappings":"AAAA,IAAI;AACJ,IAAI,WAAW;AAEf,OAAO,OAAO,GAAG,MAAM","ignoreList":[0]}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout/lib/Layout.js","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/buffer-layout/src/Layout.ts"],"sourcesContent":["unable to read source [project]/node_modules/@solana/buffer-layout/src/Layout.ts"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2309, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/bytes.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/combine-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/add-codec-sentinel.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/assertions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/add-codec-size-prefix.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/fix-codec-size.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/offset-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/resize-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/pad-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/reverse-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/transform-codec.ts"],"sourcesContent":["import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        -- Our sentinel.\n * //   -- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Heres how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       -- Our encoded base-58 string.\n * //   -- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 2910, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-core/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/bytes.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/combine-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/add-codec-sentinel.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/assertions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/add-codec-size-prefix.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/array-buffers.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/decoder-entire-byte-array.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/fix-codec-size.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/offset-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/resize-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/pad-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/reverse-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-core/src/transform-codec.ts"],"sourcesContent":["import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport function padBytes(bytes: Uint8Array, length: number): Uint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    return bytesEqual(slice, bytes);\n}\n\n/**\n * Returns true if and only if the provided `bytes1` and `bytes2` byte arrays are equal.\n *\n * @param bytes1 - The first byte array to compare.\n * @param bytes2 - The second byte array to compare.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const bytes2 = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * bytesEqual(bytes1, bytes2); // true\n * ```\n */\nexport function bytesEqual(bytes1: ReadonlyUint8Array | Uint8Array, bytes2: ReadonlyUint8Array | Uint8Array): boolean {\n    return bytes1.length === bytes2.length && bytes1.every((value, index) => value === bytes2[index]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array<ArrayBuffer>;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        -- Our sentinel.\n * //   -- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Heres how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       -- Our encoded base-58 string.\n * //   -- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts a `Uint8Array` to an `ArrayBuffer`. If the underlying buffer is a `SharedArrayBuffer`,\n * it will be copied to a non-shared buffer, for safety.\n *\n * @remarks\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nexport function toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    let buffer: ArrayBuffer;\n    if (typeof SharedArrayBuffer === 'undefined') {\n        buffer = bytes.buffer as ArrayBuffer;\n    } else if (bytes.buffer instanceof SharedArrayBuffer) {\n        buffer = new ArrayBuffer(bytes.length);\n        new Uint8Array(buffer).set(new Uint8Array(bytes));\n    } else {\n        buffer = bytes.buffer;\n    }\n    return (bytesOffset === 0 || bytesOffset === -bytes.byteLength) && bytesLength === bytes.byteLength\n        ? buffer\n        : buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, SolanaError } from '@solana/errors';\n\nimport { createDecoder, Decoder } from './codec';\n\n/**\n * Create a {@link Decoder} that asserts that the bytes provided to `decode` or `read` are fully consumed by the inner decoder\n * @param decoder A decoder to wrap\n * @returns A new decoder that will throw if provided with a byte array that it does not fully consume\n *\n * @typeParam T - The type of the decoder\n *\n * @remarks\n * Note that this compares the offset after encoding to the length of the input byte array\n *\n * The `offset` parameter to `decode` and `read` is still considered, and will affect the new offset that is compared to the byte array length\n *\n * The error that is thrown by the returned decoder is a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY`\n *\n * @example\n * Create a decoder that decodes a `u32` (4 bytes) and ensures the entire byte array is consumed\n * ```ts\n * const decoder = createDecoderThatUsesExactByteArray(getU32Decoder());\n * decoder.decode(new Uint8Array([0, 0, 0, 0])); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0])); // throws\n *\n * // with an offset\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0]), 1); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0, 0]), 1); // throws\n * ```\n */\nexport function createDecoderThatConsumesEntireByteArray<T>(decoder: Decoder<T>): Decoder<T> {\n    return createDecoder({\n        ...decoder,\n        read(bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n                    expectedLength: newOffset,\n                    numExcessBytes: bytes.length - newOffset,\n                });\n            }\n            return [value, newOffset];\n        },\n    });\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 3552, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/assertions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/common.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/utils.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/f32.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/f64.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i128.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i32.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i64.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i8.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/short-u16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u128.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u32.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u64.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n"],"names":["Endian","combineCodec","createEncoder","createDecoder"],"mappings":"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"}},
    {"offset": {"line": 3965, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-numbers/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/assertions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/common.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/utils.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/f32.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/f64.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/i128.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/i16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/i32.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/i64.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/i8.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/short-u16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/u128.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/u16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/u32.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/u64.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-numbers/src/u8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    toArrayBuffer,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n"],"names":["Endian","combineCodec","createEncoder","createDecoder"],"mappings":"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"}},
    {"offset": {"line": 4373, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/functional/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/functional/src/pipe.ts"],"sourcesContent":["/**\n * A pipeline is a solution that allows you to perform successive transforms of a value using functions. This is useful when building up a transaction message.\n *\n * Until the [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) becomes part of JavaScript you can use this utility to create pipelines.\n *\n * Following common implementations of pipe functions that use TypeScript, this function supports a maximum arity of 10 for type safety.\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```ts\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n *\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * @example Basic\n * ```ts\n * const add = (a, b) => a + b;\n * const add10 = x => add(x, 10);\n * const add100 = x => add(x, 100);\n * const sum = pipe(1, add10, add100);\n * sum === 111; // true\n * ```\n *\n * @example Building a Solana transaction message\n * ```ts\n * const transferTransactionMessage = pipe(\n *     // The result of the first expression...\n *     createTransactionMessage({ version: 0 }),\n *     // ...gets passed as the sole argument to the next function in the pipeline.\n *     tx => setTransactionMessageFeePayer(myAddress, tx),\n *     // The return value of that function gets passed to the next...\n *     tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n *     // ...and so on.\n *     tx => appendTransactionMessageInstruction(createTransferInstruction(myAddress, toAddress, amountInLamports), tx),\n * );\n * ```\n *\n * @returns The initial value\n */\nexport function pipe<TInitial>(\n    /** The initial value */\n    init: TInitial,\n): TInitial;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n): R1;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n): R2;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n): R3;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n): R4;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n): R5;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n): R6;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n): R7;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n): R8;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n): R9;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n    /** The function with which to transform the return value of the prior function */\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n"],"names":[],"mappings":";;;;;AAyOO,SAAS,IAAA,CAAe,IAAA,EAAA,GAAmB,GAAA,EAAyB;IACvE,OAAO,GAAA,CAAI,MAAA,CAAO,CAAC,GAAA,EAAK,KAAO,EAAA,CAAG,GAAG,GAAG,IAAI,CAAA;AAChD"}},
    {"offset": {"line": 4388, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-strings/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/text-encoding-impl/src/index.node.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    toArrayBuffer,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(toArrayBuffer(bytes), offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBO,SAAS,qBAAA,CAAsBA,SAAAA,EAAkB,SAAA,EAAmB,UAAA,GAAa,SAAA,EAAW;IAC/F,IAAI,CAAC,UAAU,KAAA,CAAM,IAAI,OAAO,CAAA,EAAA,EAAKA,SAAQ,CAAA,GAAA,CAAK,CAAC,CAAA,EAAG;QAClD,MAAM,IAAI,2KAAA,CAAY,6MAAA,EAA+C;YACjE,QAAA,EAAAA,SAAAA;YACA,MAAMA,SAAAA,CAAS,MAAA;YACf,KAAA,EAAO;QAAA,CACV,CAAA;IACL;AACJ;ACEO,IAAM,eAAA,GAAkB,CAACA,SAAAA,KAAkD;IAC9E,WAAO,qLAAA,EAAc;QACjB,gBAAA,EAAkB,CAAC,KAAA,KAA0B;YACzC,MAAM,CAAC,eAAe,SAAS,CAAA,GAAI,uBAAuB,KAAA,EAAOA,SAAAA,CAAS,CAAC,CAAC,CAAA;YAC5E,IAAI,CAAC,SAAA,EAAW,OAAO,KAAA,CAAM,MAAA;YAE7B,MAAM,YAAA,GAAe,kBAAA,CAAmB,SAAA,EAAWA,SAAQ,CAAA;YAC3D,OAAO,aAAA,CAAc,MAAA,GAAS,IAAA,CAAK,IAAA,CAAK,aAAa,QAAA,CAAS,EAAE,CAAA,CAAE,MAAA,GAAS,CAAC,CAAA;QAChF,CAAA;QACA,KAAA,EAAM,KAAA,EAAe,KAAA,EAAO,MAAA,EAAQ;YAEhC,qBAAA,CAAsBA,WAAU,KAAK,CAAA;YACrC,IAAI,KAAA,KAAU,IAAI,OAAO,MAAA;YAGzB,MAAM,CAAC,eAAe,SAAS,CAAA,GAAI,uBAAuB,KAAA,EAAOA,SAAAA,CAAS,CAAC,CAAC,CAAA;YAC5E,IAAI,CAAC,SAAA,EAAW;gBACZ,KAAA,CAAM,GAAA,CAAI,IAAI,UAAA,CAAW,aAAA,CAAc,MAAM,CAAA,CAAE,IAAA,CAAK,CAAC,CAAA,EAAG,MAAM,CAAA;gBAC9D,OAAO,SAAS,aAAA,CAAc,MAAA;YAClC;YAGA,IAAI,YAAA,GAAe,kBAAA,CAAmB,SAAA,EAAWA,SAAQ,CAAA;YAGzD,MAAM,YAAsB,EAAC;YAC7B,MAAO,eAAe,EAAA,CAAI;gBACtB,SAAA,CAAU,OAAA,CAAQ,MAAA,CAAO,YAAA,GAAe,IAAI,CAAC,CAAA;gBAC7C,YAAA,IAAgB,IAAA;YACpB;YAEA,MAAM,UAAA,GAAa,CAAC;mBAAG,KAAA,CAAM,aAAA,CAAc,MAAM,CAAA,CAAE,IAAA,CAAK,CAAC,CAAA,EAAG;mBAAG,SAAS;aAAA;YACxE,KAAA,CAAM,GAAA,CAAI,YAAY,MAAM,CAAA;YAC5B,OAAO,SAAS,UAAA,CAAW,MAAA;QAC/B;IAAA,CACH,CAAA;AACL;AAuBO,IAAM,eAAA,GAAkB,CAACA,SAAAA,KAAkD;IAC9E,WAAO,qLAAA,EAAc;QACjB,IAAA,EAAK,QAAA,EAAU,MAAA,EAA0B;YACrC,MAAM,QAAQ,MAAA,KAAW,CAAA,GAAI,QAAA,GAAW,QAAA,CAAS,KAAA,CAAM,MAAM,CAAA;YAC7D,IAAI,MAAM,MAAA,KAAW,CAAA,EAAG,OAAO;gBAAC;gBAAI,CAAC;aAAA;YAGrC,IAAI,UAAA,GAAa,KAAA,CAAM,SAAA,CAAU,CAAA,CAAA,GAAK,MAAM,CAAC,CAAA;YAC7C,UAAA,GAAa,UAAA,KAAe,CAAA,CAAA,GAAK,KAAA,CAAM,MAAA,GAAS,UAAA;YAChD,MAAM,aAAA,GAAgBA,SAAAA,CAAS,CAAC,CAAA,CAAE,MAAA,CAAO,UAAU,CAAA;YACnD,IAAI,eAAe,KAAA,CAAM,MAAA,EAAA,OAAe;gBAAC,aAAA;gBAAe,SAAS,MAAM;aAAA;YAGvE,MAAM,YAAA,GAAe,KAAA,CAAM,KAAA,CAAM,UAAU,EAAE,MAAA,CAAO,CAAC,GAAA,EAAK,IAAA,GAAS,GAAA,GAAM,IAAA,GAAO,MAAA,CAAO,IAAI,GAAG,EAAE,CAAA;YAGhG,MAAM,SAAA,GAAY,kBAAA,CAAmB,YAAA,EAAcA,SAAQ,CAAA;YAE3D,OAAO;gBAAC,aAAA,GAAgB,SAAA;gBAAW,QAAA,CAAS,MAAM;aAAA;QACtD;IAAA,CACH,CAAA;AACL;AA+CO,IAAM,aAAA,GAAgB,CAACA,SAAAA,OAC1B,oLAAA,EAAa,gBAAgBA,SAAQ,CAAA,EAAG,eAAA,CAAgBA,SAAQ,CAAC;AAErE,SAAS,sBAAA,CACL,KAAA,EACA,aAAA,EACqD;IACrD,MAAM,CAAC,YAAA,EAAc,SAAS,CAAA,GAAI,KAAA,CAAM,KAAA,CAAM,IAAI,MAAA,CAAO,CAAA,IAAA,EAAO,aAAa,CAAA,IAAA,CAAM,CAAC,CAAA;IACpF,OAAO;QAAC;QAAc,SAAS;KAAA;AACnC;AAEA,SAAS,kBAAA,CAAmB,KAAA,EAAeA,SAAAA,EAA0B;IACjE,MAAM,IAAA,GAAO,MAAA,CAAOA,SAAAA,CAAS,MAAM,CAAA;IACnC,IAAI,GAAA,GAAM,EAAA;IACV,KAAA,MAAW,QAAQ,KAAA,CAAO;QACtB,GAAA,IAAO,IAAA;QACP,GAAA,IAAO,MAAA,CAAOA,SAAAA,CAAS,OAAA,CAAQ,IAAI,CAAC,CAAA;IACxC;IACA,OAAO,GAAA;AACX;AAEA,SAAS,kBAAA,CAAmB,KAAA,EAAeA,SAAAA,EAA0B;IACjE,MAAM,IAAA,GAAO,MAAA,CAAOA,SAAAA,CAAS,MAAM,CAAA;IACnC,MAAM,YAAY,EAAC;IACnB,MAAO,QAAQ,EAAA,CAAI;QACf,SAAA,CAAU,OAAA,CAAQA,SAAAA,CAAS,MAAA,CAAO,KAAA,GAAQ,IAAI,CAAC,CAAC,CAAA;QAChD,KAAA,IAAS,IAAA;IACb;IACA,OAAO,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA;AAC5B;;AC1LA,IAAM,QAAA,GAAW,YAAA;AAqBV,IAAM,gBAAA,GAAmB,IAAM,eAAA,CAAgB,QAAQ;AAoBvD,IAAM,gBAAA,GAAmB,IAAM,eAAA,CAAgB,QAAQ;AA2CvD,IAAM,cAAA,GAAiB,IAAM,aAAA,CAAc,QAAQ;ACnE1D,IAAM,gCAAA,GAAmC;IACrC,QAAA,EAAU,kBAAA;IACV,IAAA,EAAM;AACV,CAAA;AAEA,SAAS,iBAAiB,IAAA,EAAc;IACpC,IAAI,IAAA,IAAQ,EAAA,CAAA,QAAA,OAAa,IAAA,IAAQ,EAAA,CAAA,QAAA,KAAA,OAAkB,IAAA,GAAO,EAAA,CAAA,QAAA;IAC1D,IAAI,QAAQ,EAAA,CAAA,QAAA,OAAa,IAAA,IAAQ,EAAA,CAAA,QAAA,KAAW,OAAO,OAAA,CAAQ,EAAA,CAAA,QAAA,MAAY,EAAA,CAAA;IACvE,IAAI,QAAQ,EAAA,CAAA,QAAA,OAAa,IAAA,IAAQ,GAAA,CAAA,QAAA,KAAW,OAAO,OAAA,CAAQ,EAAA,CAAA,QAAA,MAAY,EAAA,CAAA;AAC3E;AAqBO,IAAM,gBAAA,GAAmB,QAC5BC,qLAAAA,EAAc;QACV,kBAAkB,CAAC,KAAA,GAAkB,KAAK,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA;QAC/D,KAAA,EAAM,KAAA,EAAe,KAAA,EAAO,MAAA,EAAQ;YAChC,MAAM,MAAM,KAAA,CAAM,MAAA;YAClB,MAAM,KAAK,GAAA,GAAM,CAAA;YACjB,IAAI,QAAQ,CAAA,EAAG;gBACX,MAAM,CAAA,GAAI,KAAA,CAAM,UAAA,CAAW,CAAC,CAAA;gBAC5B,MAAM,CAAA,GAAI,iBAAiB,CAAC,CAAA;gBAC5B,IAAI,MAAM,KAAA,CAAA,EAAW;oBACjB,MAAM,IAAIC,2KAAAA,CAAYC,6MAAAA,EAA+C;wBACjE,GAAG,gCAAA;wBACH;oBAAA,CACH,CAAA;gBACL;gBACA,KAAA,CAAM,GAAA,CAAI;oBAAC,CAAC;iBAAA,EAAG,MAAM,CAAA;gBACrB,OAAO,CAAA,GAAI,MAAA;YACf;YACA,MAAM,QAAA,GAAW,IAAI,UAAA,CAAW,EAAE,CAAA;YAClC,IAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAI,CAAA,EAAA,CAAK;gBAChC,MAAM,EAAA,GAAK,KAAA,CAAM,UAAA,CAAW,CAAA,EAAG,CAAA;gBAC/B,MAAM,EAAA,GAAK,KAAA,CAAM,UAAA,CAAW,CAAA,EAAG,CAAA;gBAE/B,MAAM,EAAA,GAAK,iBAAiB,EAAE,CAAA;gBAC9B,MAAM,EAAA,GAAK,iBAAiB,EAAE,CAAA;gBAC9B,IAAI,EAAA,KAAO,KAAA,KAAc,EAAA,KAAO,KAAA,CAAA,IAAa,CAAC,MAAA,CAAO,KAAA,CAAM,EAAE,CAAA,EAAI;oBAC7D,MAAM,IAAID,2KAAAA,CAAYC,6MAAAA,EAA+C;wBACjE,GAAG,gCAAA;wBACH;oBAAA,CACH,CAAA;gBACL;gBACA,QAAA,CAAS,CAAC,CAAA,GAAI,CAAC,MAAA,CAAO,KAAA,CAAM,EAAE,CAAA,GAAK,EAAA,IAAM,CAAA,GAAA,CAAM,EAAA,IAAM,CAAA,CAAA,GAAK,EAAA;YAC9D;YAEA,KAAA,CAAM,GAAA,CAAI,UAAU,MAAM,CAAA;YAC1B,OAAO,SAAS,MAAA,GAAS,MAAA;QAC7B;IACJ,CAAC;AAoBE,IAAM,gBAAA,GAAmB,QAC5BC,qLAAAA,EAAc;QACV,IAAA,EAAK,KAAA,EAAO,MAAA,EAAQ;YAChB,MAAM,QAAQ,KAAA,CAAM,KAAA,CAAM,MAAM,CAAA,CAAE,MAAA,CAAO,CAAC,GAAA,EAAK,IAAA,GAAS,GAAA,GAAM,IAAA,CAAK,QAAA,CAAS,EAAE,CAAA,CAAE,QAAA,CAAS,CAAA,EAAG,GAAG,GAAG,EAAE,CAAA;YACpG,OAAO;gBAAC,KAAA;gBAAO,KAAA,CAAM,MAAM;aAAA;QAC/B;IACJ,CAAC;AA2CE,IAAM,iBAAiB,QAAiCC,oLAAAA,EAAa,gBAAA,EAAiB,EAAG,kBAAkB;;ACzJlH,IAAML,SAAAA,GAAW,4DAAA;AAqBV,IAAM,gBAAA,GAAmB,IAAM,eAAA,CAAgBA,SAAQ;AAoBvD,IAAM,gBAAA,GAAmB,IAAM,eAAA,CAAgBA,SAAQ;AA2CvD,IAAM,cAAA,GAAiB,IAAM,aAAA,CAAcA,SAAQ;ACpDnD,IAAM,sBAAA,GAAyB,CAACA,SAAAA,EAAkB,IAAA,OACrDC,qLAAAA,EAAc;QACV,gBAAA,EAAkB,CAAC,KAAA,GAAkB,IAAA,CAAK,KAAA,CAAO,KAAA,CAAM,MAAA,GAAS,OAAQ,CAAC,CAAA;QACzE,KAAA,EAAM,KAAA,EAAe,KAAA,EAAO,MAAA,EAAQ;YAChC,qBAAA,CAAsBD,WAAU,KAAK,CAAA;YACrC,IAAI,KAAA,KAAU,IAAI,OAAO,MAAA;YACzB,MAAM,WAAA,GAAc,CAAC;mBAAG,KAAK;aAAA,CAAE,GAAA,CAAI,CAAA,CAAA,GAAKA,SAAAA,CAAS,OAAA,CAAQ,CAAC,CAAC,CAAA;YAC3D,MAAM,aAAA,GAAgB,OAAA,CAAQ,WAAA,EAAa,IAAA,EAAM,GAAG,KAAK,CAAA;YACzD,KAAA,CAAM,GAAA,CAAI,eAAe,MAAM,CAAA;YAC/B,OAAO,cAAc,MAAA,GAAS,MAAA;QAClC;IACJ,CAAC;AAyBE,IAAM,sBAAA,GAAyB,CAACA,SAAAA,EAAkB,IAAA,OACrDI,qLAAAA,EAAc;QACV,IAAA,EAAK,QAAA,EAAU,MAAA,GAAS,CAAA,EAAqB;YACzC,MAAM,QAAQ,MAAA,KAAW,CAAA,GAAI,QAAA,GAAW,QAAA,CAAS,KAAA,CAAM,MAAM,CAAA;YAC7D,IAAI,MAAM,MAAA,KAAW,CAAA,EAAA,OAAU;gBAAC,EAAA;gBAAI,SAAS,MAAM;aAAA;YACnD,MAAM,WAAA,GAAc,QAAQ,CAAC;mBAAG,KAAK;aAAA,EAAG,CAAA,EAAG,MAAM,IAAI,CAAA;YACrD,OAAO;gBAAC,WAAA,CAAY,GAAA,CAAI,CAAA,CAAA,GAAKJ,SAAAA,CAAS,CAAC,CAAC,CAAA,CAAE,IAAA,CAAK,EAAE,CAAA;gBAAG,QAAA,CAAS,MAAM;aAAA;QACvE;IACJ,CAAC;AA+CE,IAAM,oBAAA,GAAuB,CAACA,SAAAA,EAAkB,IAAA,OACnDK,oLAAAA,EAAa,sBAAA,CAAuBL,SAAAA,EAAU,IAAI,CAAA,EAAG,sBAAA,CAAuBA,SAAAA,EAAU,IAAI,CAAC;AAG/F,SAAS,OAAA,CAAQ,KAAA,EAAiB,SAAA,EAAmB,UAAA,EAAoB,YAAA,EAAiC;IACtG,MAAM,SAAS,EAAC;IAChB,IAAI,WAAA,GAAc,CAAA;IAClB,IAAI,iBAAA,GAAoB,CAAA;IACxB,MAAM,IAAA,GAAA,CAAQ,KAAK,UAAA,IAAc,CAAA;IACjC,KAAA,MAAW,SAAS,KAAA,CAAO;QACvB,WAAA,GAAe,eAAe,SAAA,GAAa,KAAA;QAC3C,iBAAA,IAAqB,SAAA;QACrB,MAAO,qBAAqB,UAAA,CAAY;YACpC,iBAAA,IAAqB,UAAA;YACrB,MAAA,CAAO,IAAA,CAAM,WAAA,IAAe,iBAAA,GAAqB,IAAI,CAAA;QACzD;IACJ;IACA,IAAI,YAAA,IAAgB,oBAAoB,CAAA,EAAG;QACvC,MAAA,CAAO,IAAA,CAAM,WAAA,IAAgB,UAAA,GAAa,iBAAA,GAAsB,IAAI,CAAA;IACxE;IACA,OAAO,MAAA;AACX;;AClIA,IAAMA,SAAAA,GAAW,kEAAA;AAqBV,IAAM,mBAAmB,MAAmC;IAgC/C;QACZ,WAAOC,qLAAAA,EAAc;YACjB,kBAAkB,CAAC,KAAA,GAAkB,OAAO,IAAA,CAAK,KAAA,EAAO,QAAQ,CAAA,CAAE,MAAA;YAClE,KAAA,EAAM,KAAA,EAAe,KAAA,EAAO,MAAA,EAAQ;gBAChC,qBAAA,CAAsBD,SAAAA,EAAU,KAAA,CAAM,OAAA,CAAQ,IAAA,EAAM,EAAE,CAAC,CAAA;gBACvD,MAAM,MAAA,GAAS,MAAA,CAAO,IAAA,CAAK,KAAA,EAAO,QAAQ,CAAA;gBAC1C,KAAA,CAAM,GAAA,CAAI,QAAQ,MAAM,CAAA;gBACxB,OAAO,OAAO,MAAA,GAAS,MAAA;YAC3B;QAAA,CACH,CAAA;IACL;AAGJ;AAoBO,IAAM,mBAAmB,MAAmC;IAW/C;QACZ,WAAOI,qLAAAA,EAAc;YACjB,MAAM,CAAC,KAAA,EAAO,MAAA,GAAS,CAAA,GAAM;oBAAC,MAAA,CAAO,IAAA,KAAK,qLAAA,EAAc,KAAK,GAAG,MAAM,CAAA,CAAE,QAAA,CAAS,QAAQ,CAAA;oBAAG,MAAM,MAAM;iBAAA;QAAA,CAC3G,CAAA;IACL;AAKJ;AA2CO,IAAM,iBAAiB,QAAiCC,oLAAAA,EAAa,gBAAA,EAAiB,EAAG,kBAAkB;;ACtJ3G,IAAM,uBAAuB,CAAC,KAAA,GAAA,4CAAA;IAEjC,KAAA,CAAM,OAAA,CAAQ,SAAA,EAAW,EAAE;AAkBxB,IAAM,oBAAoB,CAAC,KAAA,EAAe,QAAkB,KAAA,CAAM,MAAA,CAAO,OAAO,IAAQ;;ACnCxF,IAAMC,IAAc,UAAA,CAAW,WAAA;AAA/B,IACMC,IAAc,UAAA,CAAW,WAAA;;AC8B/B,IAAM,iBAAiB,MAAmC;IAC7D,IAAI,WAAA;IACJ,WAAON,qLAAAA,EAAc;QACjB,gBAAA,EAAkB,CAAA,QAAA,CAAU,WAAA,KAAgB,IAAI,GAAY,EAAG,MAAA,CAAO,KAAK,CAAA,CAAE,MAAA;QAC7E,KAAA,EAAO,CAAC,KAAA,EAAe,KAAA,EAAO,MAAA,KAAW;YACrC,MAAM,aAAA,CAAc,WAAA,KAAgB,IAAI,CAAA,EAAY,EAAG,MAAA,CAAO,KAAK,CAAA;YACnE,KAAA,CAAM,GAAA,CAAI,YAAY,MAAM,CAAA;YAC5B,OAAO,SAAS,UAAA,CAAW,MAAA;QAC/B;IAAA,CACH,CAAA;AACL;AAqBO,IAAM,iBAAiB,MAAmC;IAC7D,IAAI,WAAA;IACJ,WAAOG,qLAAAA,EAAc;QACjB,IAAA,EAAK,KAAA,EAAO,MAAA,EAAQ;YAChB,MAAM,KAAA,GAAA,CAAS,gBAAgB,IAAI,CAAA,EAAA,EAAe,MAAA,CAAO,KAAA,CAAM,KAAA,CAAM,MAAM,CAAC,CAAA;YAC5E,OAAO;gBAAC,oBAAA,CAAqB,KAAK,CAAA;gBAAG,MAAM,MAAM;aAAA;QACrD;IAAA,CACH,CAAA;AACL;AA2CO,IAAM,eAAe,QAAiCC,oLAAAA,EAAa,cAAA,EAAe,EAAG,gBAAgB"}},
    {"offset": {"line": 4712, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/assertions/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/assertions/src/crypto.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/assertions/src/subtle-crypto.ts"],"sourcesContent":["import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\n/**\n * Throws an exception unless {@link Crypto#getRandomValues | `crypto.getRandomValues()`} is\n * available in the current JavaScript environment.\n */\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#digest | `crypto.subtle.digest()`} is available in\n * the current JavaScript environment.\n */\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#generateKey | `crypto.subtle.generateKey()`} is\n * available in the current JavaScript environment and has support for the Ed25519 curve.\n */\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#exportKey | `crypto.subtle.exportKey()`} is\n * available in the current JavaScript environment.\n */\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#sign | `crypto.subtle.sign()`} is available in the\n * current JavaScript environment.\n */\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n/**\n * Throws an exception unless {@link SubtleCrypto#verify | `crypto.subtle.verify()`} is available in\n * the current JavaScript environment.\n */\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n"],"names":["SolanaError"],"mappings":";;;;;;;;;;;;;;;;;AAMO,SAAS,qBAAA,GAAwB;IACpC,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,eAAA,KAAoB,UAAA,EAAY;QACrG,MAAM,IAAI,2KAAA,CAAY,0NAA0D,CAAA;IACpF;AACJ;ACOA,IAAI,qBAAA;AACJ,eAAe,wBAAwB,MAAA,EAAwC;IAC3E,IAAI,0BAA0B,KAAA,CAAA,EAAW;QACrC,qBAAA,GAAwB,IAAI,QAAQ,CAAA,OAAA,KAAW;YAC3C,MAAA,CACK,WAAA,CAAY,SAAA,EAAA,eAAA,GAA6B,KAAA,EAAO;gBAAC;gBAAQ,QAAQ;aAAA,EACjE,IAAA,CAAK,MAAM;gBACR,OAAA,CAAS,wBAAwB,IAAK,CAAA;YAC1C,CAAC,CAAA,CACA,KAAA,CAAM,MAAM;gBACT,OAAA,CAAS,wBAAwB,KAAM,CAAA;YAC3C,CAAC,CAAA;QACT,CAAC,CAAA;IACL;IACA,IAAI,OAAO,0BAA0B,SAAA,EAAW;QAC5C,OAAO,qBAAA;IACX,CAAA,MAAO;QACH,OAAO,MAAM,qBAAA;IACjB;AACJ;AAMO,SAAS,iCAAA,GAAoC;IAEhD,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,MAAA,KAAW,UAAA,EAAY;QACpG,MAAM,IAAIA,2KAAAA,CAAY,iNAAiD,CAAA;IAC3E;AACJ;AAMA,eAAsB,8BAAA,GAAiC;IAEnD,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,WAAA,KAAgB,UAAA,EAAY;QACzG,MAAM,IAAIA,2KAAAA,CAAY,4NAA4D,CAAA;IACtF;IACA,IAAI,CAAE,MAAM,uBAAA,CAAwB,UAAA,CAAW,MAAA,CAAO,MAAM,CAAA,EAAI;QAC5D,MAAM,IAAIA,2KAAAA,CAAY,4NAA4D,CAAA;IACtF;AACJ;AAMO,SAAS,4BAAA,GAA+B;IAE3C,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,SAAA,KAAc,UAAA,EAAY;QACvG,MAAM,IAAIA,2KAAAA,CAAY,0NAA0D,CAAA;IACpF;AACJ;AAMO,SAAS,kCAAA,GAAqC;IAEjD,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,IAAA,KAAS,UAAA,EAAY;QAClG,MAAM,IAAIA,2KAAAA,CAAY,wNAAwD,CAAA;IAClF;AACJ;AAKO,SAAS,uCAAA,GAA0C;IAEtD,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,MAAA,KAAW,UAAA,EAAY;QACpG,MAAM,IAAIA,2KAAAA,CAAY,0NAA0D,CAAA;IACpF;AACJ"}},
    {"offset": {"line": 4789, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/addresses/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/addresses/src/address.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/addresses/src/vendor/noble/ed25519.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/addresses/src/curve-internal.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/addresses/src/curve.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/addresses/src/program-derived-address.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/addresses/src/public-key.ts"],"sourcesContent":["import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * Represents a string that validates as a Solana address. Functions that require well-formed\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an arbitrary string as a base58-encoded address, use the\n * {@link address}, {@link assertIsAddress}, or {@link isAddress} functions in this package.\n */\nexport type Address<TAddress extends string = string> = Brand<EncodedString<TAddress, 'base58'>, 'Address'>;\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Address} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAddress } from '@solana/addresses';\n *\n * if (isAddress(ownerAddress)) {\n *     // At this point, `ownerAddress` has been refined to a\n *     // `Address` that can be used with the RPC.\n *     const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n *     setBalanceLamports(lamports);\n * } else {\n *     setError(`${ownerAddress} is not an address`);\n * }\n * ```\n */\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an address or public\n * key, from an untrusted network API or user input. Use this function to assert that such an\n * arbitrary string is a base58-encoded address.\n *\n * @example\n * ```ts\n * import { assertIsAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // At this point, `address` is an `Address` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out not to be a base58-encoded address\n *     }\n * }\n * ```\n */\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an address with _coercing_ it to the {@link Address} type.\n * It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good address as a string, it's more efficient to typecast it rather\n * than to use the {@link address} helper, because the helper unconditionally performs validation on\n * its input.\n * >\n * > ```ts\n * > import { Address } from '@solana/addresses';\n * >\n * > const MEMO_PROGRAM_ADDRESS =\n * >     'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n * > ```\n */\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded address to a byte array.\n *\n * @example\n * ```ts\n * import { getAddressEncoder } from '@solana/addresses';\n *\n * const address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\n * const addressEncoder = getAddressEncoder();\n * const addressBytes = addressEncoder.encode(address);\n * // Uint8Array(32) [\n * //   150, 183, 190,  48, 171,   8, 39, 156,\n * //   122, 213, 172, 108, 193,  95, 26, 158,\n * //   149, 243, 115, 254,  20, 200, 36,  30,\n * //   248, 179, 178, 232, 220,  89, 53, 127\n * // ]\n * ```\n */\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an address to the\n * base58-encoded representation of that address.\n *\n * @example\n * ```ts\n * import { getAddressDecoder } from '@solana/addresses';\n *\n * const addressBytes = new Uint8Array([\n *     150, 183, 190,  48, 171,   8, 39, 156,\n *     122, 213, 172, 108, 193,  95, 26, 158,\n *     149, 243, 115, 254,  20, 200, 36,  30,\n *     248, 179, 178, 232, 220,  89, 53, 127\n * ]);\n * const addressDecoder = getAddressDecoder();\n * const address = addressDecoder.decode(addressBytes); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n * ```\n */\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded address.\n *\n * @see {@link getAddressDecoder}\n * @see {@link getAddressEncoder}\n */\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the Software), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // -1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v\n    const v7 = mod(v3 * v3 * v); // v\n    const pow = pow_2_252_3(u * v7); // (uv)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is -1\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx = -u-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y\n    const u = mod(y2 - 1n); // u=y-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv)(uv)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\n\nimport { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: ReadonlyUint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: ReadonlyUint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SolanaError } from '@solana/errors';\nimport type { AffinePoint } from '@solana/nominal-types';\n\nimport { type Address, getAddressCodec } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * Represents an {@link Address} that validates as being off-curve. Functions that require off-curve\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an address as being off-curve, use the {@link offCurveAddress},\n * {@link assertIsOffCurveAddress}, or {@link isOffCurveAddress} functions in this package.\n */\nexport type OffCurveAddress<TAddress extends string = string> = AffinePoint<Address<TAddress>, 'invalid'>;\n\n/**\n * A type guard that returns `true` if the input address conforms to the {@link OffCurveAddress}\n * type, and refines its type for use in your application.\n *\n * @example\n * ```ts\n * import { isOffCurveAddress } from '@solana/addresses';\n *\n * if (isOffCurveAddress(accountAddress)) {\n *     // At this point, `accountAddress` has been refined to a\n *     // `OffCurveAddress` that can be used within your business logic.\n *     const { value: account } = await rpc.getAccountInfo(accountAddress).send();\n * } else {\n *     setError(`${accountAddress} is not off-curve`);\n * }\n * ```\n */\nexport function isOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\n\n/**\n * From time to time you might acquire an {@link Address}, that you expect to validate as an\n * off-curve address, from an untrusted source. Use this function to assert that such an address is\n * off-curve.\n *\n * @example\n * ```ts\n * import { assertIsOffCurveAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that the input conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `OffCurveAddress`.\n *         assertIsOffCurveAddress(address);\n *         // At this point, `address` is an `OffCurveAddress` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out to NOT be a base58-encoded off-curve address\n *     }\n * }\n * ```\n */\nexport function assertIsOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): asserts putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\n\n/**\n * Combines _asserting_ that an {@link Address} is off-curve with _coercing_ it to the\n * {@link OffCurveAddress} type. It's most useful with untrusted input.\n */\nexport function offCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): OffCurveAddress<TAddress> {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport { bytesEqual, type ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * A tuple representing a program derived address (derived from the address of some program and a\n * set of seeds) and the associated bump seed used to ensure that the address, as derived, does not\n * fall on the Ed25519 curve.\n *\n * Whenever you need to validate an arbitrary tuple as one that represents a program derived\n * address, use the {@link assertIsProgramDerivedAddress} or {@link isProgramDerivedAddress}\n * functions in this package.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * Represents an integer in the range [0,255] used in the derivation of a program derived address to\n * ensure that it does not fall on the Ed25519 curve.\n */\nexport type ProgramDerivedAddressBump = Brand<number, 'ProgramDerivedAddressBump'>;\n\n/**\n * A type guard that returns `true` if the input tuple conforms to the {@link ProgramDerivedAddress}\n * type, and refines its type for use in your program.\n *\n * @see The {@link isAddress} function for an example of how to use a type guard.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * In the event that you receive an address/bump-seed tuple from some untrusted source, use this\n * function to assert that it conforms to the {@link ProgramDerivedAddress} interface.\n *\n * @see The {@link assertIsAddress} function for an example of how to use an assertion function.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\n/**\n * Given a program's {@link Address} and up to 16 {@link Seed | Seeds}, this method will return the\n * program derived address (PDA) associated with each.\n *\n * @example\n * ```ts\n * import { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n *\n * const addressEncoder = getAddressEncoder();\n * const [pda, bumpSeed] = await getProgramDerivedAddress({\n *     programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n *     seeds: [\n *         // Owner\n *         addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n *         // Token program\n *         addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n *         // Mint\n *         addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n *     ],\n * });\n * ```\n */\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\n/**\n * Returns a base58-encoded address derived from some base address, some program address, and a seed\n * string or byte array.\n *\n * @example\n * ```ts\n * import { createAddressWithSeed } from '@solana/addresses';\n *\n * const derivedAddress = await createAddressWithSeed({\n *     // The private key associated with this address will be able to sign for `derivedAddress`.\n *     baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n *     // Only this program will be able to write data to this account.\n *     programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n *     seed: 'data-account',\n * });\n * ```\n */\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        bytesEqual(programAddressBytes.slice(-PDA_MARKER_BYTES.length), new Uint8Array(PDA_MARKER_BYTES))\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder, getAddressEncoder } from './address';\n\n/**\n * Given a public {@link CryptoKey}, this method will return its associated {@link Address}.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const address = await getAddressFromPublicKey(publicKey);\n * ```\n */\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n\n/**\n * Given an {@link Address}, return a {@link CryptoKey} that can be used to verify signatures.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const publicKey = await getPublicKeyFromAddress(address);\n * ```\n */\nexport async function getPublicKeyFromAddress(address: Address) {\n    const addressBytes = getAddressEncoder().encode(address);\n    return await crypto.subtle.importKey('raw', addressBytes, { name: 'Ed25519' }, true /* extractable */, ['verify']);\n}\n"],"names":["SolanaError","address"],"mappings":"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"}},
    {"offset": {"line": 5141, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-types/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-types/src/blockhash.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-types/src/cluster-url.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-types/src/commitment.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-types/src/lamports.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-types/src/stringified-bigint.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-types/src/stringified-number.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-types/src/unix-timestamp.ts"],"sourcesContent":["import { Address, assertIsAddress, getAddressDecoder, getAddressEncoder, isAddress } from '@solana/addresses';\nimport { combineCodec, createEncoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nexport type Blockhash = Brand<EncodedString<string, 'base58'>, 'Blockhash'>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Blockhash} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isBlockhash } from '@solana/rpc-types';\n *\n * if (isBlockhash(blockhash)) {\n *     // At this point, `blockhash` has been refined to a\n *     // `Blockhash` that can be used with the RPC.\n *     const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsFresh(isValid);\n * } else {\n *     setError(`${blockhash} is not a blockhash`);\n * }\n * ```\n */\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    return isAddress(putativeBlockhash);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as a blockhash, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string is\n * a base58-encoded blockhash.\n *\n * @example\n * ```ts\n * import { assertIsBlockhash } from '@solana/rpc-types';\n *\n * // Imagine a function that determines whether a blockhash is fresh when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const blockhash: string = blockhashInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `blockhash` to `Blockhash`.\n *         assertIsBlockhash(blockhash);\n *         // At this point, `blockhash` is a `Blockhash` that can be used with the RPC.\n *         const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     } catch (e) {\n *         // `blockhash` turned out not to be a base58-encoded blockhash\n *     }\n * }\n * ```\n */\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    try {\n        assertIsAddress(putativeBlockhash);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is a blockhash with _coercing_ it to the {@link Blockhash}\n * type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { blockhash } from '@solana/rpc-types';\n *\n * const { value: isValid } = await rpc.isBlockhashValid(blockhash(blockhashFromUserInput)).send();\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good blockhash as a string, it's more efficient to typecast it\n * rather than to use the {@link blockhash} helper, because the helper unconditionally performs\n * validation on its input.\n * >\n * > ```ts\n * > import { Blockhash } from '@solana/rpc-types';\n * >\n * > const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * > ```\n */\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded blockhash to a byte array.\n *\n * @example\n * ```ts\n * import { getBlockhashEncoder } from '@solana/rpc-types';\n *\n * const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * const blockhashEncoder = getBlockhashEncoder();\n * const blockhashBytes = blockhashEncoder.encode(blockhash);\n * // Uint8Array(32) [\n * //   136, 123,  44, 249,  43,  19,  60,  14,\n * //   144,  16, 168, 241, 121, 111,  70, 232,\n * //   186,  26, 140, 202, 213,  64, 231,  82,\n * //   179,  66, 103, 237,  52, 117, 217,  93\n * // ]\n * ```\n */\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    const addressEncoder = getAddressEncoder();\n    return createEncoder({\n        fixedSize: 32,\n        write: (value: string, bytes, offset) => {\n            assertIsBlockhash(value);\n            return addressEncoder.write(value as string as Address, bytes, offset);\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing a blockhash to\n * the base58-encoded representation of that blockhash.\n *\n * @example\n * ```ts\n * import { getBlockhashDecoder } from '@solana/rpc-types';\n *\n * const blockhashBytes = new Uint8Array([\n *     136, 123,  44, 249,  43,  19,  60,  14,\n *     144,  16, 168, 241, 121, 111,  70, 232,\n *     186,  26, 140, 202, 213,  64, 231,  82,\n *     179,  66, 103, 237,  52, 117, 217,  93\n * ]);\n * const blockhashDecoder = getBlockhashDecoder();\n * const blockhash = blockhashDecoder.decode(blockhashBytes); // ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48\n * ```\n */\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<Blockhash, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded blockhash.\n *\n * @see {@link getBlockhashDecoder}\n * @see {@link getBlockhashEncoder}\n */\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\n/** Given a URL casts it to a type that is only accepted where mainnet URLs are expected. */\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where devnet URLs are expected. */\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where testnet URLs are expected. */\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\n/**\n * A union of all possible commitment statuses -- each a measure of the network confirmation and\n * stake levels on a particular block.\n *\n * Read more about the statuses themselves, [here](https://docs.solana.com/cluster/commitments).\n */\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * Represents an integer value denominated in Lamports (ie. $1 \\times 10^{-9}$ ).\n *\n * It is represented as a `bigint` in client code and an `u64` in server code.\n */\nexport type Lamports = Brand<bigint, 'Lamports'>;\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link Lamports} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isLamports } from '@solana/rpc-types';\n *\n * if (isLamports(lamports)) {\n *     // At this point, `lamports` has been refined to a\n *     // `Lamports` that can be used anywhere Lamports are expected.\n *     await transfer(fromAddress, toAddress, lamports);\n * } else {\n *     setError(`${lamports} is not a quantity of Lamports`);\n * }\n * ```\n */\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\n/**\n * Lamport values returned from the RPC API conform to the type {@link Lamports}. You can use a\n * value of that type wherever a quantity of Lamports is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a quantity of Lamports, from\n * an untrusted network API or user input. To assert that such an arbitrary number is usable as a\n * quantity of Lamports, use this function.\n *\n * ```ts\n * import { assertIsLamports } from '@solana/rpc-types';\n *\n * // Imagine a function that creates a transfer instruction when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `number` type.\n *     const lamports: number = parseInt(quantityInput.value, 10);\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `lamports` to `Lamports`.\n *         assertIsLamports(lamports);\n *         // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n *         await transfer(fromAddress, toAddress, lamports);\n *     } catch (e) {\n *         // `lamports` turned out not to validate as a quantity of Lamports.\n *     }\n * }\n * ```\n */\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\n/**\n * This helper combines _asserting_ that a number is a possible number of {@link Lamports} with\n * _coercing_ it to the {@link Lamports} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { lamports } from '@solana/rpc-types';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n */\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\n/**\n * Returns an encoder that you can use to encode a 64-bit {@link Lamports} value to 8 bytes in\n * little endian order.\n */\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link Lamports} value to a byte array.\n *\n * You must supply a number decoder that will determine how encode the numeric value.\n *\n * @example\n * ```ts\n * import { getLamportsEncoder } from '@solana/rpc-types';\n * import { getU16Encoder } from '@solana/codecs-numbers';\n *\n * const lamports = lamports(256n);\n * const lamportsEncoder = getLamportsEncoder(getU16Encoder());\n * const lamportsBytes = lamportsEncoder.encode(lamports);\n * // Uint8Array(2) [ 0, 1 ]\n * ```\n */\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a 64-bit little endian\n * number to a {@link Lamports} value.\n */\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\n/**\n * Returns a decoder that you can use to convert an array of bytes representing a number to a\n * {@link Lamports} value.\n *\n * You must supply a number decoder that will determine how many bits to use to decode the numeric\n * value.\n *\n * @example\n * ```ts\n * import { getLamportsDecoder } from '@solana/rpc-types';\n * import { getU16Decoder } from '@solana/codecs-numbers';\n *\n * const lamportsBytes = new Uint8Array([ 0, 1 ]);\n * const lamportsDecoder = getLamportsDecoder(getU16Decoder());\n * const lamports = lamportsDecoder.decode(lamportsBytes); // lamports(256n)\n * ```\n */\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a 64-bit {@link Lamports} value.\n *\n * @see {@link getDefaultLamportsDecoder}\n * @see {@link getDefaultLamportsEncoder}\n */\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link Lamports} value.\n *\n * @see {@link getLamportsDecoder}\n * @see {@link getLamportsEncoder}\n */\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a `bigint` which has been encoded as a string for transit over a transport\n * that does not support `bigint` values natively. The JSON-RPC is such a transport.\n */\nexport type StringifiedBigInt = Brand<string, 'StringifiedBigInt'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `BigInt`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedBigInt } from '@solana/rpc-types';\n *\n * if (isStringifiedBigInt(bigintString)) {\n *     // At this point, `bigintString` has been refined to a `StringifiedBigInt`\n *     bigintString satisfies StringifiedBigInt; // OK\n * } else {\n *     setError(`${bigintString} does not represent a BigInt`);\n * }\n * ```\n */\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `BigInt`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `BigInt`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedBigInt } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents the supply of some token.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `supplyString` to `StringifiedBigInt`.\n *     assertIsStringifiedBigInt(supplyString);\n *     // At this point, `supplyString` is a `StringifiedBigInt`.\n *     supplyString satisfies StringifiedBigInt;\n * } catch (e) {\n *     // `supplyString` turned out not to parse as a `BigInt`\n * }\n * ```\n */\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `BigInt` with _coercing_ it to the\n * {@link StringifiedBigInt} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedBigInt } from '@solana/rpc-types';\n *\n * const supplyString = stringifiedBigInt('1000000000');\n * ```\n */\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a number which has been encoded as a string for transit over a transport\n * where loss of precision when using the native number type is a concern. The JSON-RPC is such a\n * transport.\n */\nexport type StringifiedNumber = Brand<string, 'StringifiedNumber'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `Number`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedNumber } from '@solana/rpc-types';\n *\n * if (isStringifiedNumber(numericString)) {\n *     // At this point, `numericString` has been refined to a `StringifiedNumber`\n *     numericString satisfies StringifiedNumber; // OK\n * } else {\n *     setError(`${numericString} does not represent a number`);\n * }\n * ```\n */\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `Number`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `Number`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedNumber } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents some decimal number.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `decimalNumberString` to `StringifiedNumber`.\n *     assertIsStringifiedNumber(decimalNumberString);\n *     // At this point, `decimalNumberString` is a `StringifiedNumber`.\n *     decimalNumberString satisfies StringifiedNumber;\n * } catch (e) {\n *     // `decimalNumberString` turned out not to parse as a number.\n * }\n * ```\n */\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `Number` with _coercing_ it to the\n * {@link StringifiedNumber} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedNumber } from '@solana/rpc-types';\n *\n * const decimalNumberString = stringifiedNumber('-42.1');\n * ```\n */\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a Unix timestamp in _seconds_.\n *\n * It is represented as a `bigint` in client code and an `i64` in server code.\n */\nexport type UnixTimestamp = Brand<bigint, 'UnixTimestamp'>;\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link UnixTimestamp} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isUnixTimestamp } from '@solana/rpc-types';\n *\n * if (isUnixTimestamp(timestamp)) {\n *     // At this point, `timestamp` has been refined to a\n *     // `UnixTimestamp` that can be used anywhere timestamps are expected.\n *     timestamp satisfies UnixTimestamp;\n * } else {\n *     setError(`${timestamp} is not a Unix timestamp`);\n * }\n * ```\n */\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\n/**\n * Timestamp values returned from the RPC API conform to the type {@link UnixTimestamp}. You can use\n * a value of that type wherever a timestamp is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a timestamp, from an untrusted\n * network API or user input. To assert that such an arbitrary number is usable as a Unix timestamp,\n * use this function.\n *\n * ```ts\n * import { assertIsUnixTimestamp } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents a timestamp.\n * // At this point we know only that it conforms to the `bigint` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `timestamp` to `UnixTimestamp`.\n *     assertIsUnixTimestamp(timestamp);\n *     // At this point, `timestamp` is a `UnixTimestamp`.\n *     timestamp satisfies UnixTimestamp;\n * } catch (e) {\n *     // `timestamp` turned out not to be a valid Unix timestamp\n * }\n * ```\n */\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a `bigint` represents a Unix timestamp with _coercing_ it\n * to the {@link UnixTimestamp} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { unixTimestamp } from '@solana/rpc-types';\n *\n * const timestamp = unixTimestamp(-42n); // Wednesday, December 31, 1969 3:59:18 PM GMT-08:00\n * ```\n */\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n"],"names":["SolanaError","combineCodec"],"mappings":"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"}},
    {"offset": {"line": 5385, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-data-structures/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/assertions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/utils.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/array.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/bit-array.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/boolean.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/bytes.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/constant.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/tuple.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/union.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/discriminated-union.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/enum-helpers.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/enum.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/hidden-prefix.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/hidden-suffix.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/literal-union.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/map.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/unit.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/nullable.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/set.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-data-structures/src/struct.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type  i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Defines the possible size strategies for array-like codecs (`array`, `map`, and `set`).\n *\n * The size of the collection can be determined using one of the following approaches:\n * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} to store a size prefix.\n * - A fixed `number` of items, enforcing an exact length.\n * - The string `\"remainder\"`, which infers the number of items by consuming the rest of the available bytes.\n *   This option is only available when encoding fixed-size items.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/**\n * Defines the configuration options for array codecs.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how the size of the array is determined.\n     *\n     * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} stores a size prefix before encoding the array.\n     * - A `number` enforces a fixed number of elements.\n     * - `\"remainder\"` uses all remaining bytes to infer the array length (only for fixed-size items).\n     *\n     * @defaultValue A `u32` size prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for arrays of values.\n *\n * This encoder serializes arrays by encoding each element using the provided item encoder.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TFrom - The type of the elements in the array.\n *\n * @param item - The encoder for each item in the array.\n * @param config - Optional configuration for the size encoding strategy.\n * @returns A `VariableSizeEncoder<TFrom[]>` for encoding arrays.\n *\n * @example\n * Encoding an array of `u8` numbers.\n * ```ts\n * const encoder = getArrayEncoder(getU8Encoder());\n * const bytes = encoder.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for arrays of values.\n *\n * This decoder deserializes arrays by decoding each element using the provided item decoder.\n * By default, a `u32` size prefix is expected to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TTo - The type of the decoded elements in the array.\n *\n * @param item - The decoder for each item in the array.\n * @param config - Optional configuration for the size decoding strategy.\n * @returns A `VariableSizeDecoder<TTo[]>` for decoding arrays.\n *\n * @example\n * Decoding an array of `u8` numbers.\n * ```ts\n * const decoder = getArrayDecoder(getU8Decoder());\n * const array = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // [1, 2, 3]\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding arrays of values.\n *\n * This codec serializes arrays by encoding each element using the provided item codec.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * @typeParam TFrom - The type of the elements to encode.\n * @typeParam TTo - The type of the decoded elements.\n *\n * @param item - The codec for each item in the array.\n * @param config - Optional configuration for the size encoding/decoding strategy.\n * @returns A `VariableSizeCodec<TFrom[], TTo[]>` for encoding and decoding arrays.\n *\n * @example\n * Encoding and decoding an array of `u8` numbers.\n * ```ts\n * const codec = getArrayCodec(getU8Codec());\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n *\n * const array = codec.decode(bytes);\n * // [1, 2, 3]\n * ```\n *\n * @example\n * Using a `u16` size prefix instead of `u32`.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix telling us to read 3 items.\n * ```\n *\n * @example\n * Using a fixed-size array of 3 items.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 3 });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. There must always be 3 items in the array.\n * ```\n *\n * @example\n * Using the `\"remainder\"` size strategy.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 'remainder' });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n * ```\n *\n * @remarks\n * The size of the array can be controlled using the `size` option:\n * - A `Codec<number>` (e.g. `getU16Codec()`) stores a size prefix before the array.\n * - A `number` enforces a fixed number of elements.\n * - `\"remainder\"` uses all remaining bytes to infer the array length.\n *\n * Separate {@link getArrayEncoder} and {@link getArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getArrayEncoder(getU8Encoder()).encode([1, 2, 3]);\n * const array = getArrayDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getArrayEncoder}\n * @see {@link getArrayDecoder}\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Defines the configuration options for bit array codecs.\n *\n * A bit array codec encodes an array of booleans into bits, packing them into bytes.\n * This configuration allows adjusting the bit ordering.\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n * @see {@link getBitArrayCodec}\n */\nexport type BitArrayCodecConfig = {\n    /**\n     * Determines whether the bits should be read in reverse order.\n     *\n     * - `false` (default): The first boolean is stored in the most significant bit (MSB-first).\n     * - `true`: The first boolean is stored in the least significant bit (LSB-first).\n     *\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Returns an encoder that packs an array of booleans into bits.\n *\n * This encoder converts a list of `boolean` values into a compact bit representation,\n * storing 8 booleans per byte.\n *\n * The `backward` config option determines whether the bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding the bit array.\n * @returns A `FixedSizeEncoder<boolean[], TSize>` for encoding bit arrays.\n *\n * @example\n * Encoding a bit array.\n * ```ts\n * const encoder = getBitArrayEncoder(1);\n *\n * encoder.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Returns a decoder that unpacks bits into an array of booleans.\n *\n * This decoder converts a compact bit representation back into a list of `boolean` values.\n * Each byte is expanded into 8 booleans.\n *\n * The `backward` config option determines whether the bits are read in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for decoding the bit array.\n * @returns A `FixedSizeDecoder<boolean[], TSize>` for decoding bit arrays.\n *\n * @example\n * Decoding a bit array.\n * ```ts\n * const decoder = getBitArrayDecoder(1);\n *\n * decoder.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes boolean arrays as compact bit representations.\n *\n * This codec efficiently stores boolean arrays as bits, packing 8 values per byte.\n * The `backward` config option determines whether bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding and decoding the bit array.\n * @returns A `FixedSizeCodec<boolean[], boolean[], TSize>` for encoding and decoding bit arrays.\n *\n * @example\n * Encoding and decoding a bit array.\n * ```ts\n * const codec = getBitArrayCodec(1);\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n *\n * codec.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @example\n * Encoding and decoding a bit array backwards.\n * ```ts\n * const codec = getBitArrayCodec(1, { backward: true });\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0x05 (0b00000101)\n *\n * codec.decode(new Uint8Array([0x05]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @remarks\n * Separate {@link getBitArrayEncoder} and {@link getBitArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBitArrayEncoder(1).encode([true, false, true, false]);\n * const value = getBitArrayDecoder(1).decode(bytes);\n * ```\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/**\n * Defines the configuration options for boolean codecs.\n *\n * A boolean codec encodes `true` as `1` and `false` as `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * @typeParam TSize - A number codec, encoder, or decoder used for boolean representation.\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n * @see {@link getBooleanCodec}\n */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec used to store boolean values.\n     *\n     * - By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n     * - A custom number codec can be provided to change the storage size.\n     *\n     * @defaultValue `u8`\n     */\n    size?: TSize;\n};\n\n/**\n * Returns an encoder for boolean values.\n *\n * This encoder converts `true` into `1` and `false` into `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for encoding booleans.\n * @returns A `FixedSizeEncoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding booleans.\n * ```ts\n * const encoder = getBooleanEncoder();\n *\n * encoder.encode(false); // 0x00\n * encoder.encode(true);  // 0x01\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Returns a decoder for boolean values.\n *\n * This decoder reads a number and interprets `1` as `true` and `0` as `false`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for decoding booleans.\n * @returns A `FixedSizeDecoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Decoding booleans.\n * ```ts\n * const decoder = getBooleanDecoder();\n *\n * decoder.decode(new Uint8Array([0x00])); // false\n * decoder.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Returns a codec for encoding and decoding boolean values.\n *\n * By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n * The `size` option allows customizing the number codec used for storage.\n *\n * @param config - Configuration options for encoding and decoding booleans.\n * @returns A `FixedSizeCodec<boolean, boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding and decoding booleans using a `u8` (default).\n * ```ts\n * const codec = getBooleanCodec();\n *\n * codec.encode(false); // 0x00\n * codec.encode(true);  // 0x01\n *\n * codec.decode(new Uint8Array([0x00])); // false\n * codec.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @example\n * Encoding and decoding booleans using a custom number codec.\n * ```ts\n * const codec = getBooleanCodec({ size: getU16Codec() });\n *\n * codec.encode(false); // 0x0000\n * codec.encode(true);  // 0x0100\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * ```\n *\n * @remarks\n * Separate {@link getBooleanEncoder} and {@link getBooleanDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBooleanEncoder().encode(true);\n * const value = getBooleanDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for raw byte arrays.\n *\n * This encoder writes byte arrays exactly as provided without modification.\n *\n * The size of the encoded byte array is determined by the length of the input.\n * - To enforce a fixed size, consider using {@link fixEncoderSize}.\n * - To add a size prefix, use {@link addEncoderSizePrefix}.\n * - To add a sentinel value, use {@link addEncoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeEncoder<ReadonlyUint8Array | Uint8Array>`.\n *\n * @example\n * Encoding a byte array as-is.\n * ```ts\n * const encoder = getBytesEncoder();\n *\n * encoder.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * encoder.encode(new Uint8Array([255, 0, 127])); // 0xff007f\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder for raw byte arrays.\n *\n * This decoder reads byte arrays exactly as provided without modification.\n *\n * The decoded byte array extends from the provided offset to the end of the input.\n * - To enforce a fixed size, consider using {@link fixDecoderSize}.\n * - To add a size prefix, use {@link addDecoderSizePrefix}.\n * - To add a sentinel value, use {@link addDecoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeDecoder<ReadonlyUint8Array>`.\n *\n * @example\n * Decoding a byte array as-is.\n * ```ts\n * const decoder = getBytesDecoder();\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Uint8Array([1, 2, 3])\n * decoder.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding raw byte arrays.\n *\n * This codec serializes and deserializes byte arrays without modification.\n *\n * The size of the encoded and decoded byte array is determined dynamically.\n * This means, when reading, the codec will consume all remaining bytes in the input.\n * - To enforce a fixed size, consider using {@link fixCodecSize}.\n * - To add a size prefix, use {@link addCodecSizePrefix}.\n * - To add a sentinel value, use {@link addCodecSentinel}.\n *\n * @returns A `VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array>`.\n *\n * @example\n * Encoding and decoding a byte array.\n * ```ts\n * const codec = getBytesCodec();\n *\n * codec.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * codec.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @remarks\n * Separate {@link getBytesEncoder} and {@link getBytesDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBytesEncoder().encode(new Uint8Array([1, 2, 3]));\n * const value = getBytesDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBytesEncoder}\n * @see {@link getBytesDecoder}\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Returns an encoder that always writes a predefined constant byte sequence.\n *\n * This encoder ensures that encoding always produces the specified byte array,\n * ignoring any input values.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence that will be written during encoding.\n *\n * @param constant - The predefined byte array to encode.\n * @returns A `FixedSizeEncoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding a constant magic number.\n * ```ts\n * const encoder = getConstantEncoder(new Uint8Array([1, 2, 3, 4]));\n *\n * const bytes = encoder.encode();\n * // 0x01020304\n * //    The predefined 4-byte constant.\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder that verifies a predefined constant byte sequence.\n *\n * This decoder reads the next bytes and checks that they match the provided constant.\n * If the bytes differ, it throws an error.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence expected during decoding.\n *\n * @param constant - The predefined byte array to verify.\n * @returns A `FixedSizeDecoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Decoding a constant magic number.\n * ```ts\n * const decoder = getConstantDecoder(new Uint8Array([1, 2, 3]));\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Passes\n * decoder.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes a predefined constant byte sequence.\n *\n * - **Encoding:** Always writes the specified byte array.\n * - **Decoding:** Asserts that the next bytes match the constant, throwing an error if they do not.\n *\n * This is useful for encoding fixed byte patterns required in a binary format or to use in\n * conjunction with other codecs such as {@link getHiddenPrefixCodec} or {@link getHiddenSuffixCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence to encode and verify during decoding.\n *\n * @param constant - The predefined byte array to encode and assert during decoding.\n * @returns A `FixedSizeCodec<void, void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding and decoding a constant magic number.\n * ```ts\n * const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n *\n * codec.encode(); // 0x010203\n * codec.decode(new Uint8Array([1, 2, 3])); // Passes\n * codec.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @remarks\n * Separate {@link getConstantEncoder} and {@link getConstantDecoder} functions are available.\n *\n * ```ts\n * const bytes = getConstantEncoder(new Uint8Array([1, 2, 3])).encode();\n * getConstantDecoder(new Uint8Array([1, 2, 3])).decode(bytes);\n * ```\n *\n * @see {@link getConstantEncoder}\n * @see {@link getConstantDecoder}\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for a tuple that can be encoded using a tuple codec.\n *\n * This type maps each provided item encoder to its corresponding value type.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n */\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for a tuple that can be decoded using a tuple codec.\n *\n * This type maps each provided item decoder to its corresponding value type.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n */\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for tuples.\n *\n * This encoder serializes a fixed-size array (tuple) by encoding its items\n * sequentially using the provided item encoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n *\n * @param items - The encoders for each item in the tuple.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding tuples.\n *\n * @example\n * Encoding a tuple with 2 items.\n * ```ts\n * const encoder = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()]);\n *\n * const bytes = encoder.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for tuples.\n *\n * This decoder deserializes a fixed-size array (tuple) by decoding its items\n * sequentially using the provided item decoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n *\n * @param items - The decoders for each item in the tuple.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding tuples.\n *\n * @example\n * Decoding a tuple with 2 items.\n * ```ts\n * const decoder = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()]);\n *\n * const tuple = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // ['Alice', 42]\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding tuples.\n *\n * This codec serializes tuples by encoding and decoding each item sequentially.\n *\n * Unlike the {@link getArrayCodec} codec, each item in the tuple has its own codec\n * and, therefore, can be of a different type.\n *\n * @typeParam TItems - An array of codecs, each corresponding to a tuple element.\n *\n * @param items - The codecs for each item in the tuple.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding tuples.\n *\n * @example\n * Encoding and decoding a tuple with 2 items.\n * ```ts\n * const codec = getTupleCodec([fixCodecSize(getUtf8Codec(), 5), getU8Codec()]);\n *\n * const bytes = codec.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n *\n * const tuple = codec.decode(bytes);\n * // ['Alice', 42]\n * ```\n *\n * @remarks\n * Separate {@link getTupleEncoder} and {@link getTupleDecoder} functions are available.\n *\n * ```ts\n * const bytes = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()])\n *   .encode(['Alice', 42]);\n *\n * const tuple = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()])\n *   .decode(bytes);\n * ```\n *\n * @see {@link getTupleEncoder}\n * @see {@link getTupleDecoder}\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for values that can be encoded using a union codec.\n *\n * This type maps the provided variant encoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n */\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Infers the TypeScript type for values that can be decoded using a union codec.\n *\n * This type maps the provided variant decoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n */\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype UnionEncoder<TVariants extends readonly Encoder<unknown>[]> = TVariants extends readonly FixedSizeEncoder<any>[]\n    ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants>>\n    : Encoder<GetEncoderTypeFromVariants<TVariants>>;\n\ntype UnionDecoder<TVariants extends readonly Decoder<unknown>[]> = TVariants extends readonly FixedSizeDecoder<any>[]\n    ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants>>\n    : Decoder<GetDecoderTypeFromVariants<TVariants>>;\n\ntype UnionCodec<TVariants extends readonly Codec<unknown>[]> = TVariants extends readonly FixedSizeCodec<any>[]\n    ? FixedSizeCodec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >\n    : Codec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >;\n\n/**\n * Returns an encoder for union types.\n *\n * This encoder serializes values by selecting the correct variant encoder\n * based on the `getIndexFromValue` function.\n *\n * Unlike other codecs, this encoder does not store the variant index.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n *\n * @param variants - The encoders for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @returns An `Encoder` for encoding union values.\n *\n * @example\n * Encoding a union of numbers and booleans.\n * ```ts\n * const encoder = getUnionEncoder(\n *   [getU16Encoder(), getBooleanEncoder()],\n *   value => (typeof value === 'number' ? 0 : 1)\n * );\n *\n * encoder.encode(42);\n * // 0x2a00\n * //    Encoded number (42) as `u16`\n *\n * encoder.encode(true);\n * // 0x01\n * //    Encoded boolean (`true`) as `u8`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): UnionEncoder<TVariants> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write }) as UnionEncoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    }) as UnionEncoder<TVariants>;\n}\n\n/**\n * Returns a decoder for union types.\n *\n * This decoder deserializes values by selecting the correct variant decoder\n * based on the `getIndexFromBytes` function.\n *\n * Unlike other codecs, this decoder does not assume a stored discriminator.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n *\n * @param variants - The decoders for each variant of the union.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Decoder` for decoding union values.\n *\n * @example\n * Decoding a union of numbers and booleans.\n * ```ts\n * const decoder = getUnionDecoder(\n *   [getU16Decoder(), getBooleanDecoder()],\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * decoder.decode(new Uint8Array([0x01]));       // true\n * // Type is inferred as `number | boolean`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionDecoder<TVariants> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read }) as UnionDecoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read }) as UnionDecoder<TVariants>;\n}\n\n/**\n * Returns a codec for encoding and decoding union types.\n *\n * This codec serializes and deserializes union values by selecting the correct variant\n * based on the provided index functions.\n *\n * Unlike the {@link getDiscriminatedUnionCodec}, this codec does not assume a stored\n * discriminator and must be used with an explicit mechanism for managing discriminators.\n *\n * @typeParam TVariants - An array of codecs, each corresponding to a union variant.\n *\n * @param variants - The codecs for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Codec` for encoding and decoding union values.\n *\n * @example\n * Encoding and decoding a union of numbers and booleans.\n * ```ts\n * const codec = getUnionCodec(\n *   [getU16Codec(), getBooleanCodec()],\n *   value => (typeof value === 'number' ? 0 : 1),\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * const bytes1 = codec.encode(42); // 0x2a00\n * const value1: number | boolean = codec.decode(bytes1); // 42\n *\n * const bytes2 = codec.encode(true); // 0x01\n * const value2: number | boolean = codec.decode(bytes2); // true\n * ```\n *\n * @remarks\n * If you need a codec that includes a stored discriminator,\n * consider using {@link getDiscriminatedUnionCodec}.\n *\n * Separate {@link getUnionEncoder} and {@link getUnionDecoder} functions are also available.\n *\n * ```ts\n * const bytes = getUnionEncoder(variantEncoders, getIndexFromValue).encode(42);\n * const value = getUnionDecoder(variantDecoders, getIndexFromBytes).decode(bytes);\n * ```\n *\n * @see {@link getUnionEncoder}\n * @see {@link getUnionDecoder}\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionCodec<TVariants> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants as readonly Decoder<any>[], getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    ) as UnionCodec<TVariants>;\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Represents a discriminated union using a specific discriminator property.\n *\n * A discriminated union is a TypeScript-friendly way to represent Rust-like enums.\n * Each variant in the union is distinguished by a shared discriminator property.\n *\n * @typeParam TDiscriminatorProperty - The name of the discriminator property.\n * @typeParam TDiscriminatorValue - The type of the discriminator value.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union based on its discriminator value.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type ClickEvent = GetDiscriminatedUnionVariant<Message, '__kind', 'Move'>;\n * // -> { __kind: 'Move'; x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator property.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type MoveContent = GetDiscriminatedUnionVariantContent<Message, '__kind', 'Move'>;\n * // -> { x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/**\n * Defines the configuration for discriminated union codecs.\n *\n * This configuration controls how the discriminator is stored and named.\n *\n * @typeParam TDiscriminatorProperty - The property name of the discriminator.\n * @typeParam TDiscriminatorSize - The codec used for the discriminator prefix.\n */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec used to encode/decode the discriminator prefix.\n     * @defaultValue `u8` prefix\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype UnionEncoder<TVariants extends Variants<Encoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeEncoder<any>>\n        ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionDecoder<TVariants extends Variants<Decoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeDecoder<any>>\n        ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionCodec<TVariants extends Variants<Codec<unknown, unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeCodec<any, any>>\n        ? FixedSizeCodec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >\n        : Codec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >;\n\n/**\n * Returns an encoder for discriminated unions.\n *\n * This encoder serializes objects that follow the discriminated union pattern\n * by prefixing them with a numerical discriminator that represents their variant.\n *\n * Unlike {@link getUnionEncoder}, this encoder automatically extracts and processes\n * the discriminator property (default: `__kind`) from each variant.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant encoders as `[discriminator, encoder]` pairs.\n * @param config - Configuration options for encoding.\n * @returns An `Encoder` for encoding discriminated union objects.\n *\n * @example\n * Encoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageEncoder = getDiscriminatedUnionEncoder([\n *   ['Quit', getUnitEncoder()],\n *   ['Write', getStructEncoder([['fields', getTupleEncoder([addCodecSizePrefix(getUtf8Encoder(), getU32Encoder())])]])],\n *   ['Move', getStructEncoder([['x', getI32Encoder()], ['y', getI32Encoder()]])]\n * ]);\n *\n * messageEncoder.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): UnionEncoder<TVariants, TDiscriminatorProperty> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    ) as UnionEncoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a decoder for discriminated unions.\n *\n * This decoder deserializes objects that follow the discriminated union pattern\n * by **reading a numerical discriminator** and mapping it to the corresponding variant.\n *\n * Unlike {@link getUnionDecoder}, this decoder automatically inserts the discriminator\n * property (default: `__kind`) into the decoded object.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant decoders as `[discriminator, decoder]` pairs.\n * @param config - Configuration options for decoding.\n * @returns A `Decoder` for decoding discriminated union objects.\n *\n * @example\n * Decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageDecoder = getDiscriminatedUnionDecoder([\n *   ['Quit', getUnitDecoder()],\n *   ['Write', getStructDecoder([['fields', getTupleDecoder([addCodecSizePrefix(getUtf8Decoder(), getU32Decoder())])]])],\n *   ['Move', getStructDecoder([['x', getI32Decoder()], ['y', getI32Decoder()]])]\n * ]);\n *\n * messageDecoder.decode(new Uint8Array([0x02,0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00]));\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): UnionDecoder<TVariants, TDiscriminatorProperty> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    ) as UnionDecoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a codec for encoding and decoding {@link DiscriminatedUnion}.\n *\n * A {@link DiscriminatedUnion} is a TypeScript representation of Rust-like enums, where\n * each variant is distinguished by a discriminator field (default: `__kind`).\n *\n * This codec inserts a numerical prefix to represent the variant index.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant codecs as `[discriminator, codec]` pairs.\n * @param config - Configuration options for encoding/decoding.\n * @returns A `Codec` for encoding and decoding discriminated union objects.\n *\n * @example\n * Encoding and decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Quit', getUnitCodec()],\n *   ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n *   ['Move', getStructCodec([['x', getI32Codec()], ['y', getI32Codec()]])]\n * ]);\n *\n * messageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n *\n * const value = messageCodec.decode(bytes);\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @example\n * Using a `u32` discriminator instead of `u8`.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { size: getU32Codec() });\n *\n * codec.encode({ __kind: 'Quit' });\n * // 0x00000000\n * //   ------ 4-byte discriminator (Index 0)\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n * // { __kind: 'Quit' }\n * ```\n *\n * @example\n * Customizing the discriminator property.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { discriminator: 'message' });\n *\n * codec.encode({ message: 'Quit' }); // 0x00\n * codec.decode(new Uint8Array([0x00])); // { message: 'Quit' }\n * ```\n *\n * @remarks\n * Separate `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder` functions are available.\n *\n * ```ts\n * const bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\n * const message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n * ```\n *\n * @see {@link getDiscriminatedUnionEncoder}\n * @see {@link getDiscriminatedUnionDecoder}\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): UnionCodec<TVariants, TDiscriminatorProperty> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config) as Encoder<\n            GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    ) as UnionCodec<TVariants, TDiscriminatorProperty>;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/**\n * Defines the configuration options for enum codecs.\n *\n * The `size` option determines the numerical encoding used for the enum's discriminant.\n * By default, enums are stored as a `u8` (1 byte).\n *\n * The `useValuesAsDiscriminators` option allows mapping the actual enum values\n * as discriminators instead of using their positional index.\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the enum discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * If set to `true`, the enum values themselves will be used as discriminators.\n     * This is only valid for numerical enum values.\n     *\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Returns an encoder for enums.\n *\n * This encoder serializes enums as a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding the enum.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding enums.\n *\n * @example\n * Encoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const encoder = getEnumEncoder(Direction);\n *\n * encoder.encode(Direction.Up);    // 0x00\n * encoder.encode(Direction.Down);  // 0x01\n * encoder.encode(Direction.Left);  // 0x02\n * encoder.encode(Direction.Right); // 0x03\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Returns a decoder for enums.\n *\n * This decoder deserializes enums from a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for decoding the enum.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding enums.\n *\n * @example\n * Decoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const decoder = getEnumDecoder(Direction);\n *\n * decoder.decode(new Uint8Array([0x00])); // Direction.Up\n * decoder.decode(new Uint8Array([0x01])); // Direction.Down\n * decoder.decode(new Uint8Array([0x02])); // Direction.Left\n * decoder.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding enums.\n *\n * This codec serializes enums as a numerical discriminator, allowing them\n * to be efficiently stored and reconstructed from binary data.\n *\n * By default, the discriminator is derived from the positional index\n * of the enum variant, but it can be configured to use the enum's numeric values instead.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding and decoding the enum.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding enums.\n *\n * @example\n * Encoding and decoding enums using positional indexes.\n * ```ts\n * enum Direction { Up, Down, Left, Right }\n * const codec = getEnumCodec(Direction);\n *\n * codec.encode(Direction.Up);    // 0x00\n * codec.encode(Direction.Down);  // 0x01\n * codec.encode(Direction.Left);  // 0x02\n * codec.encode(Direction.Right); // 0x03\n *\n * codec.decode(new Uint8Array([0x00])); // Direction.Up\n * codec.decode(new Uint8Array([0x01])); // Direction.Down\n * codec.decode(new Uint8Array([0x02])); // Direction.Left\n * codec.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @example\n * Encoding and decoding enums using their numeric values.\n * ```ts\n * enum GameDifficulty { Easy = 1, Normal = 4, Hard = 7, Expert = 9 }\n * const codec = getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true });\n *\n * codec.encode(GameDifficulty.Easy);   // 0x01\n * codec.encode(GameDifficulty.Normal); // 0x04\n * codec.encode(GameDifficulty.Hard);   // 0x07\n * codec.encode(GameDifficulty.Expert); // 0x09\n *\n * codec.decode(new Uint8Array([0x01])); // GameDifficulty.Easy\n * codec.decode(new Uint8Array([0x04])); // GameDifficulty.Normal\n * codec.decode(new Uint8Array([0x07])); // GameDifficulty.Hard\n * codec.decode(new Uint8Array([0x09])); // GameDifficulty.Expert\n * ```\n *\n * Note that, when using values as discriminators, the enum values must be numerical.\n * Otherwise, an error will be thrown.\n *\n * ```ts\n * enum GameDifficulty { Easy = 'EASY', Normal = 'NORMAL', Hard = 'HARD' }\n * getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true }); // Throws an error.\n * ```\n *\n * @example\n * Using a custom discriminator size.\n * ```ts\n * enum Status { Pending, Approved, Rejected }\n * const codec = getEnumCodec(Status, { size: getU16Codec() });\n *\n * codec.encode(Status.Pending);  // 0x0000\n * codec.encode(Status.Approved); // 0x0100\n * codec.encode(Status.Rejected); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // Status.Pending\n * codec.decode(new Uint8Array([0x01, 0x00])); // Status.Approved\n * codec.decode(new Uint8Array([0x02, 0x00])); // Status.Rejected\n * ```\n *\n * @remarks\n * Separate {@link getEnumEncoder} and {@link getEnumDecoder} functions are available.\n *\n * ```ts\n * const bytes = getEnumEncoder(Direction).encode(Direction.Up);\n * const value = getEnumDecoder(Direction).decode(bytes);\n * ```\n *\n * @see {@link getEnumEncoder}\n * @see {@link getEnumDecoder}\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that prefixes encoded values with hidden data.\n *\n * This encoder applies a list of void encoders before encoding the main value.\n * The prefixed data is encoded before the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param prefixedEncoders - A list of void encoders that produce the hidden prefix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden prefix.\n *\n * @example\n * Prefixing a value with constants.\n * ```ts\n * const encoder = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden prefixed data before decoding the main value.\n *\n * This decoder applies a list of void decoders before decoding the main value.\n * The prefixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param prefixedDecoders - A list of void decoders that produce the hidden prefix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden prefix.\n *\n * @example\n * Decoding a value with prefixed constants.\n * ```ts\n * const decoder = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 0x48, 0x65, 0x6C, 0x6C, 0x6F]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden prefix.\n *\n * - **Encoding:** Prefixes the value with hidden data before encoding.\n * - **Decoding:** Skips the hidden prefix before decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param prefixedCodecs - A list of void codecs that produce the hidden prefix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden prefix.\n *\n * @example\n * Encoding and decoding a value with prefixed constants.\n * ```ts\n * const codec = getHiddenPrefixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes before a value, consider using {@link padLeftCodec} instead.\n *\n * Separate {@link getHiddenPrefixEncoder} and {@link getHiddenPrefixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenPrefixEncoder}\n * @see {@link getHiddenPrefixDecoder}\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that appends hidden data after the encoded value.\n *\n * This encoder applies a list of void encoders after encoding the main value.\n * The suffixed data is encoded after the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param suffixedEncoders - A list of void encoders that produce the hidden suffix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden suffix.\n *\n * @example\n * Suffixing a value with constants.\n * ```ts\n * const encoder = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden suffixed data after decoding the main value.\n *\n * This decoder applies a list of void decoders after decoding the main value.\n * The suffixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param suffixedDecoders - A list of void decoders that produce the hidden suffix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden suffix.\n *\n * @example\n * Decoding a value with suffixed constants.\n * ```ts\n * const decoder = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F, 1, 2, 3, 4, 5, 6]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden suffix.\n *\n * - **Encoding:** Appends hidden data after encoding the main value.\n * - **Decoding:** Skips the hidden suffix after decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param suffixedCodecs - A list of void codecs that produce the hidden suffix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden suffix.\n *\n * @example\n * Encoding and decoding a value with suffixed constants.\n * ```ts\n * const codec = getHiddenSuffixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes after a value, consider using {@link padRightCodec} instead.\n *\n * Separate {@link getHiddenSuffixEncoder} and {@link getHiddenSuffixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenSuffixEncoder}\n * @see {@link getHiddenSuffixDecoder}\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the configuration options for literal union codecs.\n *\n * A literal union codec encodes values from a predefined set of literals.\n * The `size` option determines the numerical encoding used for the discriminant.\n * By default, literals are stored as a `u8` (1 byte).\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type LiteralUnionCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variant = bigint | boolean | number | string | null | undefined;\ntype GetTypeFromVariants<TVariants extends readonly Variant[]> = TVariants[number];\n\n/**\n * Returns an encoder for literal unions.\n *\n * This encoder serializes a value from a predefined set of literals\n * as a numerical index representing its position in the `variants` array.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding the literal union.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding literal unions.\n *\n * @example\n * Encoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeEncoder = getLiteralUnionEncoder(['small', 'medium', 'large']);\n *\n * sizeEncoder.encode('small');  // 0x00\n * sizeEncoder.encode('medium'); // 0x01\n * sizeEncoder.encode('large');  // 0x02\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> = {},\n): Encoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Encoder();\n    return transformEncoder(discriminator, variant => {\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants,\n            });\n        }\n        return index;\n    });\n}\n\n/**\n * Returns a decoder for literal unions.\n *\n * This decoder deserializes a numerical index into a corresponding\n * value from a predefined set of literals.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for decoding the literal union.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding literal unions.\n *\n * @example\n * Decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeDecoder = getLiteralUnionDecoder(['small', 'medium', 'large']);\n *\n * sizeDecoder.decode(new Uint8Array([0x00])); // 'small'\n * sizeDecoder.decode(new Uint8Array([0x01])); // 'medium'\n * sizeDecoder.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> = {},\n): Decoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Decoder();\n    return transformDecoder(discriminator, (index: bigint | number) => {\n        if (index < 0 || index >= variants.length) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0,\n            });\n        }\n        return variants[Number(index)];\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding literal unions.\n *\n * A literal union codec serializes and deserializes values\n * from a predefined set of literals, using a numerical index\n * to represent each value in the `variants` array.\n *\n * This allows efficient storage and retrieval of common\n * predefined values such as enum-like structures in TypeScript.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding and decoding the literal union.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding literal unions.\n *\n * @example\n * Encoding and decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeCodec = getLiteralUnionCodec(['small', 'medium', 'large']);\n *\n * sizeCodec.encode('small');  // 0x00\n * sizeCodec.encode('medium'); // 0x01\n * sizeCodec.encode('large');  // 0x02\n *\n * sizeCodec.decode(new Uint8Array([0x00])); // 'small'\n * sizeCodec.decode(new Uint8Array([0x01])); // 'medium'\n * sizeCodec.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @example\n * Encoding and decoding a union of number literals.\n * ```ts\n * type Level = 10 | 20 | 30;\n * const levelCodec = getLiteralUnionCodec([10, 20, 30]);\n *\n * levelCodec.encode(10);  // 0x00\n * levelCodec.encode(20);  // 0x01\n * levelCodec.encode(30);  // 0x02\n *\n * levelCodec.decode(new Uint8Array([0x00])); // 10\n * levelCodec.decode(new Uint8Array([0x01])); // 20\n * levelCodec.decode(new Uint8Array([0x02])); // 30\n * ```\n *\n * @example\n * Using a custom discriminator size with different variant types.\n * ```ts\n * type MaybeBoolean = false | true | \"either\";\n * const codec = getLiteralUnionCodec([false, true, 'either'], { size: getU16Codec() });\n *\n * codec.encode(false);    // 0x0000\n * codec.encode(true);     // 0x0100\n * codec.encode('either'); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * codec.decode(new Uint8Array([0x02, 0x00])); // 'either'\n * ```\n *\n * @remarks\n * Separate {@link getLiteralUnionEncoder} and {@link getLiteralUnionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getLiteralUnionEncoder(['red', 'green', 'blue']).encode('green');\n * const value = getLiteralUnionDecoder(['red', 'green', 'blue']).decode(bytes);\n * ```\n *\n * @see {@link getLiteralUnionEncoder}\n * @see {@link getLiteralUnionDecoder}\n */\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> = {},\n): Codec<GetTypeFromVariants<TVariants>> {\n    return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Defines the configuration options for map codecs.\n *\n * The `size` option determines how the number of entries in the map is stored.\n * It can be:\n * - A {@link NumberCodec} to prefix the map with its size.\n * - A fixed number of entries.\n * - `'remainder'`, which infers the number of entries based on the remaining bytes.\n *   This option is only available for fixed-size keys and values.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used for the size prefix.\n */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the map.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for maps.\n *\n * This encoder serializes maps where the keys and values are encoded\n * using the provided key and value encoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n *\n * @param key - The encoder for the map's keys.\n * @param value - The encoder for the map's values.\n * @param config - Configuration options for encoding the map.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding maps.\n *\n * @example\n * Encoding a map with a `u32` size prefix.\n * ```ts\n * const encoder = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder());\n * const bytes = encoder.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Returns a decoder for maps.\n *\n * This decoder deserializes maps where the keys and values are decoded\n * using the provided key and value decoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The decoder for the map's keys.\n * @param value - The decoder for the map's values.\n * @param config - Configuration options for decoding the map.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding maps.\n *\n * @example\n * Decoding a map with a `u32` size prefix.\n * ```ts\n * const decoder = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder());\n * const map = decoder.decode(new Uint8Array([\n *   0x02,0x00,0x00,0x00,0x61,0x6c,0x69,0x63,0x65,0x2a,0x62,0x6f,0x62,0x00,0x00,0x05\n * ]));\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding maps.\n *\n * This codec serializes maps where the key/value pairs are encoded\n * and decoded one after another using the provided key and value codecs.\n * The number of entries is determined by the `size` configuration and\n * defaults to a `u32` size prefix.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The codec for the map's keys.\n * @param value - The codec for the map's values.\n * @param config - Configuration options for encoding and decoding the map.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding maps.\n *\n * @example\n * Encoding and decoding a map with a `u32` size prefix (default).\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec());\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with a `u16` size prefix.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x0200616c6963652a626f62000005\n * //   |   |         | |          Value (5)\n * //   |   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |   |          Value (42)\n * //   |    Key (\"alice\", 5 bytes fixed)\n * //    2-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a fixed-size map.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 2 });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with remainder size.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n * // No size prefix, the size is inferred from the remaining bytes.\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @remarks\n * Separate {@link getMapEncoder} and {@link getMapDecoder} functions are available.\n * ```ts\n * const bytes = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()).encode(new Map([['alice', 42]]));\n * const map = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getMapEncoder}\n * @see {@link getMapDecoder}\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for `void` values.\n *\n * This encoder writes nothing to the byte array and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op encoder,\n * such as empty variants in {@link getDiscriminatedUnionEncoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeEncoder<void, 0>`, representing an empty encoder.\n *\n * @example\n * Encoding a `void` value.\n * ```ts\n * getUnitEncoder().encode(undefined); // Produces an empty byte array.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Returns a decoder for `void` values.\n *\n * This decoder always returns `undefined` and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op decoder,\n * such as empty variants in {@link getDiscriminatedUnionDecoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeDecoder<void, 0>`, representing an empty decoder.\n *\n * @example\n * Decoding a `void` value.\n * ```ts\n * getUnitDecoder().decode(anyBytes); // Returns `undefined`.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Returns a codec for `void` values.\n *\n * This codec does nothing when encoding or decoding and has a fixed size of 0 bytes.\n * Namely, it always returns `undefined` when decoding and produces an empty byte array when encoding.\n *\n * This can be useful when working with structures that require a no-op codec,\n * such as empty variants in {@link getDiscriminatedUnionCodec}.\n *\n * @returns A `FixedSizeCodec<void, void, 0>`, representing an empty codec.\n *\n * @example\n * Encoding and decoding a `void` value.\n * ```ts\n * const codec = getUnitCodec();\n *\n * codec.encode(undefined); // Produces an empty byte array.\n * codec.decode(new Uint8Array([])); // Returns `undefined`.\n * ```\n *\n * @example\n * Using unit codecs as empty variants in a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Enter' }\n *   | { __kind: 'Leave' }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Enter', getUnitCodec()], // <- No-op codec for empty data\n *   ['Leave', getUnitCodec()], // <- No-op codec for empty data\n *   ['Move', getStructCodec([...])]\n * ]);\n * ```\n *\n * @remarks\n * Separate {@link getUnitEncoder} and {@link getUnitDecoder} functions are available.\n *\n * ```ts\n * const bytes = getUnitEncoder().encode();\n * const value = getUnitDecoder().decode(bytes);\n * ```\n *\n * @see {@link getUnitEncoder}\n * @see {@link getUnitDecoder}\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/**\n * Defines the configuration options for nullable codecs.\n *\n * This configuration controls how nullable values are encoded and decoded.\n *\n * By default, nullable values are prefixed with a `u8` (0 = `null`, 1 = present).\n * The `noneValue` and `prefix` options allow customizing this behavior.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n * @see {@link getNullableCodec}\n */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how `null` values are represented in the encoded data.\n     *\n     * - By default, `null` values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec.\n     * - Custom byte array: `null` values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; `null` values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between `null` and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = null`, `1 = present`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines `null`.\n     *   If no `noneValue` is set, `null` is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values, allowing `null` values to be encoded.\n *\n * This encoder serializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are replaced with the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding nullable values.\n *\n * @example\n * Encoding an optional number.\n * ```ts\n * const encoder = getNullableEncoder(getU32Encoder());\n *\n * encoder.encode(null); // 0x00\n * encoder.encode(42);   // 0x012a000000\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Returns a decoder for optional values, allowing `null` values to be recognized.\n *\n * This decoder deserializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are identified by zeroes.\n * - If `noneValue` is a byte array, `null` values match the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding nullable values.\n *\n * @example\n * Decoding an optional number.\n * ```ts\n * const decoder = getNullableDecoder(getU32Decoder());\n *\n * decoder.decode(new Uint8Array([0x00])); // null\n * decoder.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values, allowing `null` values to be handled.\n *\n * This codec serializes and deserializes optional values using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present).\n *    This can be customized using a custom number codec or even disabled by setting\n *    the `prefix` to `null`.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are represented by the provided constant.\n *\n * For more details on the configuration options, see {@link NullableCodecConfig}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding optional values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding nullable values.\n *\n * @example\n * Encoding and decoding an optional number using a `u8` prefix (default).\n * ```ts\n * const codec = getNullableCodec(getU32Codec());\n *\n * codec.encode(null); // 0x00\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding an optional number using a fixed-size codec, by filling `null` values with zeroes.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), { noneValue: 'zeroes' });\n *\n * codec.encode(null); // 0x0000000000\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with zeroes and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), {\n *   noneValue: 'zeroes',\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0x00000000\n * codec.encode(42);   // 0x2a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0xffff\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([0xff, 0xff])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @example\n * Identifying `null` values by the absence of bytes.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), { prefix: null });\n *\n * codec.encode(null); // Empty bytes\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @remarks\n * Separate {@link getNullableEncoder} and {@link getNullableDecoder} functions are available.\n *\n * ```ts\n * const bytes = getNullableEncoder(getU32Encoder()).encode(42);\n * const value = getNullableDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/**\n * Defines the configuration options for set codecs.\n *\n * This configuration allows specifying how the size of the set is encoded.\n * The `size` option can be:\n *\n * - A {@link NumberCodec}, {@link NumberEncoder}, or {@link NumberDecoder} to store the size as a prefix.\n * - A fixed number of items, enforcing a strict length.\n * - The string `'remainder'` to infer the set size from the remaining bytes (only for fixed-size items).\n *\n * @typeParam TPrefix - The type used for encoding the size of the set.\n */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size encoding strategy for the set.\n     * @defaultValue Uses a `u32` prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for sets of items.\n *\n * This encoder serializes `Set<T>` values by encoding each item using the provided item encoder.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n *\n * @param item - The encoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns An `Encoder<Set<TFrom>>` for encoding sets of items.\n *\n * @example\n * Encoding a set of `u8` numbers.\n * ```ts\n * const encoder = getSetEncoder(getU8Encoder());\n * const bytes = encoder.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Returns a decoder for sets of items.\n *\n * This decoder deserializes a `Set<T>` from a byte array by decoding each item using the provided item decoder.\n * The number of items is determined by a `u32` size prefix by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The decoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Decoder<Set<TTo>>` for decoding sets of items.\n *\n * @example\n * Decoding a set of `u8` numbers.\n * ```ts\n * const decoder = getSetDecoder(getU8Decoder());\n * const value = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // new Set([1, 2, 3])\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Returns a codec for encoding and decoding sets of items.\n *\n * This codec serializes `Set<T>` values by encoding each item using the provided item codec.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The codec to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Codec<Set<TFrom>, Set<TTo>>` for encoding and decoding sets.\n *\n * @example\n * Encoding and decoding a set of `u8` numbers.\n * ```ts\n * const codec = getSetCodec(getU8Codec());\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n *\n * const value = codec.decode(bytes);\n * // new Set([1, 2, 3])\n * ```\n *\n * @example\n * Using a `u16` prefix for size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix indicating 3 items.\n * ```\n *\n * @example\n * Using a fixed-size set.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 3 });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- Exactly 3 items of 1 byte each.\n * ```\n *\n * @example\n * Using remainder to infer set size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remaining bytes.\n * ```\n *\n * @remarks\n * Separate {@link getSetEncoder} and {@link getSetDecoder} functions are available.\n *\n * ```ts\n * const bytes = getSetEncoder(getU8Encoder()).encode(new Set([1, 2, 3]));\n * const value = getSetDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getSetEncoder}\n * @see {@link getSetDecoder}\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Represents a collection of named fields used in struct codecs.\n *\n * Each field is defined as a tuple containing:\n * - A string key representing the field name.\n * - A codec used to encode and decode the field's value.\n *\n * @typeParam T - The codec type used for each field.\n */\ntype Fields<T> = readonly (readonly [string, T])[];\n\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\n/**\n * Infers the TypeScript type for an object that can be encoded using a struct codec.\n *\n * This type maps the provided field encoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n */\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for an object that can be decoded using a struct codec.\n *\n * This type maps the provided field decoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n */\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for custom objects.\n *\n * This encoder serializes an object by encoding its fields sequentially,\n * using the provided field encoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n *\n * @param fields - The name and encoder of each field.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding custom objects.\n *\n * @example\n * Encoding a custom struct.\n * ```ts\n * const encoder = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]);\n *\n * const bytes = encoder.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for custom objects.\n *\n * This decoder deserializes an object by decoding its fields sequentially,\n * using the provided field decoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n *\n * @param fields - The name and decoder of each field.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding custom objects.\n *\n * @example\n * Decoding a custom struct.\n * ```ts\n * const decoder = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]);\n *\n * const struct = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding custom objects.\n *\n * This codec serializes objects by encoding and decoding each field sequentially.\n *\n * @typeParam TFields - The fields of the struct, each paired with a codec.\n *\n * @param fields - The name and codec of each field.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding custom objects.\n *\n * @example\n * Encoding and decoding a custom struct.\n * ```ts\n * const codec = getStructCodec([\n *   ['name', fixCodecSize(getUtf8Codec(), 5)],\n *   ['age', getU8Codec()]\n * ]);\n *\n * const bytes = codec.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n *\n * const struct = codec.decode(bytes);\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @remarks\n * Separate {@link getStructEncoder} and {@link getStructDecoder} functions are available.\n *\n * ```ts\n * const bytes = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]).encode({ name: 'Alice', age: 42 });\n *\n * const struct = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getStructEncoder}\n * @see {@link getStructDecoder}\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n"],"names":["newOffset","createEncoder","createDecoder","combineCodec","SolanaError","getEncodedSize","isFixedSize","getU8Encoder","transformEncoder","getU8Decoder","transformDecoder","containsBytes"],"mappings":"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"}},
    {"offset": {"line": 6253, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/instructions/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instructions/src/instruction.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instructions/src/roles.ts"],"sourcesContent":["import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { AccountLookupMeta, AccountMeta } from './accounts';\n\n/**\n * An instruction destined for a given program.\n *\n * @example\n * ```ts\n * type StakeProgramInstruction = Instruction<'StakeConfig11111111111111111111111111111111'>;\n * ```\n */\nexport interface Instruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: ReadonlyUint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\n/**\n * An instruction that loads certain accounts.\n *\n * @example\n * ```ts\n * type InstructionWithTwoAccounts = InstructionWithAccounts<\n *     [\n *         WritableAccount, // First account\n *         RentSysvar, // Second account\n *     ]\n * >;\n * ```\n */\nexport interface InstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[],\n> extends Instruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\n/**\n * An instruction whose data conforms to a certain type.\n *\n * This is most useful when you have a branded `Uint8Array` that represents a particular\n * instruction's data.\n *\n * @example A type for the \\`AdvanceNonce\\` instruction of the System program\n * ```ts\n * type AdvanceNonceAccountInstruction<\n *     TNonceAccountAddress extends string = string,\n *     TNonceAuthorityAddress extends string = string,\n * > = Instruction<'11111111111111111111111111111111'> &\n *     InstructionWithAccounts<\n *         [\n *             WritableAccount<TNonceAccountAddress>,\n *             ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n *             ReadonlySignerAccount<TNonceAuthorityAddress>,\n *         ]\n *     > &\n *     InstructionWithData<AdvanceNonceAccountInstructionData>;\n * ```\n */\nexport interface InstructionWithData<TData extends ReadonlyUint8Array> extends Instruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Describes the purpose for which an account participates in a transaction.\n *\n * Every account that participates in a transaction can be read from, but only ones that you mark as\n * writable may be written to, and only ones that you indicate must sign the transaction will gain\n * the privileges associated with signers at runtime.\n *\n * |                               | `isSigner` | `isWritable` |\n * | ----------------------------- | ---------- | ------------ |\n * | `AccountRole.READONLY`        | &#x274c;   | &#x274c;     |\n * | `AccountRole.WRITABLE`        | &#x274c;   | &#x2705;     |\n * | `AccountRole.READONLY_SIGNER` | &#x2705;   | &#x274c;     |\n * | `AccountRole.WRITABLE_SIGNER` | &#x2705;   | &#x2705;     |\n */\nexport enum AccountRole {\n    // Bitflag guide: is signer  is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\n// Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\n/**\n * @returns An {@link AccountRole} representing the non-signer variant of the supplied role.\n */\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the read-only variant of the supplied role.\n */\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a signer. Also refines the\n * TypeScript type of the supplied role.\n */\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a writable account. Also\n * refines the TypeScript type of the supplied role.\n */\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\n/**\n * Given two {@link AccountRole | AccountRoles}, will return the {@link AccountRole} that grants the\n * highest privileges of both.\n *\n * @example\n * ```ts\n * // Returns `AccountRole.WRITABLE_SIGNER`\n * mergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n * ```\n */\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\n/**\n * @returns An {@link AccountRole} representing the signer variant of the supplied role.\n */\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the writable variant of the supplied role.\n */\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n"],"names":["AccountRole"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CO,SAAS,uBAAA,CACZ,WAAA,EACA,cAAA,EAC0E;IAC1E,OAAO,YAAY,cAAA,KAAmB,cAAA;AAC1C;AAEO,SAAS,6BAAA,CACZ,WAAA,EACA,cAAA,EACkF;IAClF,IAAI,WAAA,CAAY,cAAA,KAAmB,cAAA,EAAgB;QAC/C,MAAM,IAAI,2KAAA,CAAY,8MAAA,EAAgD;YAClE,sBAAsB,WAAA,CAAY,cAAA;YAClC,sBAAA,EAAwB;QAAA,CAC3B,CAAA;IACL;AACJ;AAEO,SAAS,0BAGd,WAAA,EAA6F;IAC3F,OAAO,YAAY,QAAA,KAAa,KAAA,CAAA;AACpC;AAEO,SAAS,gCAGd,WAAA,EAAqG;IACnG,IAAI,WAAA,CAAY,QAAA,KAAa,KAAA,CAAA,EAAW;QACpC,MAAM,IAAI,2KAAA,CAAY,oNAAA,EAAsD;YACxE,MAAM,WAAA,CAAY,IAAA;YAClB,gBAAgB,WAAA,CAAY,cAAA;QAAA,CAC/B,CAAA;IACL;AACJ;AA4BO,SAAS,sBAGd,WAAA,EAAqF;IACnF,OAAO,YAAY,IAAA,KAAS,KAAA,CAAA;AAChC;AAEO,SAAS,4BAGd,WAAA,EAA6F;IAC3F,IAAI,WAAA,CAAY,IAAA,KAAS,KAAA,CAAA,EAAW;QAChC,MAAM,IAAI,2KAAA,CAAY,gNAAA,EAAkD;YACpE,kBAAkB,WAAA,CAAY,QAAA,EAAU,GAAA,CAAI,CAAA,CAAA,GAAK,EAAE,OAAO,CAAA;YAC1D,gBAAgB,WAAA,CAAY,cAAA;QAAA,CAC/B,CAAA;IACL;AACJ;;AClHO,IAAK,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAAA,KAAL;IAEHA,YAAAA,CAAAA,YAAAA,CAAA,iBAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,iBAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,iBAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,iBAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,UAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,UAAA;IALQ,OAAAA,YAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA;AASZ,IAAM,iBAAA,GAAoB,CAAA;AAC1B,IAAM,mBAAA,GAAsB,CAAA;AAQrB,SAAS,yBAAyB,IAAA,EAAgC;IACrE,OAAO,OAAO,CAAC,iBAAA;AACnB;AAQO,SAAS,wBAAwB,IAAA,EAAgC;IACpE,OAAO,OAAO,CAAC,mBAAA;AACnB;AAMO,SAAS,aAAa,IAAA,EAAsF;IAC/G,OAAO,IAAA,IAAQ,CAAA,CAAA,mBAAA;AACnB;AAMO,SAAS,eAAe,IAAA,EAA+E;IAC1G,OAAA,CAAQ,OAAO,mBAAA,MAAyB,CAAA;AAC5C;AAsBO,SAAS,UAAA,CAAW,KAAA,EAAoB,KAAA,EAAiC;IAC5E,OAAO,KAAA,GAAQ,KAAA;AACnB;AAQO,SAAS,oBAAoB,IAAA,EAAgC;IAChE,OAAO,IAAA,GAAO,iBAAA;AAClB;AAQO,SAAS,sBAAsB,IAAA,EAAgC;IAClE,OAAO,IAAA,GAAO,mBAAA;AAClB"}},
    {"offset": {"line": 6357, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transaction-messages/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/blockhash.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/codecs/address-table-lookup.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/codecs/header.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/codecs/instruction.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/transaction-message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/codecs/transaction-version.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/codecs/message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compile/accounts.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compile/address-table-lookups.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compile/header.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compile/instructions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compile/lifetime-token.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compile/static-accounts.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compile/message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/compress-transaction-message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/create-transaction-message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/durable-nonce-instruction.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/durable-nonce.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/fee-payer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/instructions.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transaction-messages/src/decompile-message.ts"],"sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { TransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is TransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is TransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends Partial<TransactionMessageWithLifetime> & TransactionMessage,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import { AccountMeta, Instruction } from '@solana/instructions';\n\n/**\n * @deprecated Use `TransactionMessage` instead.\n */\n// TODO(#1147) Stop exporting this in a future major version.\nexport type BaseTransactionMessage<\n    TVersion extends TransactionVersion = TransactionVersion,\n    TInstruction extends Instruction = Instruction,\n> = Readonly<{\n    instructions: readonly TInstruction[];\n    version: TVersion;\n}>;\n\nexport const MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n\ntype LegacyInstruction<TProgramAddress extends string = string> = Instruction<TProgramAddress, readonly AccountMeta[]>;\ntype LegacyTransactionMessage = BaseTransactionMessage<'legacy', LegacyInstruction>;\ntype V0TransactionMessage = BaseTransactionMessage<0, Instruction>;\n\nexport type TransactionMessage = LegacyTransactionMessage | V0TransactionMessage;\nexport type TransactionVersion = 'legacy' | 0;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { MAX_SUPPORTED_TRANSACTION_VERSION, TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n\n            if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                    unsupportedVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = firstByte ^ VERSION_FLAG_MASK;\n                if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                    throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n                }\n                return [version as TransactionVersion, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getConstantEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getUnionEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<\n        CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n    >;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<\n            CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n        >,\n        value => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            };\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = getUnionEncoder(\n        [\n            // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n            getConstantEncoder(new Uint8Array(32)),\n            // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n            fixEncoderSize(getBase58Encoder(), 32),\n        ],\n        value => (value === undefined ? 0 : 1),\n    );\n\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', lifetimeTokenEncoder],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return createEncoder({\n        getSizeFromValue: compiledMessage => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage &\n                CompiledTransactionMessageWithLifetime & {\n                    addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n                }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups };\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime),\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { TransactionMessageWithFeePayer } from '../fee-payer';\nimport { TransactionMessageWithLifetime } from '../lifetime';\nimport { BaseTransactionMessage } from '../transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\nexport type CompiledTransactionMessageWithLifetime = Readonly<{\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n}>;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: 0;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): CompiledTransactionMessageFromTransactionMessage<TTransactionMessage> {\n    type ReturnType = CompiledTransactionMessageFromTransactionMessage<TTransactionMessage>;\n\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = (transactionMessage as Partial<TransactionMessageWithLifetime>).lifetimeConstraint;\n\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        ...(lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    } as ReturnType;\n}\n\ntype CompiledTransactionMessageFromTransactionMessage<TTransactionMessage extends BaseTransactionMessage> =\n    ForwardTransactionMessageLifetime<ForwardTransactionMessageVersion<TTransactionMessage>, TTransactionMessage>;\n\ntype ForwardTransactionMessageVersion<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends Readonly<{ version: 'legacy' }>\n        ? LegacyCompiledTransactionMessage\n        : VersionedCompiledTransactionMessage;\n\ntype ForwardTransactionMessageLifetime<\n    TCompiledTransactionMessage extends CompiledTransactionMessage,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithLifetime\n    ? CompiledTransactionMessageWithLifetime & TCompiledTransactionMessage\n    : TCompiledTransactionMessage;\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import {\n *     AddressesByLookupTableAddress,\n *     compressTransactionMessageUsingAddressLookupTables,\n * } from '@solana/transaction-messages';\n * import { fetchAddressLookupTable } from '@solana-program/address-lookup-table';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const {\n *     data: { addresses },\n * } = await fetchAddressLookupTable(rpc, lookupTableAddress);\n * const addressesByAddressLookupTable: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: addresses,\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     addressesByAddressLookupTable,\n * );\n * ```\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const programAddresses = new Set(transactionMessage.instructions.map(ix => ix.programAddress));\n    const eligibleLookupAddresses = new Set(\n        Object.values(addressesByLookupTableAddress)\n            .flatMap(a => a)\n            .filter(address => !programAddresses.has(address)),\n    );\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !eligibleLookupAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { TransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\nexport type NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is TransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsTransactionMessageWithDurableNonceLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: TransactionMessage | (TransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is TransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transaction-messages';\n * import { fetchNonce } from '@solana-program/system';\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n *\n * const {\n *     data: { blockhash },\n * } = await fetchNonce(rpc, nonceAccountAddress);\n * const nonce = blockhash as string as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends TransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends TransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = TTransactionMessage extends unknown\n    ? Omit<\n          // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n          TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n              ? TTransactionMessage\n              : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n          // 2. Remove the instructions array as we are going to replace it with a new one.\n          'instructions'\n      > & {\n          // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n          readonly instructions: TTransactionMessage['instructions'] extends readonly [\n              AdvanceNonceAccountInstruction,\n              ...infer TTail extends readonly Instruction[],\n          ]\n              ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n              : readonly [\n                    AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n                    ...TTransactionMessage['instructions'],\n                ];\n          // 4. Set the lifetime constraint to the nonce value.\n          readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n      }\n    : never;\n","import { Address } from '@solana/addresses';\n\nimport { TransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends unknown ? Omit<TTransactionMessage, 'feePayer'> : never;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends Partial<TransactionMessageWithFeePayer> & TransactionMessage,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n        TransactionMessageWithFeePayer<TFeePayerAddress>;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { TransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = TTransactionMessage extends TransactionMessage\n    ? Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n          readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n      }\n    : never;\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = TTransactionMessage extends TransactionMessage\n    ? Omit<\n          ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n          'instructions'\n      > & {\n          readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n      }\n    : never;\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransactionMessage = appendTransactionMessageInstruction(\n *     {\n *         data: getUtf8Encoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     transactionMessage,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends TransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    }) as AppendTransactionMessageInstructions<TTransactionMessage, TInstructions>;\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends TransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends TransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    }) as unknown as PrependTransactionMessageInstructions<TTransactionMessage, TInstructions>;\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BlockhashLifetimeConstraint, setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionMessageWithLifetime } from './lifetime';\nimport { TransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | BlockhashLifetimeConstraint\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    config?: DecompileTransactionMessageConfig,\n): TransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as TransactionMessage,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    ) as TransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime;\n}\n"],"names":["alphabet","SolanaError","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","transformDecoder","AccountRole","getAddressComparator","isWritableRole","isSignerRole"],"mappings":"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"}},
    {"offset": {"line": 7465, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/keys/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/keys/src/algorithm.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/keys/src/private-key.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/keys/src/public-key.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/keys/src/signatures.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/keys/src/key-pair.ts"],"sourcesContent":["export const ED25519_ALGORITHM_IDENTIFIER =\n    // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n    // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\n    Object.freeze({ name: 'Ed25519' });\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array<ArrayBuffer> {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 private key for use\n * with other methods in this package that accept\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\n * const extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n * ```\n */\nexport async function createPrivateKeyFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        'sign',\n    ]);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\n/**\n * Given an extractable [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * private key, gets the corresponding public key as a\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey).\n *\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the public\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n *\n * const publicKey = await getPublicKeyFromPrivateKey(privateKey);\n * const extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n * ```\n */\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array, toArrayBuffer } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\n/**\n * A 64-byte Ed25519 signature as a base58-encoded string.\n */\nexport type Signature = Brand<EncodedString<string, 'base58'>, 'Signature'>;\n/**\n * A 64-byte Ed25519 signature.\n *\n * Whenever you need to verify that a particular signature is, in fact, the one that would have been\n * produced by signing some known bytes using the private key associated with some known public key,\n * use the {@link verifySignature} function in this package.\n */\nexport type SignatureBytes = Brand<Uint8Array, 'SignatureBytes'>;\n\nlet base58Encoder: Encoder<string> | undefined;\n\n/**\n * Asserts that an arbitrary string is a base58-encoded Ed25519 signature.\n *\n * Useful when you receive a string from user input or an untrusted network API that you expect to\n * represent an Ed25519 signature (eg. of a transaction).\n *\n * @example\n * ```ts\n * import { assertIsSignature } from '@solana/keys';\n *\n * // Imagine a function that asserts whether a user-supplied signature is valid or not.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const signature: string = signatureInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signature` to `Signature`.\n *         assertIsSignature(signature);\n *         // At this point, `signature` is a `Signature` that can be used with the RPC.\n *         const {\n *             value: [status],\n *         } = await rpc.getSignatureStatuses([signature]).send();\n *     } catch (e) {\n *         // `signature` turned out not to be a base58-encoded signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    assertIsSignatureBytes(bytes);\n}\n\n/**\n * Asserts that an arbitrary `ReadonlyUint8Array` is an Ed25519 signature.\n *\n * Useful when you receive a `ReadonlyUint8Array` from an external interface (like the browser wallets' `signMessage` API) that you expect to\n * represent an Ed25519 signature.\n *\n * @example\n * ```ts\n * import { assertIsSignatureBytes } from '@solana/keys';\n *\n * // Imagine a function that verifies a signature.\n * function verifySignature() {\n *     // We know only that the input conforms to the `ReadonlyUint8Array` type.\n *     const signatureBytes: ReadonlyUint8Array = signatureBytesInput;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signatureBytes` to `SignatureBytes`.\n *         assertIsSignatureBytes(signatureBytes);\n *         // At this point, `signatureBytes` is a `SignatureBytes` that can be used with `verifySignature`.\n *         if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *             throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *         }\n *     } catch (e) {\n *         // `signatureBytes` turned out not to be a 64-byte Ed25519 signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignatureBytes(\n    putativeSignatureBytes: ReadonlyUint8Array,\n): asserts putativeSignatureBytes is SignatureBytes {\n    const numBytes = putativeSignatureBytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * A type guard that accepts a string as input. It will both return `true` if the string conforms to\n * the {@link Signature} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignature } from '@solana/keys';\n *\n * if (isSignature(signature)) {\n *     // At this point, `signature` has been refined to a\n *     // `Signature` that can be used with the RPC.\n *     const {\n *         value: [status],\n *     } = await rpc.getSignatureStatuses([signature]).send();\n *     setSignatureStatus(status);\n * } else {\n *     setError(`${signature} is not a transaction signature`);\n * }\n * ```\n */\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    return isSignatureBytes(bytes);\n}\n\n/**\n * A type guard that accepts a `ReadonlyUint8Array` as input. It will both return `true` if the `ReadonlyUint8Array` conforms to\n * the {@link SignatureBytes} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignatureBytes } from '@solana/keys';\n *\n * if (isSignatureBytes(signatureBytes)) {\n *     // At this point, `signatureBytes` has been refined to a\n *     // `SignatureBytes` that can be used with `verifySignature`.\n *     if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *         throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *     }\n * } else {\n *     setError(`${signatureBytes} is not a 64-byte Ed25519 signature`);\n * }\n * ```\n */\nexport function isSignatureBytes(putativeSignatureBytes: ReadonlyUint8Array): putativeSignatureBytes is SignatureBytes {\n    return putativeSignatureBytes.byteLength === 64;\n}\n\n/**\n * Given a private [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and a\n * `Uint8Array` of bytes, this method will return the 64-byte Ed25519 signature of that data as a\n * `Uint8Array`.\n *\n * @example\n * ```ts\n * import { signBytes } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * const signature = await signBytes(privateKey, data);\n * ```\n */\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, toArrayBuffer(data));\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\n/**\n * This helper combines _asserting_ that a string is an Ed25519 signature with _coercing_ it to the\n * {@link Signature} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signature } from '@solana/keys';\n *\n * const signature = signature(userSuppliedSignature);\n * const {\n *     value: [status],\n * } = await rpc.getSignatureStatuses([signature]).send();\n * ```\n */\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\n/**\n * This helper combines _asserting_ that a `ReadonlyUint8Array` is an Ed25519 signature with _coercing_ it to the\n * {@link SignatureBytes} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signatureBytes } from '@solana/keys';\n *\n * const signature = signatureBytes(userSuppliedSignatureBytes);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport function signatureBytes(putativeSignatureBytes: ReadonlyUint8Array): SignatureBytes {\n    assertIsSignatureBytes(putativeSignatureBytes);\n    return putativeSignatureBytes;\n}\n\n/**\n * Given a public [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey), some\n * {@link SignatureBytes}, and a `Uint8Array` of data, this method will return `true` if the\n * signature was produced by signing the data using the private key associated with the public key,\n * and `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifySignature } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, toArrayBuffer(signature), toArrayBuffer(data));\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\n/**\n * Generates an Ed25519 public/private key pair for use with other methods in this package that\n * accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await generateKeyPair();\n * ```\n */\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\n/**\n * Given a 64-byte `Uint8Array` secret key, creates an Ed25519 public/private key pair for use with\n * other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 64 bytes, the first 32 of which represent the private key and the last 32 of which\n * represent its associated public key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairFromBytes } from '@solana/keys';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a CryptoKeyPair from the bytes.\n * const { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n * ```\n */\nexport async function createKeyPairFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            'verify',\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 public/private key\n * pair for use with other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n * ```\n *\n * This can be useful when you have a private key but not the corresponding public key or when you\n * need to derive key pairs from seeds. For instance, the following code snippet derives a key pair\n * from the hash of a message.\n *\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n * ```\n */\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n"],"names":["SolanaError","signature","privateKey"],"mappings":"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"}},
    {"offset": {"line": 7692, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transactions/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/codecs/signatures-encoder.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/codecs/transaction-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/lifetime.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/compile-transaction.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/signatures.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/wire-transaction.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/transaction-size.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/sendable-transaction.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/transactions/src/transaction-message-size.ts"],"sourcesContent":["import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\n/**\n * Returns an encoder that you can use to encode a {@link Transaction} to a byte array in a wire\n * format appropriate for sending to the Solana network for execution.\n */\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana transaction wire format\n * to a {@link Transaction} object.\n *\n * @example\n * ```ts\n * import { getTransactionDecoder } from '@solana/transactions';\n *\n * const transactionDecoder = getTransactionDecoder();\n * const transaction = transactionDecoder.decode(wireTransactionBytes);\n * for (const [address, signature] in Object.entries(transaction.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a {@link Transaction}\n *\n * @see {@link getTransactionDecoder}\n * @see {@link getTransactionEncoder}\n */\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n","import { type Address, isAddress } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SolanaError,\n} from '@solana/errors';\nimport { type Blockhash, isBlockhash, type Slot } from '@solana/rpc-types';\nimport type {\n    CompiledTransactionMessage,\n    CompiledTransactionMessageWithLifetime,\n    Nonce,\n    TransactionMessage,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\n\nimport type { Transaction } from './transaction';\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network. The transaction will continue to be eligible to land until the network considers the\n * `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type TransactionBlockhashLifetime = {\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction eligible to land.\n     */\n    lastValidBlockHeight: Slot;\n};\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionDurableNonceLifetime = {\n    /**\n     * A value contained in the account with address `nonceAccountAddress` at the time the\n     * transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce;\n    /** The account that contains the `nonce` value */\n    nonceAccountAddress: Address;\n};\n\n/**\n * A transaction whose ability to land on the network is determined by some evanescent criteria.\n *\n * This describes a window of time after which a transaction is constructed and before which it will\n * no longer be accepted by the network.\n *\n * No transaction can land on Solana without having a `lifetimeConstraint` set.\n */\nexport type TransactionWithLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime | TransactionDurableNonceLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by the age of a blockhash observed on the network.\n *\n * The transaction will continue to be eligible to land until the network considers the `blockhash`\n * to be expired.\n */\nexport type TransactionWithBlockhashLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by a nonce.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionWithDurableNonceLifetime = {\n    readonly lifetimeConstraint: TransactionDurableNonceLifetime;\n};\n\n/**\n * Helper type that sets the lifetime constraint of a transaction to be the same as the\n * lifetime constraint of the provided transaction message.\n *\n * If the transaction message has no explicit lifetime constraint, neither will the transaction.\n */\nexport type SetTransactionLifetimeFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends TransactionMessage,\n> = TTransactionMessage extends { lifetimeConstraint: unknown }\n    ? TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithBlockhashLifetime['lifetimeConstraint']\n        ? TransactionWithBlockhashLifetime & TTransaction\n        : TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithDurableNonceLifetime['lifetimeConstraint']\n          ? TransactionWithDurableNonceLifetime & TTransaction\n          : TransactionWithLifetime & TTransaction\n    : TTransaction;\n\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address;\n\nfunction compiledInstructionIsAdvanceNonceInstruction(\n    instruction: CompiledTransactionMessage['instructions'][number],\n    staticAddresses: Address[],\n): instruction is typeof instruction & { accountIndices: [number, number, number] } {\n    return (\n        staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accountIndices?.length === 3\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): boolean {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n/**\n * Get the lifetime constraint for a transaction from a compiled transaction message that includes a lifetime token.\n * @param compiledTransactionMessage A compiled transaction message that includes a lifetime token\n * @returns A lifetime constraint for the transaction\n * Note that this is less precise than checking a decompiled instruction, as we can't inspect\n * the address or role of input accounts (which may be in lookup tables). However, this is\n * sufficient for all valid advance durable nonce instructions.\n * Note that the program address must not be in a lookup table, see [this answer on StackExchange](https://solana.stackexchange.com/a/16224/289)\n * @see {@link isAdvanceNonceAccountInstruction}\n * Note that this function is async to allow for future implementations that may fetch `lastValidBlockHeight` using an RPC\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function getTransactionLifetimeConstraintFromCompiledTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n): Promise<TransactionBlockhashLifetime | TransactionDurableNonceLifetime> {\n    const firstInstruction = compiledTransactionMessage.instructions[0];\n    const { staticAccounts } = compiledTransactionMessage;\n\n    // We need to check if the first instruction is an AdvanceNonceAccount instruction\n    if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n        const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n        if (!nonceAccountAddress) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {\n                nonce: compiledTransactionMessage.lifetimeToken,\n            });\n        }\n        return {\n            nonce: compiledTransactionMessage.lifetimeToken as Nonce,\n            nonceAccountAddress,\n        };\n    } else {\n        return {\n            blockhash: compiledTransactionMessage.lifetimeToken as Blockhash,\n            // This is not known from the compiled message, so we set it to the maximum possible value\n            lastValidBlockHeight: 0xffffffffffffffffn,\n        };\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * if (isTransactionWithBlockhashLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a `TransactionWithBlockhashLifetime`.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'blockhash' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transaction.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * blockhash-based lifetime, from for example a wallet. Use this function to\n * assert that such a transaction actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithBlockhashLifetime`.\n *     assertIsTransactionWithBlockhashLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `transaction` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithBlockhashLifetime {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithDurableNonceLifetime } from '@solana/transactions';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionWithDurableNonceLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a\n *     // `TransactionWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'nonce' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        typeof transaction.lifetimeConstraint.nonceAccountAddress === 'string' &&\n        isAddress(transaction.lifetimeConstraint.nonceAccountAddress)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * nonce-based lifetime, from for example a wallet. Use this function to assert\n * that such a transaction actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithDurableNonceLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithDurableNonceLifetime`.\n *     assertIsTransactionWithDurableNonceLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `transaction` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithDurableNonceLifetime {\n    if (!isTransactionWithDurableNonceLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n","import {\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport type { TransactionWithLifetime } from './lifetime';\nimport type { SignaturesMap, TransactionFromTransactionMessage, TransactionMessageBytes } from './transaction';\n\n/**\n * Returns a {@link Transaction} object for a given {@link TransactionMessage}.\n *\n * This includes the compiled bytes of the transaction message, and a map of signatures. This map\n * will have a key for each address that is required to sign the transaction. The transaction will\n * not yet have signatures for any of these addresses.\n *\n * Whether a transaction message is ready to be compiled or not is enforced for you at the type\n * level. In order to be signable, a transaction message must:\n *\n * - have a version and a list of zero or more instructions (ie. conform to\n *   {@link TransactionMessage})\n * - have a fee payer set (ie. conform to {@link TransactionMessageWithFeePayer})\n * - have a lifetime specified (ie. conform to {@link TransactionMessageWithBlockhashLifetime} or\n *   {@link TransactionMessageWithDurableNonceLifetime})\n */\nexport function compileTransaction<TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer>(\n    transactionMessage: TTransactionMessage,\n): Readonly<TransactionFromTransactionMessage<TTransactionMessage>> {\n    type ReturnType = Readonly<TransactionFromTransactionMessage<TTransactionMessage>>;\n\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'] | undefined;\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    return Object.freeze({\n        ...(lifetimeConstraint ? { lifetimeConstraint } : undefined),\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    }) as ReturnType;\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { bytesEqual, Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { Transaction } from './transaction';\n\n/**\n * Represents a transaction that is signed by all of its required signers. Being fully signed is a\n * prerequisite of functions designed to land transactions on the network.\n */\nexport type FullySignedTransaction = NominalType<'transactionSignedness', 'fullySigned'>;\n\nlet base58Decoder: Decoder<string> | undefined;\n\n/**\n * Given a transaction signed by its fee payer, this method will return the {@link Signature} that\n * uniquely identifies it. This string can be used to look up transactions at a later date, for\n * example on a Solana block explorer.\n *\n * @example\n * ```ts\n * import { getSignatureFromTransaction } from '@solana/transactions';\n *\n * const signature = getSignatureFromTransaction(tx);\n * console.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n * ```\n */\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link Transaction}.\n *\n * Though the resulting transaction might have every signature it needs to land on the network, this\n * function will not assert that it does. A partially signed transaction cannot be landed on the\n * network, but can be serialized and deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignTransaction } from '@solana/transactions';\n *\n * const partiallySignedTransaction = await partiallySignTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link signTransaction} if you want to assert that the transaction has all of its required\n * signatures after signing.\n */\nexport async function partiallySignTransaction<TTransaction extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<TTransaction> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && bytesEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link FullySignedTransaction}.\n *\n * This function will throw unless the resulting transaction is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signTransaction } from '@solana/transactions';\n *\n * const signedTransaction = await signTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link partiallySignTransaction} if you want to sign the transaction without asserting that\n * the resulting transaction is fully signed.\n */\nexport async function signTransaction<TTransaction extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<FullySignedTransaction & TTransaction> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * Checks whether a given {@link Transaction} is fully signed.\n *\n * @example\n * ```ts\n * import { isFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isFullySignedTransaction(transaction)) {\n *   // At this point we know that the transaction is signed and can be sent to the network.\n * }\n * ```\n */\nexport function isFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is FullySignedTransaction & TTransaction {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertIsFullySignedTransaction(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is FullySignedTransaction & TTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/** Represents the wire format of a transaction as a base64-encoded string. */\nexport type Base64EncodedWireTransaction = Brand<EncodedString<string, 'base64'>, 'Base64EncodedWireTransaction'>;\n\n/**\n * Given a signed transaction, this method returns the transaction as a string that conforms to the\n * {@link Base64EncodedWireTransaction} type.\n *\n * @example\n * ```ts\n * import { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n *\n * const serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n * const signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n * ```\n */\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { NominalType } from '@solana/nominal-types';\nimport type { BaseTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/**\n * The maximum size of a transaction packet in bytes.\n */\nexport const TRANSACTION_PACKET_SIZE = 1280;\n\n/**\n * The size of the transaction packet header in bytes.\n * This includes the IPv6 header and the fragment header.\n */\nexport const TRANSACTION_PACKET_HEADER =\n    40 /* 40 bytes is the size of the IPv6 header. */ + 8; /* 8 bytes is the size of the fragment header. */\n\n/**\n * The maximum size of a transaction in bytes.\n *\n * Note that this excludes the transaction packet header.\n * In other words, this is how much content we can fit in a transaction packet.\n */\nexport const TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\n\n/**\n * Gets the size of a given transaction in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionSize(transaction);\n * ```\n */\nexport function getTransactionSize(transaction: Transaction): number {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\n\n/**\n * A type guard that checks if a transaction is within the size limit.\n */\nexport type TransactionWithinSizeLimit = NominalType<'transactionSize', 'withinLimit'>;\n\n/**\n * Helper type that adds the `TransactionWithinSizeLimit` flag to\n * a transaction if and only if the provided transaction message\n * is also within the size limit.\n */\nexport type SetTransactionWithinSizeLimitFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithinSizeLimit\n    ? TransactionWithinSizeLimit & TTransaction\n    : TTransaction;\n\n/**\n * Checks if a transaction is within the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * if (isTransactionWithinSizeLimit(transaction)) {\n *    transaction satisfies TransactionWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is TransactionWithinSizeLimit & TTransaction {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction is within the size limit.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction exceeds the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * assertIsTransactionWithinSizeLimit(transaction);\n * transaction satisfies TransactionWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is TransactionWithinSizeLimit & TTransaction {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { assertIsFullySignedTransaction, FullySignedTransaction, isFullySignedTransaction } from './signatures';\nimport { Transaction } from './transaction';\nimport {\n    assertIsTransactionWithinSizeLimit,\n    isTransactionWithinSizeLimit,\n    TransactionWithinSizeLimit,\n} from './transaction-size';\n\n/**\n * Helper type that includes all transaction types required\n * for the transaction to be sent to the network.\n *\n * @see {@link isSendableTransaction}\n * @see {@link assertIsSendableTransaction}\n */\nexport type SendableTransaction = FullySignedTransaction & TransactionWithinSizeLimit;\n\n/**\n * Checks if a transaction has all the required\n * conditions to be sent to the network.\n *\n * @example\n * ```ts\n * import { isSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isSendableTransaction(transaction)) {\n *   // At this point we know that the transaction can be sent to the network.\n * }\n * ```\n *\n * @see {@link assertIsSendableTransaction}\n */\nexport function isSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is SendableTransaction & TTransaction {\n    return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\n\n/**\n * Asserts that a given transaction has all the\n * required conditions to be sent to the network.\n *\n * From time to time you might acquire a {@link Transaction}\n * from an untrusted network API or user input and you are not sure\n * that it has all the required conditions to be sent to the network\n *  such as being fully signed and within the size limit.\n * This function can be used to assert that such a transaction\n * is in fact sendable.\n *\n * @example\n * ```ts\n * import { assertIsSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `SendableTransaction`.\n *     assertIsSendableTransaction(transaction);\n *     // At this point we know that the transaction can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT)) {\n *         setError(`Transaction exceeds size limit of ${e.context.transactionSizeLimit} bytes`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is SendableTransaction & TTransaction {\n    assertIsFullySignedTransaction(transaction);\n    assertIsTransactionWithinSizeLimit(transaction);\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionMessageWithinSizeLimit,\n} from '@solana/transaction-messages';\n\nimport { compileTransaction } from './compile-transaction';\nimport { getTransactionSize, TRANSACTION_SIZE_LIMIT } from './transaction-size';\n\n/**\n * Gets the compiled transaction size of a given transaction message in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionMessageSize(transactionMessage);\n * ```\n */\nexport function getTransactionMessageSize(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): number {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\n\n/**\n * Checks if a transaction message is within the size limit\n * when compiled into a transaction.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * if (isTransactionMessageWithinSizeLimit(transactionMessage)) {\n *    transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction message is within the size limit\n * when compiled into a transaction.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction message exceeds the size limit.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * assertIsTransactionMessageWithinSizeLimit(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): asserts transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n"],"names":["getBytesEncoder","SolanaError","SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT"],"mappings":"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"}},
    {"offset": {"line": 8048, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/offchain-messages/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/application-domain.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/application-domain.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/signing-domain.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/preamble-common.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/signatures.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/envelope.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/content.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/message-v0.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/content.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/preamble-v0.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/message-v0.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/preamble-v1.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/message-v1.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/codecs/message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/envelope-common.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/envelope-v0.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/envelope-v1.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/envelope.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/offchain-messages/src/signatures.ts"],"sourcesContent":["import { assertIsAddress, isAddress } from '@solana/addresses';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * A 32-byte array identifying the application requesting off-chain message signing.\n *\n * This may be any arbitrary bytes. For instance the on-chain address of a program, DAO instance,\n * Candy Machine, et cetera.\n *\n * This field SHOULD be displayed to users as a base58-encoded ASCII string rather than interpreted\n * otherwise.\n */\nexport type OffchainMessageApplicationDomain = Brand<\n    EncodedString<string, 'base58'>,\n    'OffchainMessageApplicationDomain'\n>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the\n * {@link OffchainMessageApplicationDomain} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * if (isOffchainMessageApplicationDomain(applicationDomain)) {\n *     // At this point, `applicationDomain` has been refined to an\n *     // `OffchainMessageApplcationDomain` that can be used to craft a message.\n *     const offchainMessage: OffchainMessageV0 = {\n *         applicationDomain:\n *             offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *     };\n * } else {\n *     setError(`${applicationDomain} is not a valid application domain for an offchain message`);\n * }\n * ```\n */\nexport function isOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): putativeApplicationDomain is OffchainMessageApplicationDomain {\n    return isAddress(putativeApplicationDomain);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an offchain message\n * application domain, from an untrusted network API or user input. Use this function to assert that\n * such an arbitrary string is a base58-encoded application domain.\n *\n * @example\n * ```ts\n * import { assertIsOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * // Imagine a function that determines whether an application domain is valid.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const applicationDomain: string = applicationDomainInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `applicationDomain` to `OffchainMessageApplicationDomain`.\n *         assertIsOffchainMessageApplicationDomain(applicationDomain);\n *         // At this point, `applicationDomain` is a `OffchainMessageApplicationDomain` that can be\n *         // used to craft an offchain message.\n *         const offchainMessage: OffchainMessageV0 = {\n *             applicationDomain:\n *                 offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `applicationDomain` turned out not to be a base58-encoded application domain\n *     }\n * }\n * ```\n */\nexport function assertIsOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): asserts putativeApplicationDomain is OffchainMessageApplicationDomain {\n    try {\n        assertIsAddress(putativeApplicationDomain);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n                error.context,\n            );\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n                error.context,\n            );\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an offchain message application domain with _coercing_ it\n * to the {@link OffchainMessageApplicationDomain} type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * const offchainMessage: OffchainMessageV0 = {\n *     applicationDomain:\n *         offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *     // ...\n * };\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good application domain as a string, it's more efficient to typecast\n * > it rather than to use the {@link offchainMessageApplicationDomain} helper, because the helper\n * > unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageApplicationDomain } from '@solana/offchain-messages';\n * >\n * > const applicationDomain =\n * >     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * > ```\n */\nexport function offchainMessageApplicationDomain(putativeApplicationDomain: string): OffchainMessageApplicationDomain {\n    assertIsOffchainMessageApplicationDomain(putativeApplicationDomain);\n    return putativeApplicationDomain;\n}\n","import { Address, getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformEncoder,\n} from '@solana/codecs-core';\n\nimport { OffchainMessageApplicationDomain, offchainMessageApplicationDomain } from '../application-domain';\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded offchain message application\n * domain to a byte array.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainEncoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomain =\n *     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * const offchainMessageApplicationDomainEncoder = getOffchainMessageApplicationDomainEncoder();\n * const offchainMessageApplicationDomainBytes =\n *     offchainMessageApplicationDomainEncoder.encode(offchainMessageApplicationDomain);\n * // Uint8Array(32) [\n * //   247, 203,  28,  80,  52, 240, 169,  19,\n * //    21, 103, 107, 119,  91, 235,  13,  48,\n * //   194, 169, 148, 160,  78, 105, 235,  37,\n * //   232, 160,  49,  47,  64,  89,  18, 153,\n * // ]\n * ```\n */\nexport function getOffchainMessageApplicationDomainEncoder(): FixedSizeEncoder<OffchainMessageApplicationDomain, 32> {\n    return transformEncoder(\n        getAddressEncoder(),\n        putativeApplicationDomain => offchainMessageApplicationDomain(putativeApplicationDomain) as string as Address,\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an offchain\n * message application domain to the base58-encoded representation of that application domain.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomainBytes = new Uint8Array([\n *     247, 203,  28,  80,  52, 240, 169,  19,\n *      21, 103, 107, 119,  91, 235,  13,  48,\n *     194, 169, 148, 160,  78, 105, 235,  37,\n *     232, 160,  49,  47,  64,  89,  18, 153,\n * ]);\n * const offchainMessageApplicationDomainDecoder = getOffchainMessageApplicationDomainDecoder();\n * const offchainMessageApplicationDomain =\n *     offchainMessageApplicationDomainDecoder.decode(offchainMessageApplicationDomainBytes);\n *     // HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx\n * ```\n */\nexport function getOffchainMessageApplicationDomainDecoder(): FixedSizeDecoder<OffchainMessageApplicationDomain, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<\n        OffchainMessageApplicationDomain,\n        32\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded offchain message\n * application domain.\n *\n * @see {@link getOffchainMessageApplicationDomainDecoder}\n * @see {@link getOffchainMessageApplicationDomainEncoder}\n */\nexport function getOffchainMessageApplicationDomainCodec(): FixedSizeCodec<\n    OffchainMessageApplicationDomain,\n    OffchainMessageApplicationDomain,\n    32\n> {\n    return combineCodec(getOffchainMessageApplicationDomainEncoder(), getOffchainMessageApplicationDomainDecoder());\n}\n","import {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getConstantDecoder, getConstantEncoder } from '@solana/codecs-data-structures';\n\n// The string `'\\xffsolana offchain'`\nconst OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES: ReadonlyUint8Array = new Uint8Array([\n    0xff, 0x73, 0x6f, 0x6c, 0x61, 0x6e, 0x61, 0x20, 0x6f, 0x66, 0x66, 0x63, 0x68, 0x61, 0x69, 0x6e,\n]);\n\nexport function getOffchainMessageSigningDomainDecoder(): FixedSizeDecoder<void, 16> {\n    return getConstantDecoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeDecoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainEncoder(): FixedSizeEncoder<void, 16> {\n    return getConstantEncoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeEncoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainCodec(): FixedSizeCodec<void, void, 16> {\n    return combineCodec(getOffchainMessageSigningDomainEncoder(), getOffchainMessageSigningDomainDecoder());\n}\n","import { Address, getAddressDecoder } from '@solana/addresses';\nimport {\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    offsetDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getHiddenPrefixDecoder,\n    getHiddenPrefixEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageVersion } from '../version';\nimport { getOffchainMessageSigningDomainDecoder, getOffchainMessageSigningDomainEncoder } from './signing-domain';\n\ntype TDecoderFields = Parameters<typeof getStructDecoder>[0];\ntype TEncoderFields = Parameters<typeof getStructEncoder>[0];\n\nfunction getSigningDomainPrefixedDecoder<const T extends TDecoderFields>(...fields: T) {\n    return getHiddenPrefixDecoder(getStructDecoder(fields), [getOffchainMessageSigningDomainDecoder()]);\n}\n\nfunction getSigningDomainPrefixedEncoder<const T extends TEncoderFields>(...fields: T) {\n    return getHiddenPrefixEncoder(getStructEncoder(fields), [getOffchainMessageSigningDomainEncoder()]);\n}\n\nfunction getVersionTransformer(fixedVersion?: OffchainMessageVersion) {\n    return (version: number) => {\n        if (version > 1) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                unsupportedVersion: version,\n            });\n        }\n        if (fixedVersion != null && version !== fixedVersion) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION, {\n                actualVersion: version,\n                expectedVersion: fixedVersion,\n            });\n        }\n        return version;\n    };\n}\n\nexport function createOffchainMessagePreambleDecoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TDecoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer(version)) as FixedSizeDecoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function createOffchainMessagePreambleEncoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TEncoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedEncoder(\n        ['version', transformEncoder(getU8Encoder(), getVersionTransformer(version)) as FixedSizeEncoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function decodeRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const { version, bytesAfterVersion } = getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer())],\n        ['bytesAfterVersion', getBytesDecoder()],\n    ).decode(bytes);\n    return offsetDecoder(\n        transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n            if (signatoryAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            return signatoryAddresses;\n        }),\n        {\n            preOffset: ({ preOffset }) =>\n                preOffset +\n                (version === 0\n                    ? 32 + 1 // skip the application domain and message format of v0 messages\n                    : 0),\n        },\n    ).decode(bytesAfterVersion);\n}\n\nexport function getSignatoriesComparator(): (a: ReadonlyUint8Array, b: ReadonlyUint8Array) => -1 | 0 | 1 {\n    return (x, y) => {\n        if (x.length !== y.length) {\n            return x.length < y.length ? -1 : 1;\n        }\n        for (let ii = 0; ii < x.length; ii++) {\n            if (x[ii] === y[ii]) {\n                continue;\n            } else {\n                return x[ii] < y[ii] ? -1 : 1;\n            }\n        }\n        return 0;\n    };\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\n\nfunction getSignaturesToEncode(signaturesMap: OffchainMessageEnvelope['signatures']): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<OffchainMessageEnvelope['signatures']> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getU8Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { Address, address } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\nimport { OffchainMessageBytes } from '../message';\nimport { decodeRequiredSignatoryAddresses } from './preamble-common';\nimport { getSignaturesEncoder } from './signatures';\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageEnvelope} to a byte array\n * appropriate for sharing with a third party for validation.\n */\nexport function getOffchainMessageEnvelopeEncoder(): VariableSizeEncoder<OffchainMessageEnvelope> {\n    return transformEncoder(\n        getStructEncoder([\n            ['signatures', getSignaturesEncoder()],\n            ['content', getBytesEncoder()],\n        ]),\n        envelope => {\n            const signaturesMapAddresses = Object.keys(envelope.signatures).map(address);\n            if (signaturesMapAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n            }\n            const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(envelope.content);\n            const missingRequiredSigners = [];\n            const unexpectedSigners = [];\n            for (const address of signatoryAddresses) {\n                if (!signaturesMapAddresses.includes(address)) {\n                    missingRequiredSigners.push(address);\n                }\n            }\n            for (const address of signaturesMapAddresses) {\n                if (!signatoryAddresses.includes(address)) {\n                    unexpectedSigners.push(address);\n                }\n            }\n            if (missingRequiredSigners.length || unexpectedSigners.length) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH, {\n                    missingRequiredSigners,\n                    unexpectedSigners,\n                });\n            }\n            const orderedSignatureMap: OffchainMessageEnvelope['signatures'] = {};\n            for (const address of signatoryAddresses) {\n                orderedSignatureMap[address] = envelope.signatures[address];\n            }\n            return {\n                ...envelope,\n                signatures: orderedSignatureMap,\n            };\n        },\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana offchain message format\n * to a {@link OffchainMessageEnvelope} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageEnvelopeDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelopeDecoder = getOffchainMessageEnvelopeDecoder();\n * const offchainMessageEnvelope = offchainMessageEnvelopeDecoder.decode(offchainMessageEnvelopeBytes);\n * for (const [address, signature] in Object.entries(offchainMessageEnvelope.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\nexport function getOffchainMessageEnvelopeDecoder(): VariableSizeDecoder<OffchainMessageEnvelope> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getU8Decoder() })],\n            ['content', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedOffchainMessageEnvelope,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageEnvelope}\n *\n * @see {@link getOffchainMessageEnvelopeDecoder}\n * @see {@link getOffchainMessageEnvelopeEncoder}\n */\nexport function getOffchainMessageEnvelopeCodec() {\n    return combineCodec(getOffchainMessageEnvelopeEncoder(), getOffchainMessageEnvelopeDecoder());\n}\n\ntype PartiallyDecodedOffchainMessageEnvelope = {\n    content: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedOffchainMessageEnvelope(\n    offchainMessageEnvelope: PartiallyDecodedOffchainMessageEnvelope,\n): OffchainMessageEnvelope {\n    const { content, signatures } = offchainMessageEnvelope;\n\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(content);\n\n    // Signer addresses and signatures must be the same length\n    // We encode an all-zero signature when the signature is missing\n    if (signatoryAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH, {\n            numRequiredSignatures: signatoryAddresses.length,\n            signatoryAddresses,\n            signaturesLength: signatures.length,\n        });\n    }\n\n    // Combine the signer addresses + signatures into the signatures map\n    const signaturesMap: OffchainMessageEnvelope['signatures'] = {};\n    signatoryAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return Object.freeze({\n        content: content as OffchainMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    });\n}\n\nfunction decodeAndValidateRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const signatoryAddresses = decodeRequiredSignatoryAddresses(bytes);\n\n    if (signatoryAddresses.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n    }\n\n    return signatoryAddresses;\n}\n","import { getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nconst MAX_BODY_BYTES =\n    // Largest 16-bit unsigned integer\n    0xffff;\nconst MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE =\n    // Space remaining in the mininum IPv6 MTU after network header overhead\n    1232;\n\n/**\n * A restriction on what characters the message text can contain and how long it can be.\n *\n * The aim of this restriction is to make a message more likely to be signable by a hardware wallet\n * that imposes limits on message size. In the case of wanting a message to be clear-signable,\n * restricting the character set to ASCII may ensure that certain models of hardware wallet without\n * extended character sets can display it onscreen.\n *\n * @remarks This only applies to v0 messages.\n */\nexport enum OffchainMessageContentFormat {\n    RESTRICTED_ASCII_1232_BYTES_MAX = 0,\n    UTF8_1232_BYTES_MAX = 1,\n    UTF8_65535_BYTES_MAX = 2,\n}\n\n/**\n * Describes message text that is no more than 1232 bytes long and made up of characters with ASCII\n * character codes in the range [0x20, 0x7e].\n *\n * @remarks This type aims to restrict text to that which can be clear-signed by hardware wallets\n * that can only display ASCII characters onscreen.\n */\nexport type OffchainMessageContentRestrictedAsciiOf1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentRestrictedAsciiOf1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 1232 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 65535 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of65535BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of65535BytesMax'>;\n}>;\n\nexport type OffchainMessageContent =\n    | OffchainMessageContentRestrictedAsciiOf1232BytesMax\n    | OffchainMessageContentUtf8Of1232BytesMax\n    | OffchainMessageContentUtf8Of65535BytesMax;\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (isTextRestrictedAscii(putativeContent.text) === false) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX ||\n        putativeContent.text.length === 0 ||\n        isTextRestrictedAscii(putativeContent.text) === false\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is restricted ASCII with\n * _coercing_ it to the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type. It's most\n * useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageContentRestrictedAsciiOf1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: offchainMessageContentRestrictedAsciiOf1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentRestrictedAsciiOf1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good ASCII content as a string, it's more efficient to typecast it\n * > rather than to use the {@link offchainMessageContentRestrictedAsciiOf1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n * >         text: 'Hello world',\n * >     } as OffchainMessageContentRestrictedAsciiOf1232BytesMax<'Hello world'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentRestrictedAsciiOf1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentRestrictedAsciiOf1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        });\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 1232 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of1232BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 1232 bytes, it's more efficient\n * > to typecast it rather than to use the {@link offchainMessageContentUtf8Of1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n * >         text: 'cool',\n * >     } as OffchainMessageContentUtf8Of1232BytesMax<'cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of65535BytesMax}\n * type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of65535BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 65535 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of65535BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of65535BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of65535BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of65535BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 65535 bytes, it's more efficient\n * > to typecast it rather than to use the {@link OffchainMessageContentUtf8Of65535BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n * >         text: 'cool',\n * >     } as OffchainMessageContentUtf8Of65535BytesMax<'cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of65535BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of65535BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent);\n    return putativeContent;\n}\n\nfunction isTextRestrictedAscii(putativeRestrictedAsciiString: string): boolean {\n    return /^[\\x20-\\x7e]+$/.test(putativeRestrictedAsciiString);\n}\n","import {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of65535BytesMax,\n    OffchainMessageContentFormat,\n    OffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    OffchainMessageContentUtf8Of1232BytesMax,\n    OffchainMessageContentUtf8Of65535BytesMax,\n} from './content';\nimport { OffchainMessagePreambleV0 } from './preamble-v0';\nimport { OffchainMessageWithRequiredSignatories } from './signatures';\n\nexport type BaseOffchainMessageV0 = Omit<\n    OffchainMessagePreambleV0,\n    'messageFormat' | 'messageLength' | 'requiredSignatories'\n>;\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax}\n */\nexport interface OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent {\n    readonly content: OffchainMessageContentRestrictedAsciiOf1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link offchainMessageContentUtf8Of1232BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of1232BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentUtf8Of65535BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of65535BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of65535BytesMax;\n}\n\n/**\n * A union of the formats a v0 message's contents can take.\n *\n * @remarks From v1 and onward, an offchain message has only one format: UTF-8 text of arbitrary\n * length.\n */\nexport type OffchainMessageWithContent =\n    | OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent\n    | OffchainMessageWithUtf8Of1232BytesMaxContent\n    | OffchainMessageWithUtf8Of65535BytesMaxContent;\n\nexport type OffchainMessageV0 = BaseOffchainMessageV0 &\n    OffchainMessageWithContent &\n    OffchainMessageWithRequiredSignatories;\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageRestrictedAsciiOf1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n        }>,\n): asserts putativeMessage is OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link offchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link offchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentUtf8Of65535BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of65535BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of65535BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeMessage.content);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getEnumDecoder, getEnumEncoder } from '@solana/codecs-data-structures';\n\nimport { OffchainMessageContentFormat } from '../content';\n\nexport function getOffchainMessageContentFormatDecoder(): FixedSizeDecoder<OffchainMessageContentFormat, 1> {\n    return getEnumDecoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatEncoder(): FixedSizeEncoder<OffchainMessageContentFormat, 1> {\n    return getEnumEncoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatCodec(): FixedSizeCodec<\n    OffchainMessageContentFormat,\n    OffchainMessageContentFormat,\n    1\n> {\n    return combineCodec(getOffchainMessageContentFormatEncoder(), getOffchainMessageContentFormatDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder, getU16Decoder, getU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\n\nimport { OffchainMessagePreambleV0 } from '../preamble-v0';\nimport {\n    getOffchainMessageApplicationDomainDecoder,\n    getOffchainMessageApplicationDomainEncoder,\n} from './application-domain';\nimport { getOffchainMessageContentFormatDecoder, getOffchainMessageContentFormatEncoder } from './content';\nimport { createOffchainMessagePreambleDecoder, createOffchainMessagePreambleEncoder } from './preamble-common';\n\nexport function getOffchainMessageV0PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleDecoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainDecoder()],\n        ['messageFormat', getOffchainMessageContentFormatDecoder()],\n        [\n            'requiredSignatories',\n            transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                return signatoryAddresses.map(address => Object.freeze({ address }));\n            }),\n        ],\n        ['messageLength', getU16Decoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleEncoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainEncoder()],\n        ['messageFormat', getOffchainMessageContentFormatEncoder()],\n        [\n            'requiredSignatories',\n            transformEncoder(\n                getArrayEncoder(getAddressEncoder(), { size: getU8Encoder() }),\n                (signatoryAddresses: OffchainMessagePreambleV0['requiredSignatories']) => {\n                    if (signatoryAddresses.length === 0) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                    }\n                    return signatoryAddresses.map(({ address }) => address);\n                },\n            ),\n        ],\n        ['messageLength', getU16Encoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV0> {\n    return combineCodec(getOffchainMessageV0PreambleEncoder(), getOffchainMessageV0PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageContentFormat } from '../content';\nimport {\n    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageUtf8Of1232BytesMax,\n    assertIsOffchainMessageUtf8Of65535BytesMax,\n    OffchainMessageV0,\n} from '../message-v0';\nimport { getOffchainMessageV0PreambleDecoder, getOffchainMessageV0PreambleEncoder } from './preamble-v0';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV0} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV0Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV0Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v0 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 0.\n */\nexport function getOffchainMessageV0Decoder(): VariableSizeDecoder<OffchainMessageV0> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV0PreambleDecoder(), getUtf8Decoder()]),\n        ([{ messageLength, messageFormat, requiredSignatories, ...preambleRest }, text]) => {\n            const actualLength = getUtf8Encoder().getSizeFromValue(text);\n            if (messageLength !== actualLength) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH, {\n                    actualLength: actualLength,\n                    specifiedLength: messageLength,\n                });\n            }\n            const offchainMessage: Omit<OffchainMessageV0, 'content'> &\n                Readonly<{\n                    content: {\n                        format: OffchainMessageContentFormat;\n                        text: string;\n                    };\n                }> = Object.freeze({\n                ...preambleRest,\n                content: Object.freeze({\n                    format: messageFormat,\n                    text,\n                }),\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n            switch (messageFormat) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: messageFormat satisfies never,\n                    });\n                }\n            }\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV0} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV0Encoder(): VariableSizeEncoder<OffchainMessageV0> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV0PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...preamble } = offchainMessage;\n            switch (offchainMessage.content.format) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    break;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: offchainMessage.content satisfies never,\n                    });\n                }\n            }\n            const messageLength = getUtf8Encoder().getSizeFromValue(content.text);\n            const compiledPreamble = {\n                ...preamble,\n                messageFormat: content.format,\n                messageLength,\n            };\n            return [compiledPreamble, content.text] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV0}\n *\n * @see {@link getOffchainMessageV0Decoder}\n * @see {@link getOffchainMessageV0Encoder}\n */\nexport function getOffchainMessageV0Codec(): VariableSizeCodec<OffchainMessageV0> {\n    return combineCodec(getOffchainMessageV0Encoder(), getOffchainMessageV0Decoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessagePreambleV1 } from '../preamble-v1';\nimport {\n    createOffchainMessagePreambleDecoder,\n    createOffchainMessagePreambleEncoder,\n    getSignatoriesComparator,\n} from './preamble-common';\n\nexport function getOffchainMessageV1PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleDecoder(/* version */ 1, [\n        'requiredSignatories',\n        transformDecoder(\n            getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32), { size: getU8Decoder() }),\n            signatoryAddressesBytes => {\n                if (signatoryAddressesBytes.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const comparator = getSignatoriesComparator();\n                for (let ii = 0; ii < signatoryAddressesBytes.length - 1; ii++) {\n                    switch (comparator(signatoryAddressesBytes[ii], signatoryAddressesBytes[ii + 1])) {\n                        case 0:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                        case 1:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED);\n                    }\n                }\n                const addressDecoder = getAddressDecoder();\n                return signatoryAddressesBytes.map(addressBytes =>\n                    Object.freeze({\n                        address: addressDecoder.decode(addressBytes),\n                    }),\n                );\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleEncoder(/* version */ 1, [\n        'requiredSignatories',\n        transformEncoder(\n            transformEncoder(\n                getArrayEncoder(getBytesEncoder(), { size: getU8Encoder() }),\n                (signatoryAddressesBytes: readonly ReadonlyUint8Array[]) => {\n                    return signatoryAddressesBytes.toSorted(getSignatoriesComparator());\n                },\n            ),\n            (signatoryAddresses: OffchainMessagePreambleV1['requiredSignatories']) => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const seenSignatories = new Set();\n                for (const { address } of signatoryAddresses) {\n                    if (seenSignatories.has(address)) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                    }\n                    seenSignatories.add(address);\n                }\n                const addressEncoder = getAddressEncoder();\n                return signatoryAddresses.map(({ address }) => addressEncoder.encode(address));\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV1> {\n    return combineCodec(getOffchainMessageV1PreambleEncoder(), getOffchainMessageV1PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY, SolanaError } from '@solana/errors';\n\nimport { OffchainMessageV1 } from '../message-v1';\nimport { getOffchainMessageV1PreambleDecoder, getOffchainMessageV1PreambleEncoder } from './preamble-v1';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV1} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV1Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV1Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v1 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 1.\n */\nexport function getOffchainMessageV1Decoder(): VariableSizeDecoder<OffchainMessageV1> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV1PreambleDecoder(), getUtf8Decoder()]),\n        ([{ requiredSignatories, ...preambleRest }, text]) => {\n            if (text.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return Object.freeze({\n                ...preambleRest,\n                content: text,\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV1} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV1Encoder(): VariableSizeEncoder<OffchainMessageV1> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV1PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...compiledPreamble } = offchainMessage;\n            if (content.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return [compiledPreamble, content] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV1}\n *\n * @see {@link getOffchainMessageV1Decoder}\n * @see {@link getOffchainMessageV1Encoder}\n */\nexport function getOffchainMessageV1Codec(): VariableSizeCodec<OffchainMessageV1> {\n    return combineCodec(getOffchainMessageV1Encoder(), getOffchainMessageV1Decoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getHiddenPrefixDecoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, SolanaError } from '@solana/errors';\n\nimport { OffchainMessage } from '../message';\nimport { getOffchainMessageV0Decoder, getOffchainMessageV0Encoder } from './message-v0';\nimport { getOffchainMessageV1Decoder, getOffchainMessageV1Encoder } from './message-v1';\nimport { getOffchainMessageSigningDomainDecoder } from './signing-domain';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessage} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageDecoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded an offchain message (version: ${offchainMessage.version}`);\n * ```\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the decoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageDecoder(): VariableSizeDecoder<OffchainMessage> {\n    return createDecoder({\n        read(bytes, offset): [OffchainMessage, number] {\n            const version = getHiddenPrefixDecoder(getU8Decoder(), [\n                // Discard the signing domain\n                getOffchainMessageSigningDomainDecoder(),\n            ]).decode(bytes, offset);\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Decoder().read(bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Decoder().read(bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessage} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the encoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageEncoder(): VariableSizeEncoder<OffchainMessage> {\n    return createEncoder({\n        getSizeFromValue: offchainMessage => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().getSizeFromValue(offchainMessage);\n                case 1:\n                    return getOffchainMessageV1Encoder().getSizeFromValue(offchainMessage);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n        write: (offchainMessage, bytes, offset) => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().write(offchainMessage, bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Encoder().write(offchainMessage, bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessage}\n *\n * @see {@link getOffchainMessageDecoder}\n * @see {@link getOffchainMessageEncoder}\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the codecs specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageCodec(): VariableSizeCodec<OffchainMessage> {\n    return combineCodec(getOffchainMessageEncoder(), getOffchainMessageDecoder());\n}\n","import { VariableSizeEncoder } from '@solana/codecs-core';\n\nimport { OffchainMessageEnvelope } from './envelope';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\nexport function compileOffchainMessageEnvelopeUsingEncoder<T extends OffchainMessage>(\n    offchainMessage: T,\n    encoder: VariableSizeEncoder<T>,\n) {\n    const offchainMessageBytes = encoder.encode(offchainMessage) as OffchainMessageBytes;\n    const signatures: OffchainMessageEnvelope['signatures'] = {};\n    for (const { address } of offchainMessage.requiredSignatories) {\n        signatures[address] = null;\n    }\n    return Object.freeze({\n        content: offchainMessageBytes,\n        signatures: Object.freeze(signatures),\n    });\n}\n","import { getOffchainMessageV0Encoder } from './codecs/message-v0';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV0 } from './message-v0';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV0}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV0Envelope(offchainMessage: OffchainMessageV0): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV0Encoder());\n}\n","import { getOffchainMessageV1Encoder } from './codecs/message-v1';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV1 } from './message-v1';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV1}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV1Envelope(offchainMessage: OffchainMessageV1): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV1Encoder());\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { compileOffchainMessageV0Envelope } from './envelope-v0';\nimport { compileOffchainMessageV1Envelope } from './envelope-v1';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\ntype OrderedMap<K extends string, V> = Record<K, V>;\ntype OffchainMessageSignaturesMap = OrderedMap<Address, SignatureBytes | null>;\n\nexport interface OffchainMessageEnvelope {\n    /** The bytes of the combined offchain message preamble and content */\n    readonly content: OffchainMessageBytes;\n    /**\n     * A map between the addresses of an offchain message's signers, and the 64-byte Ed25519\n     * signature of the combined message preamble and message content by the private key associated\n     * with each.\n     */\n    readonly signatures: OffchainMessageSignaturesMap;\n}\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessage}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the compile functions\n * specific to that version so as not to bundle more code than you need.\n */\nexport function compileOffchainMessageEnvelope(offchainMessage: OffchainMessage): OffchainMessageEnvelope {\n    const { version } = offchainMessage;\n    switch (version) {\n        case 0:\n            return compileOffchainMessageV0Envelope(offchainMessage);\n        case 1:\n            return compileOffchainMessageV1Envelope(offchainMessage);\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: version satisfies never,\n            });\n    }\n}\n","import { Address, getAddressFromPublicKey, getPublicKeyFromAddress } from '@solana/addresses';\nimport { bytesEqual } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes, signBytes, verifySignature } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { decodeRequiredSignatoryAddresses } from './codecs/preamble-common';\nimport { OffchainMessageEnvelope } from './envelope';\n\n/**\n * Represents an offchain message envelope that is signed by all of its required signers.\n */\nexport type FullySignedOffchainMessageEnvelope = NominalType<'offchainMessageEnvelopeSignedness', 'fullySigned'>;\n\n/**\n * Represents an address that is required to sign an offchain message for it to be valid.\n */\nexport type OffchainMessageSignatory<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n}>;\n\n/**\n * An offchain message having a list of accounts that must sign it in order for it to be valid.\n */\nexport interface OffchainMessageWithRequiredSignatories<\n    TSignatory extends OffchainMessageSignatory = OffchainMessageSignatory,\n> {\n    requiredSignatories: readonly TSignatory[];\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message, this method will return a new signed offchain message\n * envelope of type {@link OffchainMessageEnvelope}.\n *\n * Though the resulting message might be signed by all required signers, this function will not\n * assert that it is. A partially signed message is not complete, but can be serialized and\n * deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const partiallySignedOffchainMessage = await partiallySignOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link signOffchainMessageEnvelope} if you want to assert that the message is signed by all\n * its required signers after signing.\n */\nexport async function partiallySignOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<TOffchainMessageEnvelope> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    const requiredSignatoryAddresses = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n\n            // Check if the address is expected to sign the message\n            if (!requiredSignatoryAddresses.includes(address)) {\n                // address is not an expected signer for this message\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const existingSignature = offchainMessageEnvelope.signatures[address];\n            const newSignature = await signBytes(keyPair.privateKey, offchainMessageEnvelope.content);\n\n            if (existingSignature != null && bytesEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE, {\n            expectedAddresses: requiredSignatoryAddresses,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return offchainMessageEnvelope;\n    }\n\n    return Object.freeze({\n        ...offchainMessageEnvelope,\n        signatures: Object.freeze({\n            ...offchainMessageEnvelope.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message envelope, this method will return a new signed envelope of\n * type {@link FullySignedOffchainMessageEnvelope}.\n *\n * This function will throw unless the resulting message is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const signedOffchainMessage = await signOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link partiallySignOffchainMessageEnvelope} if you want to sign the message without\n * asserting that the resulting message envelope is fully signed.\n */\nexport async function signOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<FullySignedOffchainMessageEnvelope & TOffchainMessageEnvelope> {\n    const out = await partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope);\n    assertIsFullySignedOffchainMessageEnvelope(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * A type guard that returns `true` if the input {@link OffchainMessageEnvelope} is fully signed,\n * and refines its type for use in your program, adding the\n * {@link FullySignedOffchainMessageEnvelope} type.\n *\n * @example\n * ```ts\n * import { isFullySignedOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * if (isFullySignedOffchainMessageEnvelope(offchainMessageEnvelope)) {\n *   // At this point we know that the offchain message is fully signed.\n * }\n * ```\n */\nexport function isFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    return Object.entries(offchainMessage.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link OffchainMessageEnvelope}, that you expect to be\n * fully signed, from an untrusted network API or user input. Use this function to assert that such\n * an offchain message is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedOffchainMessage } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast\n *     // `offchainMessageEnvelope` to `FullySignedOffchainMessageEnvelope`.\n *     assertIsFullySignedOffchainMessageEnvelope(offchainMessage);\n *     // At this point we know that the offchain message is signed by all required signers.\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function assertIsFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): asserts offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    const missingSigs: Address[] = [];\n    Object.entries(offchainMessage.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n\n/**\n * Asserts that there are signatures present for all of an offchain message's required signatories,\n * and that those signatures are valid given the message.\n *\n * @example\n * ```ts\n * import { isSolanaError, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE } from '@solana/errors';\n * import { verifyOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * try {\n *     await verifyOffchainMessageEnvelope(offchainMessageEnvelope);\n *     // At this point the message is valid and signed by all of the required signatories.\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE)) {\n *         if (e.context.signatoriesWithMissingSignatures.length) {\n *             console.error(\n *                 'Missing signatures for the following addresses',\n *                 e.context.signatoriesWithMissingSignatures,\n *             );\n *         }\n *         if (e.context.signatoriesWithInvalidSignatures.length) {\n *             console.error(\n *                 'Signatures for the following addresses are invalid',\n *                 e.context.signatoriesWithInvalidSignatures,\n *             );\n *         }\n *     }\n *     throw e;\n * }\n */\nexport async function verifyOffchainMessageEnvelope(offchainMessageEnvelope: OffchainMessageEnvelope): Promise<void> {\n    let errorContext;\n    const requiredSignatories = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n    await Promise.all(\n        requiredSignatories.map(async address => {\n            const signature = offchainMessageEnvelope.signatures[address];\n            if (signature == null) {\n                errorContext ||= {};\n                errorContext.signatoriesWithMissingSignatures ||= [];\n                errorContext.signatoriesWithMissingSignatures.push(address);\n            } else {\n                const publicKey = await getPublicKeyFromAddress(address);\n                if (await verifySignature(publicKey, signature, offchainMessageEnvelope.content)) {\n                    return true;\n                } else {\n                    errorContext ||= {};\n                    errorContext.signatoriesWithInvalidSignatures ||= [];\n                    errorContext.signatoriesWithInvalidSignatures.push(address);\n                }\n            }\n        }),\n    );\n    if (errorContext) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE, errorContext);\n    }\n}\n"],"names":["SolanaError","transformEncoder","getAddressDecoder","getU8Encoder","getStructEncoder","getBytesEncoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO","address","transformDecoder","getStructDecoder","getArrayDecoder","getBytesDecoder","getU8Decoder","combineCodec","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO","OffchainMessageContentFormat","getArrayEncoder","getAddressEncoder","getUtf8Encoder","fixDecoderSize","getTupleDecoder","getUtf8Decoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY","getTupleEncoder","getHiddenPrefixDecoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED","SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE"],"mappings":"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"}},
    {"offset": {"line": 8918, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/signers/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/deduplicate-signers.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/transaction-modifying-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/transaction-partial-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/transaction-sending-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/transaction-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/account-signer-meta.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/add-signers.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/fee-payer-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/message-partial-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/keypair-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/message-modifying-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/message-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/noop-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/offchain-message-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/sign-offchain-message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/transaction-with-single-sending-signer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/sign-transaction.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/text-encoding-impl/src/index.node.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/signers/src/signable-message.ts"],"sourcesContent":["import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Removes all duplicated {@link MessageSigner | MessageSigners} and\n * {@link TransactionSigner | TransactionSigners} from a provided array\n * by comparing their {@link Address | addresses}.\n *\n * @internal\n */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that potentially modifies the provided {@link Transaction | Transactions}\n * before signing them.\n *\n * For instance, this enables wallets to inject additional instructions into the\n * transaction before signing them. For each transaction, instead of returning a\n * {@link SignatureDictionary}, its\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} function\n * returns an updated {@link Transaction} with a potentially modified set of instructions and\n * signature dictionary. The returned transaction must be within the transaction size limit,\n * and include a `lifetimeConstraint`.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<(Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the provided transactions.\n * - **First signers**. For a given transaction, a modifying signer must always\n *   be used before a partial signer as the former will likely modify the\n *   transaction and thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided,\n *   the second signer may invalidate the signature of the first one. However,\n *   modifying signers may decide not to modify a transaction based on the\n *   existence of signatures for that transaction.\n *\n * @see {@link isTransactionModifyingSigner}\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionModifyingSigner}\n */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionPartialSigner#signTransactions | signTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link Transaction | Transactions}\n *  without modifying their content. It defines a\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * function that returns a {@link SignatureDictionary} for each provided transaction.\n *\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionPartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. It returns a signature dictionary for each provided\n *   transaction without modifying them, making it possible for multiple\n *   partial signers to sign the same transaction in parallel.\n * - **Flexible order**. The order in which we use these signers for\n *   a given transaction doesnt matter.\n *\n * @see {@link isTransactionPartialSigner}\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionPartialSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionPartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionPartialSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionPartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionPartialSigner}\n */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs one or multiple transactions\n * before sending them immediately to the blockchain.\n *\n * It defines a {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions}\n * function that returns the transaction signature (i.e. its identifier) for each provided\n * {@link Transaction}.\n *\n * This interface is required for PDA wallets and other types of wallets that don't provide an\n * interface for signing transactions without sending them.\n *\n * Note that it is also possible for such signers to modify the provided transactions\n * before signing and sending them. This enables use cases where the modified transactions\n * cannot be shared with the app and thus must be sent directly.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Single signer**. Since this signer also sends the provided transactions,\n *   we can only use a single {@link TransactionSendingSigner} for a given set of transactions.\n * - **Last signer**. Trivially, that signer must also be the last one used.\n * - **Potential conflicts**. Since signers may decide to modify the given\n *   transactions before sending them, they may invalidate previous signatures.\n *   However, signers may decide not to modify a transaction based\n *   on the existence of signatures for that transaction.\n * - **Potential confirmation**. Whilst this is not required by this interface,\n *   it is also worth noting that most wallets will also wait for the transaction\n *   to be confirmed (typically with a `confirmed` commitment)\n *   before notifying the app that they are done.\n *\n * @see {@link isTransactionSendingSigner}\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSendingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSendingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSendingSigner}\n */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a signer capable of signing transactions.\n *\n * @see {@link TransactionModifyingSigner} For signers that can modify transactions before signing them.\n * @see {@link TransactionPartialSigner} For signers that can be used in parallel.\n * @see {@link TransactionSendingSigner} For signers that send transactions after signing them.\n * @see {@link isTransactionSigner}\n * @see {@link assertIsTransactionSigner}\n */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSigner}\n */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSigner}\n */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * An extension of the {@link AccountMeta} type that allows us to store {@link TransactionSigner | TransactionSigners} inside it.\n *\n * Note that, because this type represents a signer, it must use one the following two roles:\n * - {@link AccountRole.READONLY_SIGNER}\n * - {@link AccountRole.WRITABLE_SIGNER}\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner} to use within the account meta.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole } from '@solana/instructions';\n * import { generateKeyPairSigner, AccountSignerMeta } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const account: AccountSignerMeta = {\n *     address: signer.address,\n *     role: AccountRole.READONLY_SIGNER,\n *     signer,\n * };\n * ```\n */\nexport interface AccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends AccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\n/**\n * A union type that supports base account metas as well as {@link AccountSignerMeta | signer account metas}.\n */\ntype AccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | AccountLookupMeta\n    | AccountMeta\n    | AccountSignerMeta<string, TSigner>;\n\n/**\n * Composable type that allows {@link AccountSignerMeta | AccountSignerMetas} to be used inside the instruction's `accounts` array\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { generateKeyPairSigner, InstructionWithSigners } from '@solana/signers';\n *\n * const [authority, buffer] = await Promise.all([\n *     generateKeyPairSigner(),\n *     generateKeyPairSigner(),\n * ]);\n * const instruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [\n *         // The authority is a signer account.\n *         {\n *             address: authority.address,\n *             role: AccountRole.READONLY_SIGNER,\n *             signer: authority,\n *         },\n *         // The buffer is a writable account.\n *         { address: buffer.address, role: AccountRole.WRITABLE },\n *     ],\n * };\n * ```\n */\nexport type InstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Pick<Instruction<string, TAccounts>, 'accounts'>;\n\n/**\n * A {@link BaseTransactionMessage} type extension that accept {@link TransactionSigner | TransactionSigners}.\n *\n * Namely, it allows:\n * - a {@link TransactionSigner} to be used as the fee payer and\n * - {@link InstructionWithSigners} to be used in its instructions.\n *\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, InstructionWithSigners, TransactionMessageWithSigners } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const firstInstruction: Instruction = { ... };\n * const secondInstruction: InstructionWithSigners = { ... };\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithSigners = {\n *     feePayer: signer,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n * ```\n */\nexport type TransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Partial<TransactionMessageWithFeePayer<TAddress> | TransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, Instruction & InstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside the account metas of an {@link InstructionWithSigners | instruction}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n *\n * @example\n * ```ts\n * import { InstructionWithSigners, getSignersFromInstruction } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const instructionWithSigners: InstructionWithSigners = {\n *     accounts: [\n *         { address: signerA.address, signer: signerA, ... },\n *         { address: signerB.address, signer: signerB, ... },\n *         { address: signerA.address, signer: signerA, ... },\n *     ],\n * };\n *\n * const instructionSigners = getSignersFromInstruction(instructionWithSigners);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: InstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside a given {@link TransactionMessageWithSigners | transaction message}.\n *\n * This includes any {@link TransactionSigner | TransactionSigners} stored\n * as the fee payer or in the instructions of the transaction message.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { InstructionWithSigners, TransactionMessageWithSigners, getSignersFromTransactionMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const firstInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerA.address, signer: signerA, ... }],\n * };\n * const secondInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerB.address, signer: signerB, ... }],\n * };\n * const transactionMessage: TransactionMessageWithSigners = {\n *     feePayer: signerA,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n *\n * const transactionSigners = getSignersFromTransactionMessage(transactionMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends TransactionMessageWithSigners<TAddress, TSigner> = TransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { Address } from '@solana/addresses';\nimport { Instruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { AccountSignerMeta, InstructionWithSigners, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of an instruction when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TInstruction - The inferred type of the instruction provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { addSignersToInstruction, TransactionSigner } from '@solana/signers';\n *\n * const instruction: Instruction = {\n *     accounts: [\n *         { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n *         { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n *     ],\n *     // ...\n * };\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const instructionWithSigners = addSignersToInstruction(\n *     [signerA, signerB],\n *     instruction\n * );\n *\n * // instructionWithSigners.accounts[0].signer === signerA\n * // instructionWithSigners.accounts[1].signer === signerB\n * ```\n */\nexport function addSignersToInstruction<TInstruction extends Instruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (InstructionWithSigners & TInstruction),\n): InstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as InstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as AccountSignerMeta);\n        }),\n    });\n}\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of all instructions inside a transaction message and/or\n * the transaction message fee payer, when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { addSignersToTransactionMessage, TransactionSigner } from '@solana/signers';\n *\n * const instructionA: Instruction = {\n *     accounts: [{ address: '1111' as Address, role: AccountRole.READONLY_SIGNER }],\n *     // ...\n * };\n * const instructionB: Instruction = {\n *     accounts: [{ address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER }],\n *     // ...\n * };\n * const transactionMessage: BaseTransactionMessage = {\n *     instructions: [instructionA, instructionB],\n *     // ...\n * }\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const transactionMessageWithSigners = addSignersToTransactionMessage(\n *     [signerA, signerB],\n *     transactionMessage\n * );\n *\n * // transactionMessageWithSigners.instructions[0].accounts[0].signer === signerA\n * // transactionMessageWithSigners.instructions[1].accounts[0].signer === signerB\n * ```\n */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (TransactionMessageWithSigners & TTransactionMessage),\n): TransactionMessageWithSigners & TTransactionMessage {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage)\n        ? signers.find(signer => signer.address === transactionMessage.feePayer.address)\n        : undefined;\n\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage as TransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        ...(feePayerSigner ? { feePayer: feePayerSigner } : null),\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n\nfunction hasAddressOnlyFeePayer(\n    message: BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n): message is BaseTransactionMessage & { feePayer: { address: Address } } {\n    return (\n        !!message &&\n        'feePayer' in message &&\n        !!message.feePayer &&\n        typeof message.feePayer.address === 'string' &&\n        !isTransactionSigner(message.feePayer)\n    );\n}\n","import { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Alternative to {@link TransactionMessageWithFeePayer} that uses a {@link TransactionSigner} for the fee payer.\n *\n * @typeParam TAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner}.\n *\n * @example\n * ```ts\n * import { TransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, TransactionMessageWithFeePayerSigner } from '@solana/signers';\n *\n * const transactionMessage: TransactionMessage & TransactionMessageWithFeePayerSigner = {\n *     feePayer: await generateKeyPairSigner(),\n *     instructions: [],\n *     version: 0,\n * };\n * ```\n */\nexport interface TransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends unknown ? Omit<TTransactionMessage, 'feePayer'> : never;\n\n/**\n * Sets the fee payer of a {@link TransactionMessage | transaction message}\n * using a {@link TransactionSigner}.\n *\n * @typeParam TFeePayerAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { pipe } from '@solana/functional';\n * import { generateKeyPairSigner, setTransactionMessageFeePayerSigner } from '@solana/signers';\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const feePayer = await generateKeyPairSigner();\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(signer, message),\n * );\n * ```\n */\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends Partial<TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner> &\n        TransactionMessage,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayerSigner<TFeePayerAddress> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out as ExcludeTransactionMessageFeePayer<TTransactionMessage> &\n        TransactionMessageWithFeePayerSigner<TFeePayerAddress>;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessagePartialSigner#signMessages | signMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link SignableMessage | SignableMessages}\n * without modifying their content.\n *\n * It defines a {@link MessagePartialSigner#signMessages | signMessages} function\n * that returns a {@link SignatureDictionary} for each provided message.\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessagePartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. When multiple signers sign the same message, we can\n *   perform this operation in parallel to obtain all their signatures.\n * - **Flexible order**. The order in which we use these signers\n *   for a given message doesnt matter.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessagePartialSigner}\n * @see {@link assertIsMessagePartialSigner}\n */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessagePartialSigner({ address, signMessages: async () => {} }); // true\n * isMessagePartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessagePartialSigner}\n */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessagePartialSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessagePartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessagePartialSigner}\n */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a signer that uses a {@link CryptoKeyPair} to sign messages and transactions.\n *\n * It implements both the {@link MessagePartialSigner} and {@link TransactionPartialSigner}\n * interfaces and keeps track of the {@link CryptoKeyPair} instance used\n * to sign messages and transactions.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = generateKeyPairSigner();\n * signer.address; // Address;\n * signer.keyPair; // CryptoKeyPair;\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * ```\n *\n * @see {@link generateKeyPairSigner}\n * @see {@link createSignerFromKeyPair}\n * @see {@link createKeyPairSignerFromBytes}\n * @see {@link createKeyPairSignerFromPrivateKeyBytes}\n * @see {@link isKeyPairSigner}\n * @see {@link assertIsKeyPairSigner}\n */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/**\n * Checks whether the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, isKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * isKeyPairSigner(signer); // true\n * isKeyPairSigner({ address: address('1234..5678') }); // false\n * ```\n */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, assertIsKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * assertIsKeyPairSigner(signer); // void\n * assertIsKeyPairSigner({ address: address('1234..5678') }); // Throws an error.\n * ```\n */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/**\n * Creates a {@link KeyPairSigner} from a provided {@link CryptoKeyPair}.\n *\n * The {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * functions of the returned signer will use the private key of the provided\n * key pair to sign messages and transactions.\n *\n * Note that both the {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions} implementations\n * are parallelized, meaning that they will sign all provided messages and transactions in parallel.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n *\n * const keyPair: CryptoKeyPair = await generateKeyPair();\n * const signer: KeyPairSigner = await createSignerFromKeyPair(keyPair);\n * ```\n */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/**\n * Generates a signer capable of signing messages and transactions by generating\n * a {@link CryptoKeyPair} and creating a {@link KeyPairSigner} from it.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * ```\n *\n * @see {@link createSignerFromKeyPair}\n */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 64-bytes `Uint8Array` secret key (private key and public key).\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairSignerFromBytes } from '@solana/signers';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a KeyPairSigner from the bytes.\n * const signer = await createKeyPairSignerFromBytes(keypairBytes);\n * ```\n *\n * @see {@link createKeyPairSignerFromPrivateKeyBytes} if you only have the 32-bytes private key instead.\n */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 32-bytes `Uint8Array` private key.\n *\n * @example\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairSignerFromPrivateKeyBytes } from '@solana/signers';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n * ```\n *\n * @see {@link createKeyPairSignerFromBytes} if you have the 64-bytes secret key instead (private key and public key).\n */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that _potentially_ modifies the content\n * of the provided {@link SignableMessage | SignableMessages} before signing them.\n *\n * For instance, this enables wallets to prefix or suffix nonces to the messages they sign.\n * For each message, instead of returning a {@link SignatureDictionary}, the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} function\n * returns an updated {@link SignableMessage} with a potentially modified content and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessageModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignableMessage[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the content of the message.\n * - **First signers**. For a given message, a modifying signer must always be used\n *   before a partial signer as the former will likely modify the message and\n *   thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided, the second\n *   signer may invalidate the signature of the first one. However, modifying signers\n *   may decide not to modify a message based on the existence of signatures for that message.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessageModifyingSigner}\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageModifyingSigner}\n */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/**\n * Defines a signer capable of signing messages.\n *\n * @see {@link MessageModifyingSigner} For signers that can modify messages before signing them.\n * @see {@link MessagePartialSigner} For signers that can be used in parallel.\n * @see {@link isMessageSigner}\n * @see {@link assertIsMessageSigner}\n */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageSigner({ address, signMessages: async () => {} }); // true\n * isMessageSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageSigner}\n */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessageSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageSigner}\n */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a Noop (No-Operation) signer that pretends to partially sign messages and transactions.\n *\n * For a given {@link Address}, a Noop Signer can be created to offer an implementation of both\n * the {@link MessagePartialSigner} and {@link TransactionPartialSigner} interfaces such that\n * they do not sign anything. Namely, signing a transaction or a message with a `NoopSigner`\n * will return an empty `SignatureDictionary`.\n *\n * @typeParam TAddress - Supply a string literal to define a Noop signer having a particular address.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * // ^ Both messageSignatures and transactionSignatures are empty.\n * ```\n *\n * @remarks\n * This signer may be useful:\n *\n * - For testing purposes.\n * - For indicating that a given account is a signer and taking the responsibility to provide\n *   the signature for that account ourselves. For instance, if we need to send the transaction\n *   to a server that will sign it and send it for us.\n *\n * @see {@link createNoopSigner}\n */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/**\n * Creates a {@link NoopSigner} from the provided {@link Address}.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * ```\n */\nexport function createNoopSigner<TAddress extends string = string>(address: Address<TAddress>): NoopSigner<TAddress> {\n    const out: NoopSigner<TAddress> = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import { OffchainMessageWithRequiredSignatories } from '@solana/offchain-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isMessageSigner, MessageSigner } from './message-signer';\n\n/**\n * Represents a {@link Signer} that is required to sign an offchain message for it to be valid.\n */\nexport type OffchainMessageSignatorySigner<TAddress extends string = string> = MessageSigner<TAddress>;\n\n/**\n * Extracts and deduplicates all {@link MessageSigner | MessageSigners} stored inside a given\n * {@link OffchainMessageWithSigners | offchain message}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link MessageSigner | MessageSigners}.\n * @typeParam TOffchainMessage - The inferred type of the offchain message provided.\n *\n * @example\n * ```ts\n * import { OffchainMessageWithSigners, getSignersFromOffchainMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signMessages: async () => {} };\n * const signerB = { address: address('2222..2222'), modifyAndSignMessages: async () => {} };\n * const OffchainMessage: OffchainMessageWithSigners = {\n *     /* ... *\\/\n *     requiredSignatories: [signerA, signerB],\n * };\n *\n * const messageSigners = getSignersFromOffchainMessage(offchainMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromOffchainMessage({\n    requiredSignatories,\n}: OffchainMessageWithRequiredSignatories): readonly MessageSigner[] {\n    const messageSigners = requiredSignatories.filter(isMessageSigner);\n    return deduplicateSigners(messageSigners);\n}\n","import {\n    assertIsFullySignedOffchainMessageEnvelope,\n    compileOffchainMessageEnvelope,\n    FullySignedOffchainMessageEnvelope,\n    OffchainMessage,\n    OffchainMessageEnvelope,\n    OffchainMessageSignatory,\n    OffchainMessageWithRequiredSignatories,\n} from '@solana/offchain-messages';\n\nimport {\n    isMessageModifyingSigner,\n    MessageModifyingSigner,\n    MessageModifyingSignerConfig,\n} from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner, MessagePartialSignerConfig } from './message-partial-signer';\nimport { MessageSigner } from './message-signer';\nimport { getSignersFromOffchainMessage, OffchainMessageSignatorySigner } from './offchain-message-signer';\nimport { SignableMessage } from './signable-message';\n\n/**\n * Extracts all {@link MessageSigner | MessageSigners} inside the provided offchain message and uses\n * them to return a signed offchain message envelope.\n *\n * It first uses all {@link MessageModifyingSigner | MessageModifyingSigners} sequentially before\n * using all {@link MessagePartialSigner | MessagePartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link MessageModifyingSigner} if no other signer implements that interface. Otherwise, it will\n * be used as a {@link MessagePartialSigner}.\n *\n * @example\n * ```ts\n * const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @see {@link signOffchainMessageWithSigners}\n */\nexport async function partiallySignOffchainMessageWithSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    config?: MessagePartialSignerConfig,\n): Promise<OffchainMessageEnvelope> {\n    const { partialSigners, modifyingSigners } = categorizeMessageSigners(\n        getSignersFromOffchainMessage(offchainMessage),\n    );\n    return await signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners, partialSigners, config);\n}\n\n/**\n * Extracts all {@link MessageSigner | MessageSigners} inside the provided offchain message and uses\n * them to return a signed offchain message envelope before asserting that all signatures required\n * by the message are present.\n *\n * This function delegates to the {@link partiallySignOffchainMessageWithSigners} function\n * in order to extract signers from the offchain message and sign it.\n *\n * @example\n * ```ts\n * const mySignedOffchainMessageEnvelope = await signOffchainMessageWithSigners(myOffchainMessage);\n *\n * // With additional config.\n * const mySignedOffchainMessageEnvelope = await signOffchainMessageWithSigners(myOffchainMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the offchain message is fully signed.\n * mySignedOffchainMessageEnvelope satisfies FullySignedOffchainMessageEnvelope;\n * ```\n *\n * @see {@link partiallySignOffchainMessageWithSigners}\n */\nexport async function signOffchainMessageWithSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    config?: MessagePartialSignerConfig,\n): Promise<FullySignedOffchainMessageEnvelope & OffchainMessageEnvelope> {\n    const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, config);\n    assertIsFullySignedOffchainMessageEnvelope(signedOffchainMessageEnvelope);\n    return signedOffchainMessageEnvelope;\n}\n\n/**\n * Identifies each provided {@link MessageSigner} and categorizes them into their respective types.\n * When a signer implements multiple interfaces, it will try to used to most powerful interface but\n * fall back to the least powerful interface when necessary.\n *\n * For instance, if a signer implements {@link MessageSigner} and {@link MessageModifyingSigner},\n * it will be categorized as a `MessageModifyingSigner`.\n */\nfunction categorizeMessageSigners(signers: readonly MessageSigner[]): Readonly<{\n    modifyingSigners: readonly MessageModifyingSigner[];\n    partialSigners: readonly MessagePartialSigner[];\n}> {\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyMessageModifyingSigners(signers);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = signers\n        .filter(isMessagePartialSigner)\n        .filter(signer => !(modifyingSigners as typeof signers).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners });\n}\n\n/** Identifies the best signers to use as MessageModifyingSigners, if any */\nfunction identifyMessageModifyingSigners(\n    signers: readonly (MessageModifyingSigner | MessagePartialSigner)[],\n): readonly MessageModifyingSigner[] {\n    // Ensure there are any MessageModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isMessageModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isMessagePartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs an offchain message using the provided\n * {@link MessageModifyingSigner | MessageModifyingSigners} sequentially followed by the\n * {@link MessagePartialSigner | MessagePartialSigners} in parallel.\n */\nasync function signModifyingAndPartialMessageSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    modifyingSigners: readonly MessageModifyingSigner[] = [],\n    partialSigners: readonly MessagePartialSigner[] = [],\n    config?: MessageModifyingSignerConfig,\n): Promise<OffchainMessageEnvelope> {\n    // @ts-expect-error SignableMessage should probably specify `ReadonlyUint8Array` here.\n    const offchainMessageEnvelope: SignableMessage = compileOffchainMessageEnvelope(offchainMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedOffchainMessage = await modifyingSigners.reduce(async (offchainMessageEnvelope, modifyingSigner) => {\n        config?.abortSignal?.throwIfAborted();\n        const [message] = await modifyingSigner.modifyAndSignMessages([await offchainMessageEnvelope], config);\n        return Object.freeze(message);\n    }, Promise.resolve(offchainMessageEnvelope));\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signMessages([modifiedOffchainMessage], config);\n            return signatures;\n        }),\n    );\n\n    // @ts-expect-error SignableMessage should probably specify `ReadonlyUint8Array` here.\n    return Object.freeze({\n        ...modifiedOffchainMessage,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedOffchainMessage.signatures ?? {}),\n        ),\n    } as OffchainMessageEnvelope);\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a transaction message with exactly one {@link TransactionSendingSigner}.\n *\n * This type is used to narrow the type of transaction messages that have been\n * checked to have exactly one sending signer.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithSingleSendingSigner } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithSingleSendingSigner;\n * ```\n *\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport type TransactionMessageWithSingleSendingSigner = Brand<\n    TransactionMessageWithSigners,\n    'TransactionMessageWithSingleSendingSigner'\n>;\n\n/**\n * Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using {@link signAndSendTransactionMessageWithSigners} to provide\n * a fallback strategy in case the transaction message cannot be send using this function.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     isTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners,\n *     signTransactionMessageWithSigners,\n * } from '@solana/signers';\n * import { getBase64EncodedWireTransaction } from '@solana/transactions';\n *\n * let transactionSignature: SignatureBytes;\n * if (isTransactionMessageWithSingleSendingSigner(transactionMessage)) {\n *     transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * } else {\n *     const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n *     const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n *     transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n * }\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport function isTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transaction: TTransactionMessage): transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Asserts that the provided transaction message has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using the {@link signAndSendTransactionMessageWithSigners} function\n * to ensure it will be able to select the correct signer to send the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     assertIsTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners\n * } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport {\n    assertIsFullySignedTransaction,\n    compileTransaction,\n    SendableTransaction,\n    Transaction,\n    TransactionWithinSizeLimit,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction.\n *\n * It first uses all {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before\n * using all {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link TransactionModifyingSigner} if no other signer implements that interface.\n * Otherwise, it will be used as a {@link TransactionPartialSigner}.\n *\n * @example\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Finally, note that this function ignores {@link TransactionSendingSigner | TransactionSendingSigners}\n * as it does not send the transaction. Check out the {@link signAndSendTransactionMessageWithSigners}\n * function for more details on how to use sending signers.\n *\n * @see {@link signTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function partiallySignTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction before asserting\n * that all signatures required by the transaction are present.\n *\n * This function delegates to the {@link partiallySignTransactionMessageWithSigners} function\n * in order to extract signers from the transaction message and sign the transaction.\n *\n * @example\n * ```ts\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n *\n * // With additional config.\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the transaction is fully signed.\n * mySignedTransaction satisfies FullySignedTransaction;\n * ```\n *\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function signTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<SendableTransaction & Transaction & TransactionWithLifetime> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertIsFullySignedTransaction(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to sign it before sending it immediately to the blockchain.\n *\n * It returns the signature of the sent transaction (i.e. its identifier) as bytes.\n *\n * @example\n * ```ts\n * import { signAndSendTransactionMessageWithSigners } from '@solana/signers';\n *\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n *\n * // With additional config.\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Similarly to the {@link partiallySignTransactionMessageWithSigners} function, it first uses all\n * {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before using all\n * {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n * It then sends the transaction using the {@link TransactionSendingSigner} it identified.\n *\n * Composite transaction signers are treated such that at least one sending signer is used if any.\n * When a {@link TransactionSigner} implements more than one interface, we use it as a:\n *\n * - {@link TransactionSendingSigner}, if no other {@link TransactionSendingSigner} exists.\n * - {@link TransactionModifyingSigner}, if no other {@link TransactionModifyingSigner} exists.\n * - {@link TransactionPartialSigner}, otherwise.\n *\n * The provided transaction must contain exactly one {@link TransactionSendingSigner} inside its account metas.\n * If more than one composite signers implement the {@link TransactionSendingSigner} interface,\n * one of them will be selected as the sending signer. Otherwise, if multiple\n * {@link TransactionSendingSigner | TransactionSendingSigners} must be selected, the function will throw an error.\n *\n * If you'd like to assert that a transaction makes use of exactly one {@link TransactionSendingSigner}\n * _before_ calling this function, you may use the {@link assertIsTransactionMessageWithSingleSendingSigner} function.\n *\n * Alternatively, you may use the {@link isTransactionMessageWithSingleSendingSigner} function to provide a\n * fallback in case the transaction does not contain any sending signer.\n *\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signTransactionMessageWithSigners}\n *\n */\nexport async function signAndSendTransactionMessageWithSigners(\n    transaction: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionSendingSignerConfig,\n): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = (await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    )) as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime;\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    });\n}\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/**\n * Defines a message that needs signing and its current set of signatures if any.\n *\n * This interface allows {@link MessageModifyingSigner | MessageModifyingSigners}\n * to decide on whether or not they should modify the provided message depending\n * on whether or not signatures already exist for such message.\n *\n * It also helps create a more consistent API by providing a structure analogous\n * to transactions which also keep track of their {@link SignatureDictionary}.\n *\n * @example\n * ```ts\n * import { createSignableMessage } from '@solana/signers';\n *\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * message.content; // The content of the message as bytes.\n * message.signatures; // The current set of signatures for this message.\n * ```\n *\n * @see {@link createSignableMessage}\n */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a {@link SignableMessage} from a `Uint8Array` or a UTF-8 string.\n *\n * It optionally accepts a signature dictionary if the message already contains signatures.\n *\n * @example\n * ```ts\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * const messageFromText = createSignableMessage('Hello world!');\n * const messageWithSignatures = createSignableMessage('Hello world!', {\n *     [address('1234..5678')]: new Uint8Array([1, 2, 3]) as SignatureBytes,\n * });\n * ```\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n"],"names":["SolanaError","offchainMessageEnvelope","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING","transaction","TextEncoder"],"mappings":"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"}},
    {"offset": {"line": 9372, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/accounts/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/accounts/src/account.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/accounts/src/decode-account.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/accounts/src/parse-account.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/accounts/src/fetch-account.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/accounts/src/maybe-account.ts"],"sourcesContent":["import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/**\n * The number of bytes required to store the {@link BaseAccount} information without its data.\n *\n * @example\n * ```ts\n * const myTotalAccountSize = myAccountDataSize + BASE_ACCOUNT_SIZE;\n * ```\n */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/**\n * Defines the attributes common to all Solana accounts. Namely, it contains everything stored\n * on-chain except the account data itself.\n *\n * @interface\n *\n * @example\n * ```ts\n * const BaseAccount: BaseAccount = {\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n    readonly space: bigint;\n};\n\n/**\n * Contains all the information relevant to a Solana account. It includes the account's address and\n * data, as well as the properties of {@link BaseAccount}.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Encoded\n * const myEncodedAccount: Account<Uint8Array, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n *\n * // Decoded\n * type MyAccountData = { name: string; age: number };\n * const myDecodedAccount: Account<MyAccountData, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/**\n * Represents an encoded account and is equivalent to an {@link Account} with `Uint8Array` account\n * data.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * } satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/**\n * Transforms an {@link EncodedAccount} into an {@link Account} (or a {@link MaybeEncodedAccount}\n * into a {@link MaybeAccount}) by decoding the account data using the provided {@link Decoder}\n * instance.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: EncodedAccount<'1234..5678'>;\n * const myDecoder: Decoder<MyAccountData> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n *\n * const myDecodedAccount = decodeAccount(myAccount, myDecoder);\n * myDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n * ```\n */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/**\n * Asserts that an account stores decoded data, ie. not a `Uint8Array`.\n *\n * Note that it does not check the shape of the data matches the decoded type, only that it is not a\n * `Uint8Array`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\n * assertAccountDecoded(myAccount);\n *\n * // now the account data can be used as MyAccountData\n * account.data satisfies MyAccountData;\n * ```\n *\n * This is particularly useful for narrowing the result of fetching a JSON parsed account.\n *\n * ```ts\n * const account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n *     rpc,\n *     '1234..5678' as Address,\n * );\n *\n * assertAccountDecoded(account);\n * // now we have a MaybeAccount<MockData>\n * account satisfies MaybeAccount<MockData>;\n * ```\n */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/**\n * Asserts that all input accounts store decoded data, ie. not a `Uint8Array`.\n *\n * As with {@link assertAccountDecoded} it does not check the shape of the data matches the decoded\n * type, only that it is not a `Uint8Array`.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccounts: Account<MyAccountData | Uint8Array, Address>[];\n * assertAccountsDecoded(myAccounts);\n *\n * // now the account data can be used as MyAccountData\n * for (const a of account) {\n *     account.data satisfies MyAccountData;\n * }\n * ```\n */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/**\n * Parses a base64-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/**\n * Parses a base58-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\ntype ParsedAccountMeta = { program: string; type?: string };\ntype JsonParsedAccountData<TData extends object> = TData & { parsedAccountMeta?: ParsedAccountMeta };\n\n/**\n * Parses an arbitrary `jsonParsed` account provided by the RPC client into an {@link Account} type\n * or a {@link MaybeAccount} type if the raw data can be set to `null`.\n *\n * The expected data type should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * const myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n * ```\n */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<JsonParsedAccountData<TData>, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<JsonParsedAccountData<TData>, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<JsonParsedAccountData<TData>, TAddress> | MaybeAccount<JsonParsedAccountData<TData>, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = (rpcAccount.data.parsed.info || {}) as TData;\n\n    if (rpcAccount.data.program || rpcAccount.data.parsed.type) {\n        (data as JsonParsedAccountData<TData>).parsedAccountMeta = {\n            program: rpcAccount.data.program,\n            type: rpcAccount.data.parsed.type,\n        };\n    }\n\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/**\n * Optional configuration for fetching a singular account.\n *\n * @interface\n */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the account as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches a {@link MaybeEncodedAccount} from the provided RPC client and address.\n *\n * It uses the {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} RPC method under the hood\n * with base64 encoding and an additional configuration object can be provided to customize the\n * behavior of the RPC call.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n *\n * // With custom configuration.\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/**\n * Fetches a {@link MaybeAccount} from the provided RPC client and address by using\n * {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} under the hood with the `jsonParsed`\n * encoding.\n *\n * It may also return a {@link MaybeEncodedAccount} if the RPC client does not know how to parse the\n * account at the requested address. In any case, the expected data type should be explicitly\n * provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\n * myAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n *\n * // With custom configuration.\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<\n    | MaybeAccount<TData & { parsedAccountMeta?: { program: string; type?: string } }, TAddress>\n    | MaybeEncodedAccount<TAddress>\n> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/**\n * Optional configuration for fetching multiple accounts.\n *\n * @interface\n */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the accounts as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches an array of {@link MaybeEncodedAccount | MaybeEncodedAccounts} from the provided RPC\n * client and an array of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with base64 encodings and an additional configuration object can be provided to\n * customize the behavior of the RPC call.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n *\n * @example\n * ```ts\n * const myAddressA = address('1234..5678');\n * const myAddressB = address('8765..4321');\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\n * myAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n *\n * // With custom configuration.\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/**\n * Fetches an array of {@link MaybeAccount | MaybeAccounts} from a provided RPC client and an array\n * of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with the `jsonParsed` encoding. It may also return a\n * {@link MaybeEncodedAccount} instead of the expected {@link MaybeAccount} if the RPC client does\n * not know how to parse some of the requested accounts. In any case, the array of expected data\n * types should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n * @typeParam TData - The expected types of these accounts' data.\n \n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * type MintData = { supply: bigint };\n * const [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n * myAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n * ```\n */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<\n                  TData[P & keyof TData] & { parsedAccountMeta?: { program: string; type?: string } },\n                  TAddresses[P]\n              >\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<\n                  TData[P] & { parsedAccountMeta?: { program: string; type?: string } },\n                  TAddresses[P & keyof TAddresses]\n              >\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/**\n * Represents an account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type with an additional `exists`\n * attribute set to `true`. When it does not exist, it is represented by an object containing only\n * the address of the account and an `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Account exists\n * const myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     // ...\n * };\n *\n * // Account does not exist\n * const myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/**\n * Represents an encoded account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type having its `TData` type\n * parameter set to `Uint8Array` with an additional `exists` attribute set to `true`. When it does\n * not exist, it is represented by an object containing only the address of the account and an\n * `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * // Encoded account exists\n * const myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     // ...\n * };\n *\n * // Encoded account does not exist\n * const myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/**\n * Given a {@link MaybeAccount}, asserts that the account exists and allows it to be used as an\n * {@link Account} type going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccount: MaybeEncodedAccount<'1234..5678'>;\n * assertAccountExists(myAccount);\n *\n * // Now we can use myAccount as an `EncodedAccount`\n * myAccount satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/**\n * Given an array of {@link MaybeAccount | MaybeAccounts}, asserts that all the accounts exist and\n * allows them to be used as an array of {@link Account | Accounts} going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccounts: MaybeEncodedAccount<Address>[];\n * assertAccountsExist(myAccounts);\n *\n * // Now we can use them as an array of `EncodedAccounts`\n * for (const a of myAccounts) {\n *     a satisfies EncodedAccount<Address>;\n * }\n * ```\n */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 9559, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/programs/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/programs/src/program-error.ts"],"sourcesContent":["import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\n/**\n * Identifies whether an error -- typically caused by a transaction failure -- is a custom program\n * error from the provided program address.\n *\n * @param transactionMessage The transaction message that failed to execute. Since the RPC response\n * only provides the index of the failed instruction, the transaction message is required to\n * determine its program address\n * @param programAddress The address of the program from which the error is expected to have\n * originated\n * @param code The expected error code of the custom program error. When provided, the function will\n * check that the custom program error code matches the given value.\n *\n * @example\n * ```ts\n * try {\n *     // Send and confirm your transaction.\n * } catch (error) {\n *     if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n *         // Handle custom program error 42 from this program.\n *     } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n *         // Handle all other custom program errors from this program.\n *     } else {\n *         throw error;\n *     }\n * }\n * ```\n */\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n"],"names":[],"mappings":";;;;;;;AA8BO,SAAS,cAAA,CACZ,KAAA,EACA,kBAAA,EACA,cAAA,EACA,IAAA,EAE4D;IAC5D,IAAI,KAAC,6KAAA,EAAc,KAAA,EAAO,uMAAuC,CAAA,EAAG;QAChE,OAAO,KAAA;IACX;IACA,MAAM,4BAA4B,kBAAA,CAAmB,YAAA,CAAa,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG,cAAA;IACxF,IAAI,CAAC,yBAAA,IAA6B,yBAAA,KAA8B,cAAA,EAAgB;QAC5E,OAAO,KAAA;IACX;IACA,OAAO,OAAO,IAAA,KAAS,WAAA,IAAe,KAAA,CAAM,OAAA,CAAQ,IAAA,KAAS,IAAA;AACjE"}},
    {"offset": {"line": 9583, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/options/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/options/src/option.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/options/src/unwrap-option.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/options/src/option-codec.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/options/src/unwrap-option-recursively.ts"],"sourcesContent":["/**\n * An implementation of the Rust `Option<T>` type in JavaScript.\n *\n * In Rust, optional values are represented using `Option<T>`, which can be either:\n * - `Some(T)`, indicating a present value.\n * - `None`, indicating the absence of a value.\n *\n * In JavaScript, this is typically represented as `T | null`. However, this approach fails with nested options.\n * For example, `Option<Option<T>>` in Rust would translate to `T | null | null` in JavaScript, which is equivalent to `T | null`.\n * This means there is no way to differentiate between `Some(None)` and `None`, making nested options impossible.\n *\n * This `Option` type helps solve this by mirroring Rusts `Option<T>` type.\n *\n * ```ts\n * type Option<T> = Some<T> | None;\n * type Some<T> = { __option: 'Some'; value: T };\n * type None = { __option: 'None' };\n * ```\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Here's how you can create `Option` values.\n *\n * To improve developer experience, helper functions are available.\n * TypeScript can infer the type of `T` or it can be explicitly provided.\n *\n * ```ts\n * // Create an option with a value.\n * some('Hello World');\n * some<number | string>(123);\n *\n * // Create an empty option.\n * none();\n * none<number | string>();\n * ```\n *\n * @see {@link Some}\n * @see {@link None}\n * @see {@link some}\n * @see {@link none}\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * A flexible type that allows working with {@link Option} values or nullable values.\n *\n * It defines a looser type that can be used when encoding {@link Option | Options}.\n * This allows us to pass `null` or the nested value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Accepting both `Option<T>` and `T | null` as input.\n * ```ts\n * function double(value: OptionOrNullable<number>) {\n *   const option = isOption(value) ? value : wrapNullable(value);\n *   return isSome(option) ? option.value * 2 : 'No value';\n * }\n *\n * double(42);       // 84\n * double(some(21)); // 42\n * double(none());   // \"No value\"\n * double(null);     // \"No value\"\n * ```\n *\n * @see {@link Option}\n * @see {@link isOption}\n * @see {@link wrapNullable}\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an {@link Option} that contains a value.\n *\n * This type mirrors Rusts `Some(T)`, indicating that a value is present.\n *\n * For more details, see {@link Option}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Creating a `Some` value.\n * ```ts\n * const value = some(42);\n * isSome(value); // true\n * isNone(value); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link some}\n * @see {@link isSome}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an {@link Option} that contains no value.\n *\n * This type mirrors Rusts `None`, indicating the absence of a value.\n *\n * For more details, see {@link Option}.\n *\n * @example\n * Creating a `None` value.\n * ```ts\n * const empty = none();\n * isNone(empty); // true\n * isSome(empty); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link none}\n * @see {@link isNone}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} that contains a value.\n *\n * This function explicitly wraps a value in an {@link Option} type.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param value - The value to wrap in an {@link Option}.\n * @returns An {@link Option} containing the provided value.\n *\n * @example\n * Wrapping a value in an `Option`.\n * ```ts\n * const option = some('Hello');\n * option.value;     // \"Hello\"\n * isOption(option); // true\n * isSome(option);   // true\n * isNone(option);   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} that contains no value.\n *\n * This function explicitly represents an absent value.\n *\n * @typeParam T - The type of the expected absent value.\n *\n * @returns An {@link Option} containing no value.\n *\n * @example\n * Creating an empty `Option`.\n * ```ts\n * const empty = none<number>();\n * isOption(empty); // true\n * isSome(empty);   // false\n * isNone(empty);   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Checks whether the given value is an {@link Option}.\n *\n * This function determines whether an input follows the `Option<T>` structure.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param input - The value to check.\n * @returns `true` if the value is an {@link Option}, `false` otherwise.\n *\n * @example\n * Checking for `Option` values.\n * ```ts\n * isOption(some(42));        // true\n * isOption(none());          // true\n * isOption(42);              // false\n * isOption(null);            // false\n * isOption(\"anything else\"); // false\n * ```\n *\n * @see {@link Option}\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Checks whether the given {@link Option} contains a value.\n *\n * This function acts as a type guard, ensuring the value is a {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link Some}, `false` otherwise.\n *\n * @example\n * Checking for `Some` values.\n * ```ts\n * isSome(some(42)); // true\n * isSome(none());   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Checks whether the given {@link Option} contains no value.\n *\n * This function acts as a type guard, ensuring the value is a {@link None}.\n *\n * @typeParam T - The type of the expected value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link None}, `false` otherwise.\n *\n * @example\n * Checking for `None` values.\n * ```ts\n * isNone(some(42)); // false\n * isNone(none());   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option}, returning its contained value or a fallback.\n *\n * This function extracts the value `T` from an `Option<T>` type.\n * - If the option is {@link Some}, it returns the contained value `T`.\n * - If the option is {@link None}, it returns the fallback value `U`, which defaults to `null`.\n *\n * @typeParam T - The type of the contained value.\n * @typeParam U - The type of the fallback value (defaults to `null`).\n *\n * @param option - The {@link Option} to unwrap.\n * @param fallback - A function that provides a fallback value if the option is {@link None}.\n * @returns The contained value if {@link Some}, otherwise the fallback value.\n *\n * @example\n * Unwrapping an `Option` with no fallback.\n * ```ts\n * unwrapOption(some('Hello World')); // \"Hello World\"\n * unwrapOption(none());              // null\n * ```\n *\n * @example\n * Providing a custom fallback value.\n * ```ts\n * unwrapOption(some('Hello World'), () => 'Default'); // \"Hello World\"\n * unwrapOption(none(), () => 'Default');              // \"Default\"\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n *\n * - If the input value is `null`, this function returns {@link None}.\n * - Otherwise, it wraps the value in {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param nullable - The nullable value to wrap.\n * @returns An {@link Option} wrapping the value.\n *\n * @example\n * Wrapping nullable values.\n * ```ts\n * wrapNullable('Hello World'); // Option<string> (Some)\n * wrapNullable<string>(null);  // Option<string> (None)\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/**\n * Defines the configuration options for {@link Option} codecs.\n *\n * The `getOptionCodec` function behaves similarly to {@link getNullableCodec}\n * but encodes `Option<T>` types instead of `T | null` types.\n *\n * This configuration controls how {@link None} values are encoded and how presence\n * is determined when decoding.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n * @see {@link getOptionCodec}\n */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how {@link None} values are represented in the encoded data.\n     *\n     * - By default, {@link None} values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec for the item.\n     * - Custom byte array: {@link None} values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; {@link None} values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between {@link None} and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines {@link None}.\n     *   If no `noneValue` is set, {@link None} is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values using the {@link Option} type.\n *\n * This encoder serializes an {@link OptionOrNullable} value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, {@link None} values are encoded as zeroes.\n * - If `noneValue` is a byte array, {@link None} values are replaced with the provided constant.\n *\n * Unlike {@link getNullableEncoder}, this encoder accepts both {@link Option} and {@link Nullable} values.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding option values.\n *\n * @example\n * Encoding an optional string.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const encoder = getOptionEncoder(stringCodec);\n *\n * encoder.encode(some('Hi'));\n * encoder.encode('Hi');\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * encoder.encode(none());\n * encoder.encode(null);\n * // 0x00\n * //   -- 1-byte prefix (None).\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Returns a decoder for optional values using the {@link Option} type.\n *\n * This decoder deserializes an `Option<T>` value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `None` values are identified by zeroes.\n * - If `noneValue` is a byte array, `None` values match the provided constant.\n *\n * Unlike {@link getNullableDecoder}, this decoder always outputs an {@link Option} type.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding option values.\n *\n * @example\n * Decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const decoder = getOptionDecoder(stringCodec);\n *\n * decoder.decode(new Uint8Array([0x01, 0x02, 0x00, 0x00, 0x00, 0x48, 0x69]));\n * // some('Hi')\n *\n * decoder.decode(new Uint8Array([0x00]));\n * // none()\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values using the {@link Option} type.\n *\n * This codec serializes and deserializes `Option<T>` values using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n * - If `noneValue: 'zeroes'` is set, `None` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `None` values are represented by the provided constant.\n * - If `prefix: null` is set, the codec determines `None` values solely from `noneValue` or the presence of bytes.\n *\n * For more details on the configuration options, see {@link OptionCodecConfig}.\n *\n * Note that this behaves similarly to {@link getNullableCodec}, except it\n * encodes {@link OptionOrNullable} values and decodes {@link Option} values.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding option values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding option values.\n *\n * @example\n * Encoding and decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode(some('Hi'));\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * const noneBytes = codec.encode(none());\n * // 0x00\n * //   -- 1-byte prefix (None).\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding nullable values.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode('Hi'); // 0x01020000004869\n * const noneBytes = codec.encode(null); // 0x00\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding an optional number with a fixed size.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { noneValue: 'zeroes' });\n *\n * const someBytes = codec.encode(some(42)); // 0x012a00\n * const noneBytes = codec.encode(none());   // 0x000000\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding {@link None} values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // 0xffff\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Identifying {@link None} values by the absence of bytes.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { prefix: null });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // new Uint8Array(0)\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @remarks\n * Separate {@link getOptionEncoder} and {@link getOptionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\n * const value = getOptionDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Defines types that should not be recursively unwrapped.\n *\n * These types are preserved as-is when using {@link unwrapOptionRecursively}.\n *\n * @see {@link unwrapOptionRecursively}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that recursively unwraps nested {@link Option} types.\n *\n * This type resolves all nested {@link Option} values, ensuring\n * that deeply wrapped values are properly extracted.\n *\n * - If `T` is an {@link Option}, it resolves to the contained value.\n * - If `T` is a known primitive or immutable type, it remains unchanged.\n * - If `T` is an object or array, it recursively unwraps any options found.\n *\n * The fallback type `U` (default: `null`) is used in place of `None` values.\n *\n * @typeParam T - The type to be unwrapped.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @example\n * Resolving nested `Option` types.\n * ```ts\n * UnwrappedOption<Some<Some<string>>>; // string\n * UnwrappedOption<None>;               // null\n * ```\n *\n * @example\n * Resolving options inside objects and arrays.\n * ```ts\n * UnwrappedOption<{ a: Some<number>; b: None }>; // { a: number; b: null }\n * UnwrappedOption<[Some<number>, None]>;         // [number, null]\n * ```\n *\n * @see {@link unwrapOptionRecursively}\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively unwraps all nested {@link Option} types within a value.\n *\n * This function traverses a given value and removes all instances\n * of {@link Option}, replacing them with their contained values.\n *\n * - If an {@link Option} is encountered, its value is extracted.\n * - If an array or object is encountered, its elements are traversed recursively.\n * - If `None` is encountered, it is replaced with the fallback value (default: `null`).\n *\n * @typeParam T - The type of the input value.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @param input - The value to unwrap.\n * @param fallback - A function that provides a fallback value for `None` options.\n * @returns The recursively unwrapped value.\n *\n * @example\n * Recursively unwrapping nested options.\n * ```ts\n * unwrapOptionRecursively(some(some('Hello World'))); // \"Hello World\"\n * unwrapOptionRecursively(some(none<string>()));      // null\n * ```\n *\n * @example\n * Recursively unwrapping options inside objects and arrays.\n * ```ts\n * unwrapOptionRecursively({\n *   a: 'hello',\n *   b: none(),\n *   c: [{ c1: some(42) }, { c2: none() }],\n * });\n * // { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n * ```\n *\n * @example\n * Using a fallback value for `None` options.\n * ```ts\n * unwrapOptionRecursively(\n *   {\n *     a: 'hello',\n *     b: none(),\n *     c: [{ c1: some(42) }, { c2: none() }],\n *   },\n *   () => 'Default',\n * );\n * // { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n * ```\n *\n * @remarks\n * This function does not mutate objects or arrays.\n *\n * @see {@link Option}\n * @see {@link UnwrappedOption}\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9740, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/promises/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/promises/src/race.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/promises/src/abortable.ts"],"sourcesContent":["/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\n/**\n * An implementation of [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\n * that causes all of the losing promises to settle. This allows them to be released and garbage\n * collected, preventing memory leaks.\n *\n * Read more here: https://github.com/nodejs/node/issues/17469\n */\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n","import { safeRace } from './race';\n\n/**\n * Returns a new promise that will reject if the abort signal fires before the original promise\n * settles. Resolves or rejects with the value of the original promise otherwise.\n *\n * @example\n * ```ts\n * const result = await getAbortablePromise(\n *     // Resolves or rejects when `fetch` settles.\n *     fetch('https://example.com/json').then(r => r.json()),\n *     // ...unless it takes longer than 5 seconds, after which the `AbortSignal` is triggered.\n *     AbortSignal.timeout(5000),\n * );\n * ```\n */\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9834, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/instruction-plans/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instruction-plans/src/instruction-plan.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instruction-plans/src/append-instruction-plan.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instruction-plans/src/transaction-plan.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instruction-plans/src/transaction-plan-result.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instruction-plans/src/transaction-plan-executor.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/instruction-plans/src/transaction-planner.ts"],"sourcesContent":["import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\n/**\n * A set of instructions with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans in order to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely the following plans are supported:\n * - {@link SingleInstructionPlan} - A plan that contains a single instruction.\n *   This is a simple instruction wrapper and the simplest leaf in this tree.\n * - {@link ParallelInstructionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialInstructionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that instructions inside it can be split into separate transactions.\n * - {@link MessagePackerInstructionPlan} - A plan that can dynamically pack\n *  instructions into transaction messages.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myInstructionPlan: InstructionPlan = parallelInstructionPlan([\n *    sequentialInstructionPlan([instructionA, instructionB]),\n *    instructionC,\n *    instructionD,\n * ]);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link ParallelInstructionPlan}\n * @see {@link SequentialInstructionPlan}\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type InstructionPlan =\n    | MessagePackerInstructionPlan\n    | ParallelInstructionPlan\n    | SequentialInstructionPlan\n    | SingleInstructionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible  meaning that\n * the instructions inside them can be split into separate transactions.\n * When `divisible` is `false`, the instructions inside the plan should\n * all be executed atomically  either in a single transaction or in a\n * transaction bundle.\n *\n * You may use the {@link sequentialInstructionPlan} and {@link nonDivisibleSequentialInstructionPlan}\n * helpers to create objects of this type.\n *\n * @example Simple sequential plan with two instructions.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan;\n * ```\n *\n * @example Non-divisible sequential plan with two instructions.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @example Sequential plan with nested parallel plans.\n * Here, instructions A and B can be executed in parallel, but they must both be finalized\n * before instructions C and D can be sent  which can also be executed in parallel.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   parallelInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @see {@link sequentialInstructionPlan}\n * @see {@link nonDivisibleSequentialInstructionPlan}\n */\nexport type SequentialInstructionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without consequence.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree  such as the {@link SequentialInstructionPlan}.\n *\n * You may use the {@link parallelInstructionPlan} helper to create objects of this type.\n *\n * @example Simple parallel plan with two instructions.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @example Parallel plan with nested sequential plans.\n * Here, instructions A and B must be executed sequentially and so must instructions C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @see {@link parallelInstructionPlan}\n */\nexport type ParallelInstructionPlan = Readonly<{\n    kind: 'parallel';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan that contains a single instruction.\n *\n * This is a simple instruction wrapper that transforms an instruction into a plan.\n *\n * You may use the {@link singleInstructionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * plan satisfies SingleInstructionPlan;\n * ```\n *\n * @see {@link singleInstructionPlan}\n */\nexport type SingleInstructionPlan<TInstruction extends Instruction = Instruction> = Readonly<{\n    instruction: TInstruction;\n    kind: 'single';\n}>;\n\n/**\n * A plan that can dynamically pack instructions into transaction messages.\n *\n * This plan provides a {@link MessagePacker} via the `getMessagePacker`\n * method, which enables instructions to be dynamically packed into the\n * provided transaction message until there are no more instructions to pack.\n * The returned {@link MessagePacker} offers a `packMessageToCapacity(message)`\n * method that packs the provided message  when possible  and a `done()` method\n * that checks whether there are more instructions to pack.\n *\n * Several helper functions are provided to create objects of this type such as\n * {@link getLinearMessagePackerInstructionPlan} or {@link getMessagePackerInstructionPlanFromInstructions}.\n *\n * @example An message packer plan for a write instruction that uses as many bytes as possible.\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example A message packer plan for multiple realloc instructions.\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example Using a message packer plan.\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link getLinearMessagePackerInstructionPlan}\n * @see {@link getMessagePackerInstructionPlanFromInstructions}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport type MessagePackerInstructionPlan = Readonly<{\n    getMessagePacker: () => MessagePacker;\n    kind: 'messagePacker';\n}>;\n\n/**\n * The message packer returned by the {@link MessagePackerInstructionPlan}.\n *\n * It offers a `packMessageToCapacity(transactionMessage)` method that packs as many instructions\n * as possible into the provided transaction message, while still being able to fit into the\n * transaction size limit. It returns the updated transaction message with the packed instructions\n * or throws an error if the current transaction message cannot accommodate this plan.\n *\n * The `done()` method checks whether there are more instructions to pack into\n * transaction messages.\n *\n * @example\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type MessagePacker = Readonly<{\n    /** Checks whether the message packer has more instructions to pack into transaction messages. */\n    done: () => boolean;\n    /**\n     * Packs the provided transaction message with instructions or throws if not possible.\n     *\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN}\n     *   if the provided transaction message cannot be used to fill the next instructions.\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE}\n     *   if the message packer is already done and no more instructions can be packed.\n     */\n    packMessageToCapacity: (\n        transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer;\n}>;\n\n/**\n * Creates a {@link ParallelInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n */\nexport function parallelInstructionPlan(plans: (Instruction | InstructionPlan)[]): ParallelInstructionPlan {\n    return Object.freeze({\n        kind: 'parallel',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function sequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: true } {\n    return Object.freeze({\n        divisible: true,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a non-divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function nonDivisibleSequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: false } {\n    return Object.freeze({\n        divisible: false,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a {@link SingleInstructionPlan} from an {@link Instruction} object.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n */\nexport function singleInstructionPlan(instruction: Instruction): SingleInstructionPlan {\n    return Object.freeze({ instruction, kind: 'single' });\n}\n\nfunction parseSingleInstructionPlans(plans: (Instruction | InstructionPlan)[]): InstructionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleInstructionPlan(plan)));\n}\n\n/**\n * Checks if the given instruction plan is a {@link SingleInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a single instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = singleInstructionPlan(myInstruction);\n *\n * if (isSingleInstructionPlan(plan)) {\n *   console.log(plan.instruction); // TypeScript knows this is a SingleInstructionPlan.\n * }\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link assertIsSingleInstructionPlan}\n */\nexport function isSingleInstructionPlan(plan: InstructionPlan): plan is SingleInstructionPlan {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link SingleInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a single instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = singleInstructionPlan(myInstruction);\n *\n * assertIsSingleInstructionPlan(plan);\n * console.log(plan.instruction); // TypeScript knows this is a SingleInstructionPlan.\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link isSingleInstructionPlan}\n */\nexport function assertIsSingleInstructionPlan(plan: InstructionPlan): asserts plan is SingleInstructionPlan {\n    if (!isSingleInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link MessagePackerInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a message packer instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = getLinearMessagePackerInstructionPlan({ /* ... *\\/ });\n *\n * if (isMessagePackerInstructionPlan(plan)) {\n *   const packer = plan.getMessagePacker(); // TypeScript knows this is a MessagePackerInstructionPlan.\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link assertIsMessagePackerInstructionPlan}\n */\nexport function isMessagePackerInstructionPlan(plan: InstructionPlan): plan is MessagePackerInstructionPlan {\n    return plan.kind === 'messagePacker';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link MessagePackerInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a message packer instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = getLinearMessagePackerInstructionPlan({ /* ... *\\/ });\n *\n * assertIsMessagePackerInstructionPlan(plan);\n * const packer = plan.getMessagePacker(); // TypeScript knows this is a MessagePackerInstructionPlan.\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link isMessagePackerInstructionPlan}\n */\nexport function assertIsMessagePackerInstructionPlan(\n    plan: InstructionPlan,\n): asserts plan is MessagePackerInstructionPlan {\n    if (!isMessagePackerInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'messagePacker',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link SequentialInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a sequential instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * if (isSequentialInstructionPlan(plan)) {\n *   console.log(plan.divisible); // TypeScript knows this is a SequentialInstructionPlan.\n * }\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link assertIsSequentialInstructionPlan}\n */\nexport function isSequentialInstructionPlan(plan: InstructionPlan): plan is SequentialInstructionPlan {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link SequentialInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a sequential instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * assertIsSequentialInstructionPlan(plan);\n * console.log(plan.divisible); // TypeScript knows this is a SequentialInstructionPlan.\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link isSequentialInstructionPlan}\n */\nexport function assertIsSequentialInstructionPlan(plan: InstructionPlan): asserts plan is SequentialInstructionPlan {\n    if (!isSequentialInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a non-divisible {@link SequentialInstructionPlan}.\n *\n * A non-divisible sequential plan requires all its instructions to be executed\n * atomically  either in a single transaction or in a transaction bundle.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a non-divisible sequential instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n *\n * if (isNonDivisibleSequentialInstructionPlan(plan)) {\n *   // All instructions must be executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link assertIsNonDivisibleSequentialInstructionPlan}\n */\nexport function isNonDivisibleSequentialInstructionPlan(\n    plan: InstructionPlan,\n): plan is SequentialInstructionPlan & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given instruction plan is a non-divisible {@link SequentialInstructionPlan}.\n *\n * A non-divisible sequential plan requires all its instructions to be executed\n * atomically  either in a single transaction or in a transaction bundle.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a non-divisible sequential instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n *\n * assertIsNonDivisibleSequentialInstructionPlan(plan);\n * // All instructions must be executed atomically.\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n * @see {@link isNonDivisibleSequentialInstructionPlan}\n */\nexport function assertIsNonDivisibleSequentialInstructionPlan(\n    plan: InstructionPlan,\n): asserts plan is SequentialInstructionPlan & { divisible: false } {\n    if (!isNonDivisibleSequentialInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given instruction plan is a {@link ParallelInstructionPlan}.\n *\n * @param plan - The instruction plan to check.\n * @return `true` if the plan is a parallel instruction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = parallelInstructionPlan([instructionA, instructionB]);\n *\n * if (isParallelInstructionPlan(plan)) {\n *   console.log(plan.plans.length); // TypeScript knows this is a ParallelInstructionPlan.\n * }\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n * @see {@link assertIsParallelInstructionPlan}\n */\nexport function isParallelInstructionPlan(plan: InstructionPlan): plan is ParallelInstructionPlan {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given instruction plan is a {@link ParallelInstructionPlan}.\n *\n * @param plan - The instruction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN` if the plan is not a parallel instruction plan.\n *\n * @example\n * ```ts\n * const plan: InstructionPlan = parallelInstructionPlan([instructionA, instructionB]);\n *\n * assertIsParallelInstructionPlan(plan);\n * console.log(plan.plans.length); // TypeScript knows this is a ParallelInstructionPlan.\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n * @see {@link isParallelInstructionPlan}\n */\nexport function assertIsParallelInstructionPlan(plan: InstructionPlan): asserts plan is ParallelInstructionPlan {\n    if (!isParallelInstructionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            instructionPlan: plan,\n        });\n    }\n}\n\n/**\n * Finds the first instruction plan in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the instruction plan tree,\n * returning the first plan that satisfies the predicate. It checks the root plan\n * first, then recursively searches through nested plans.\n *\n * @param instructionPlan - The instruction plan tree to search.\n * @param predicate - A function that returns `true` for the plan to find.\n * @returns The first matching instruction plan, or `undefined` if no match is found.\n *\n * @example\n * Finding a non-divisible sequential plan.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   nonDivisibleSequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n *\n * const nonDivisible = findInstructionPlan(\n *   plan,\n *   (p) => p.kind === 'sequential' && !p.divisible,\n * );\n * // Returns the non-divisible sequential plan containing instructionC and instructionD.\n * ```\n *\n * @example\n * Finding a specific single instruction plan.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB, instructionC]);\n *\n * const found = findInstructionPlan(\n *   plan,\n *   (p) => p.kind === 'single' && p.instruction === instructionB,\n * );\n * // Returns the SingleInstructionPlan wrapping instructionB.\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link transformInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function findInstructionPlan(\n    instructionPlan: InstructionPlan,\n    predicate: (plan: InstructionPlan) => boolean,\n): InstructionPlan | undefined {\n    if (predicate(instructionPlan)) {\n        return instructionPlan;\n    }\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return undefined;\n    }\n    for (const subPlan of instructionPlan.plans) {\n        const foundPlan = findInstructionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Checks if every instruction plan in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the instruction plan tree,\n * returning `true` only if the predicate returns `true` for every plan in the tree\n * (including the root plan and all nested plans).\n *\n * @param instructionPlan - The instruction plan tree to check.\n * @param predicate - A function that returns `true` if the plan satisfies the condition.\n * @return `true` if every plan in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all plans are divisible.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n *\n * const allDivisible = everyInstructionPlan(\n *   plan,\n *   (p) => p.kind !== 'sequential' || p.divisible,\n * );\n * // Returns true because all sequential plans are divisible.\n * ```\n *\n * @example\n * Checking if all single instructions use a specific program.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB, instructionC]);\n *\n * const allUseSameProgram = everyInstructionPlan(\n *   plan,\n *   (p) => p.kind !== 'single' || p.instruction.programAddress === myProgramAddress,\n * );\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link transformInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function everyInstructionPlan(\n    instructionPlan: InstructionPlan,\n    predicate: (plan: InstructionPlan) => boolean,\n): boolean {\n    if (!predicate(instructionPlan)) {\n        return false;\n    }\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return true;\n    }\n    return instructionPlan.plans.every(p => everyInstructionPlan(p, predicate));\n}\n\n/**\n * Transforms an instruction plan tree using a bottom-up approach.\n *\n * This function recursively traverses the instruction plan tree, applying the\n * transformation function to each plan. The transformation is applied bottom-up,\n * meaning nested plans are transformed first, then the parent plans receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed plans are frozen using `Object.freeze` to ensure immutability.\n *\n * @param instructionPlan - The instruction plan tree to transform.\n * @param fn - A function that transforms each plan and returns a new plan.\n * @return A new transformed instruction plan tree.\n *\n * @example\n * Making all sequential plans non-divisible to ensure atomicity.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n *\n * const transformed = transformInstructionPlan(plan, (p) => {\n *   if (p.kind === 'sequential' && p.divisible) {\n *     return nonDivisibleSequentialInstructionPlan(p.plans);\n *   }\n *   return p;\n * });\n * ```\n *\n * @example\n * Filtering out debug instructions before production execution.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, debugInstruction, instructionB]);\n *\n * const transformed = transformInstructionPlan(plan, (p) => {\n *   if (p.kind === 'sequential' || p.kind === 'parallel') {\n *     return { ...p, plans: p.plans.filter((p) => !isDebugInstruction(p)) };\n *   }\n *   return p;\n * });\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function transformInstructionPlan(\n    instructionPlan: InstructionPlan,\n    fn: (plan: InstructionPlan) => InstructionPlan,\n): InstructionPlan {\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return Object.freeze(fn(instructionPlan));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...instructionPlan,\n                plans: instructionPlan.plans.map(p => transformInstructionPlan(p, fn)),\n            }),\n        ),\n    );\n}\n\n/**\n * Retrieves all individual {@link SingleInstructionPlan} and {@link MessagePackerInstructionPlan}\n * instances from an instruction plan tree.\n *\n * This function recursively traverses any nested structure of instruction plans and extracts\n * all the leaf plans they contain. It's useful when you need to access all the individual\n * instructions or message packers that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param instructionPlan - The instruction plan to extract leaf plans from\n * @returns An array of all single and message packer instruction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   nonDivisibleSequentialInstructionPlan([instructionC, instructionD]),\n *   instructionE,\n * ]);\n *\n * const leafPlans = flattenInstructionPlan(plan);\n * // Array of `SingleInstructionPlan` containing:\n * // instructionA, instructionB, instructionC, instructionD and instructionE.\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link findInstructionPlan}\n * @see {@link everyInstructionPlan}\n * @see {@link transformInstructionPlan}\n */\nexport function flattenInstructionPlan(\n    instructionPlan: InstructionPlan,\n): (MessagePackerInstructionPlan | SingleInstructionPlan)[] {\n    if (instructionPlan.kind === 'single' || instructionPlan.kind === 'messagePacker') {\n        return [instructionPlan];\n    }\n    return instructionPlan.plans.flatMap(flattenInstructionPlan);\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs instructions\n * such that each instruction consumes as many bytes as possible from the given\n * `totalLength` while still being able to fit into the given transaction messages.\n *\n * This is particularly useful for instructions that write data to accounts and must\n * span multiple transactions due to their size limit.\n *\n * This message packer will first call `getInstruction` with a length of zero to\n * determine the base size of the instruction before figuring out how many\n * additional bytes can be packed into the transaction message. That remaining space\n * will then be used to call `getInstruction` again with the appropriate length.\n *\n * @param getInstruction - A function that returns an instruction for a given offset and length.\n * @param totalLength - The total length of the data to write, in bytes.\n *\n * @example\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getLinearMessagePackerInstructionPlan({\n    getInstruction,\n    totalLength: totalBytes,\n}: {\n    getInstruction: (offset: number, length: number) => Instruction;\n    totalLength: number;\n}): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let offset = 0;\n            return Object.freeze({\n                done: () => offset >= totalBytes,\n                packMessageToCapacity: (message: TransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (offset >= totalBytes) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const messageSizeWithBaseInstruction = getTransactionMessageSize(\n                        appendTransactionMessageInstruction(getInstruction(offset, 0), message),\n                    );\n                    const freeSpace =\n                        TRANSACTION_SIZE_LIMIT -\n                        messageSizeWithBaseInstruction /* Includes the base instruction (length: 0). */ -\n                        1; /* Leeway for shortU16 numbers in transaction headers. */\n\n                    if (freeSpace <= 0) {\n                        const messageSize = getTransactionMessageSize(message);\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                            // (+1) We need to pack at least one byte of data otherwise\n                            // there is no point packing the base instruction alone.\n                            numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,\n                            // (-1) Leeway for shortU16 numbers in transaction headers.\n                            numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1,\n                        });\n                    }\n\n                    const length = Math.min(totalBytes - offset, freeSpace);\n                    const instruction = getInstruction(offset, length);\n                    offset += length;\n                    return appendTransactionMessageInstruction(instruction, message);\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} from a list of instructions.\n *\n * This can be useful to prepare a set of instructions that can be iterated over\n *  e.g. to pack a list of instructions that gradually reallocate the size of an account\n * one `REALLOC_LIMIT` (10'240 bytes) at a time.\n *\n * @example\n * ```ts\n * const plan = getMessagePackerInstructionPlanFromInstructions([\n *   instructionA,\n *   instructionB,\n *   instructionC,\n * ]);\n *\n * const messagePacker = plan.getMessagePacker();\n * firstTransactionMessage = messagePacker.packMessageToCapacity(firstTransactionMessage);\n * // Contains instruction A and instruction B.\n * secondTransactionMessage = messagePacker.packMessageToCapacity(secondTransactionMessage);\n * // Contains instruction C.\n * messagePacker.done(); // true\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport function getMessagePackerInstructionPlanFromInstructions<TInstruction extends Instruction = Instruction>(\n    instructions: TInstruction[],\n): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let instructionIndex = 0;\n            return Object.freeze({\n                done: () => instructionIndex >= instructions.length,\n                packMessageToCapacity: (message: TransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (instructionIndex >= instructions.length) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const originalMessageSize = getTransactionMessageSize(message);\n\n                    for (let index = instructionIndex; index < instructions.length; index++) {\n                        message = appendTransactionMessageInstruction(instructions[index], message);\n                        const messageSize = getTransactionMessageSize(message);\n\n                        if (messageSize > TRANSACTION_SIZE_LIMIT) {\n                            if (index === instructionIndex) {\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n                                    {\n                                        numBytesRequired: messageSize - originalMessageSize,\n                                        numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize,\n                                    },\n                                );\n                            }\n                            instructionIndex = index;\n                            return message;\n                        }\n                    }\n\n                    instructionIndex = instructions.length;\n                    return message;\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\nconst REALLOC_LIMIT = 10_240;\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs a list of realloc instructions.\n *\n * That is, it splits instruction by chunks of `REALLOC_LIMIT` (10'240) bytes until\n * the given total size is reached.\n *\n * @example\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getReallocMessagePackerInstructionPlan({\n    getInstruction,\n    totalSize,\n}: {\n    getInstruction: (size: number) => Instruction;\n    totalSize: number;\n}): MessagePackerInstructionPlan {\n    const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);\n    const lastInstructionSize = totalSize % REALLOC_LIMIT;\n    const instructions = new Array(numberOfInstructions)\n        .fill(0)\n        .map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));\n\n    return getMessagePackerInstructionPlanFromInstructions(instructions);\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, SolanaError } from '@solana/errors';\nimport { type Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    appendTransactionMessageInstructions,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport { flattenInstructionPlan, InstructionPlan } from './instruction-plan';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\n\ntype AppendTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> = ReturnType<\n    typeof appendTransactionMessageInstructions<TTransactionMessage, Instruction[]>\n>;\n\n/**\n * Appends all instructions from an instruction plan to a transaction message.\n *\n * This function flattens the instruction plan into its leaf plans and sequentially\n * appends each instruction to the provided transaction message. It handles both\n * single instructions and message packer plans.\n *\n * Note that any {@link MessagePackerInstructionPlan} is assumed to only append\n * instructions. If it modifies other properties of the transaction message, the\n * type of the returned transaction message may not accurately reflect those changes.\n *\n * @typeParam TTransactionMessage - The type of transaction message being modified.\n *\n * @param transactionMessage - The transaction message to append instructions to.\n * @param instructionPlan - The instruction plan containing the instructions to append.\n * @returns The transaction message with all instructions from the plan appended.\n *\n * @example\n * Appending a simple instruction plan to a transaction message.\n * ```ts\n * import { appendTransactionMessageInstructionPlan } from '@solana/instruction-plans';\n * import { createTransactionMessage, setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const message = setTransactionMessageFeePayer(feePayer, createTransactionMessage({ version: 0 }));\n * const plan = singleInstructionPlan(myInstruction);\n *\n * const messageWithInstructions = appendTransactionMessageInstructionPlan(message, plan);\n * ```\n *\n * @example\n * Appending a sequential instruction plan.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB, instructionC]);\n * const messageWithInstructions = appendTransactionMessageInstructionPlan(message, plan);\n * ```\n *\n * @see {@link InstructionPlan}\n * @see {@link flattenInstructionPlan}\n */\nexport function appendTransactionMessageInstructionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer,\n>(\n    instructionPlan: InstructionPlan,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage> {\n    type Out = AppendTransactionMessageInstructions<TTransactionMessage>;\n\n    const leafInstructionPlans = flattenInstructionPlan(instructionPlan);\n\n    return leafInstructionPlans.reduce(\n        (messageSoFar, plan) => {\n            const kind = plan.kind;\n            if (kind === 'single') {\n                return appendTransactionMessageInstruction(plan.instruction, messageSoFar) as unknown as Out;\n            }\n            if (kind === 'messagePacker') {\n                const messagerPacker = plan.getMessagePacker();\n                let nextMessage: Out = messageSoFar;\n                while (!messagerPacker.done()) {\n                    nextMessage = messagerPacker.packMessageToCapacity(nextMessage) as Out;\n                }\n                return nextMessage;\n            }\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, {\n                kind,\n            });\n        },\n        transactionMessage as unknown as Out,\n    );\n}\n","import { SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, SolanaError } from '@solana/errors';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\n/**\n * A set of transaction messages with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely, the following plans are supported:\n * - {@link SingleTransactionPlan} - A plan that contains a single transaction message.\n *   This is the simplest leaf in this tree.\n * - {@link ParallelTransactionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialTransactionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that transaction messages inside it can be split into separate batches.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myTransactionPlan: TransactionPlan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   messageC,\n * ]);\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link ParallelTransactionPlan}\n * @see {@link SequentialTransactionPlan}\n */\nexport type TransactionPlan = ParallelTransactionPlan | SequentialTransactionPlan | SingleTransactionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible  meaning that\n * the transaction messages inside them can be split into separate batches.\n * When `divisible` is `false`, the transaction messages inside the plan should\n * all be executed atomically  usually in a transaction bundle.\n *\n * You may use the {@link sequentialTransactionPlan} and {@link nonDivisibleSequentialTransactionPlan}\n * helpers to create objects of this type.\n *\n * @example\n * Simple sequential plan with two transaction messages.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan;\n * ```\n *\n * @example\n * Non-divisible sequential plan with two transaction messages.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan & { divisible: false };\n * ```\n *\n * @example\n * Sequential plan with nested parallel plans.\n * Here, messages A and B can be executed in parallel, but they must both be finalized\n * before messages C and D can be sent  which can also be executed in parallel.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   parallelTransactionPlan([messageC, messageD]),\n * ]);\n * ```\n *\n * @see {@link sequentialTransactionPlan}\n * @see {@link nonDivisibleSequentialTransactionPlan}\n */\nexport type SequentialTransactionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without causing any side effects.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree  such as the {@link SequentialTransactionPlan}.\n *\n * You may use the {@link parallelTransactionPlan} helper to create objects of this type.\n *\n * @example\n * Simple parallel plan with two transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @example\n * Parallel plan with nested sequential plans.\n * Here, messages A and B must be executed sequentially and so must messages C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @see {@link parallelTransactionPlan}\n */\nexport type ParallelTransactionPlan = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan that contains a single transaction message.\n *\n * This is a simple transaction message wrapper that transforms a message into a plan.\n *\n * You may use the {@link singleTransactionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link singleTransactionPlan}\n */\nexport type SingleTransactionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n}>;\n\n/**\n * Creates a {@link ParallelTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n */\nexport function parallelTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): ParallelTransactionPlan {\n    return Object.freeze({ kind: 'parallel', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function sequentialTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function nonDivisibleSequentialTransactionPlan(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a {@link SingleTransactionPlan} from a {@link TransactionMessage} object.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link SingleTransactionPlan}\n */\nexport function singleTransactionPlan<\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlan<TTransactionMessage> {\n    return Object.freeze({ kind: 'single', message: transactionMessage });\n}\n\nfunction parseSingleTransactionPlans(\n    plans: (TransactionPlan | (TransactionMessage & TransactionMessageWithFeePayer))[],\n): TransactionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleTransactionPlan(plan)));\n}\n\n/**\n * Checks if the given transaction plan is a {@link SingleTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a single transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = singleTransactionPlan(transactionMessage);\n *\n * if (isSingleTransactionPlan(plan)) {\n *   console.log(plan.message); // TypeScript knows this is a SingleTransactionPlan.\n * }\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link assertIsSingleTransactionPlan}\n */\nexport function isSingleTransactionPlan(plan: TransactionPlan): plan is SingleTransactionPlan {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link SingleTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a single transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = singleTransactionPlan(transactionMessage);\n *\n * assertIsSingleTransactionPlan(plan);\n * console.log(plan.message); // TypeScript knows this is a SingleTransactionPlan.\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link isSingleTransactionPlan}\n */\nexport function assertIsSingleTransactionPlan(plan: TransactionPlan): asserts plan is SingleTransactionPlan {\n    if (!isSingleTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a {@link SequentialTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a sequential transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = sequentialTransactionPlan([messageA, messageB]);\n *\n * if (isSequentialTransactionPlan(plan)) {\n *   console.log(plan.divisible); // TypeScript knows this is a SequentialTransactionPlan.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link assertIsSequentialTransactionPlan}\n */\nexport function isSequentialTransactionPlan(plan: TransactionPlan): plan is SequentialTransactionPlan {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link SequentialTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a sequential transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = sequentialTransactionPlan([messageA, messageB]);\n *\n * assertIsSequentialTransactionPlan(plan);\n * console.log(plan.divisible); // TypeScript knows this is a SequentialTransactionPlan.\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link isSequentialTransactionPlan}\n */\nexport function assertIsSequentialTransactionPlan(plan: TransactionPlan): asserts plan is SequentialTransactionPlan {\n    if (!isSequentialTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a non-divisible {@link SequentialTransactionPlan}.\n *\n * A non-divisible sequential plan requires all its transaction messages to be executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a non-divisible sequential transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n *\n * if (isNonDivisibleSequentialTransactionPlan(plan)) {\n *   // All transaction messages must be executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link assertIsNonDivisibleSequentialTransactionPlan}\n */\nexport function isNonDivisibleSequentialTransactionPlan(\n    plan: TransactionPlan,\n): plan is SequentialTransactionPlan & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given transaction plan is a non-divisible {@link SequentialTransactionPlan}.\n *\n * A non-divisible sequential plan requires all its transaction messages to be executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a non-divisible sequential transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n *\n * assertIsNonDivisibleSequentialTransactionPlan(plan);\n * // All transaction messages must be executed atomically.\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n * @see {@link isNonDivisibleSequentialTransactionPlan}\n */\nexport function assertIsNonDivisibleSequentialTransactionPlan(\n    plan: TransactionPlan,\n): asserts plan is SequentialTransactionPlan & { divisible: false } {\n    if (!isNonDivisibleSequentialTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan is a {@link ParallelTransactionPlan}.\n *\n * @param plan - The transaction plan to check.\n * @return `true` if the plan is a parallel transaction plan, `false` otherwise.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = parallelTransactionPlan([messageA, messageB]);\n *\n * if (isParallelTransactionPlan(plan)) {\n *   console.log(plan.plans.length); // TypeScript knows this is a ParallelTransactionPlan.\n * }\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n * @see {@link assertIsParallelTransactionPlan}\n */\nexport function isParallelTransactionPlan(plan: TransactionPlan): plan is ParallelTransactionPlan {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given transaction plan is a {@link ParallelTransactionPlan}.\n *\n * @param plan - The transaction plan to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN` if the plan is not a parallel transaction plan.\n *\n * @example\n * ```ts\n * const plan: TransactionPlan = parallelTransactionPlan([messageA, messageB]);\n *\n * assertIsParallelTransactionPlan(plan);\n * console.log(plan.plans.length); // TypeScript knows this is a ParallelTransactionPlan.\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n * @see {@link isParallelTransactionPlan}\n */\nexport function assertIsParallelTransactionPlan(plan: TransactionPlan): asserts plan is ParallelTransactionPlan {\n    if (!isParallelTransactionPlan(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            transactionPlan: plan,\n        });\n    }\n}\n\n/**\n * @deprecated Use {@link flattenTransactionPlan} instead.\n */\nexport const getAllSingleTransactionPlans = flattenTransactionPlan;\n\n/**\n * Retrieves all individual {@link SingleTransactionPlan} instances from a transaction plan tree.\n *\n * This function recursively traverses any nested structure of transaction plans and extracts\n * all the single transaction plans they contain. It's useful when you need to access all\n * the actual transaction messages that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param transactionPlan - The transaction plan to extract single plans from\n * @returns An array of all single transaction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n *   messageE,\n * ]);\n *\n * const singlePlans = flattenTransactionPlan(plan);\n * // Array of `SingleTransactionPlan` containing:\n * // messageA, messageB, messageC and messageD.\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link transformTransactionPlan}\n * ```\n */\nexport function flattenTransactionPlan(transactionPlan: TransactionPlan): SingleTransactionPlan[] {\n    if (transactionPlan.kind === 'single') {\n        return [transactionPlan];\n    }\n    return transactionPlan.plans.flatMap(flattenTransactionPlan);\n}\n\n/**\n * Finds the first transaction plan in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the transaction plan tree,\n * returning the first plan that satisfies the predicate. It checks the root plan\n * first, then recursively searches through nested plans.\n *\n * @param transactionPlan - The transaction plan tree to search.\n * @param predicate - A function that returns `true` for the plan to find.\n * @return The first matching transaction plan, or `undefined` if no match is found.\n *\n * @example\n * Finding a non-divisible sequential plan.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n * ]);\n *\n * const nonDivisible = findTransactionPlan(\n *   plan,\n *   (p) => p.kind === 'sequential' && !p.divisible,\n * );\n * // Returns the non-divisible sequential plan containing messageC and messageD.\n * ```\n *\n * @example\n * Finding a specific single transaction plan.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB, messageC]);\n *\n * const found = findTransactionPlan(\n *   plan,\n *   (p) => p.kind === 'single' && p.message === messageB,\n * );\n * // Returns the SingleTransactionPlan wrapping messageB.\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link transformTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function findTransactionPlan(\n    transactionPlan: TransactionPlan,\n    predicate: (plan: TransactionPlan) => boolean,\n): TransactionPlan | undefined {\n    if (predicate(transactionPlan)) {\n        return transactionPlan;\n    }\n    if (transactionPlan.kind === 'single') {\n        return undefined;\n    }\n    for (const subPlan of transactionPlan.plans) {\n        const foundPlan = findTransactionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Checks if every transaction plan in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the transaction plan tree,\n * returning `true` only if the predicate returns `true` for every plan in the tree\n * (including the root plan and all nested plans).\n *\n * @param transactionPlan - The transaction plan tree to check.\n * @param predicate - A function that returns `true` if the plan satisfies the condition.\n * @return `true` if every plan in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all plans are divisible.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n *\n * const allDivisible = everyTransactionPlan(\n *   plan,\n *   (p) => p.kind !== 'sequential' || p.divisible,\n * );\n * // Returns true because all sequential plans are divisible.\n * ```\n *\n * @example\n * Checking if all single plans have a specific fee payer.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB, messageC]);\n *\n * const allUseSameFeePayer = everyTransactionPlan(\n *   plan,\n *   (p) => p.kind !== 'single' || p.message.feePayer.address === myFeePayer,\n * );\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link transformTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function everyTransactionPlan(\n    transactionPlan: TransactionPlan,\n    predicate: (plan: TransactionPlan) => boolean,\n): boolean {\n    if (!predicate(transactionPlan)) {\n        return false;\n    }\n    if (transactionPlan.kind === 'single') {\n        return true;\n    }\n    return transactionPlan.plans.every(p => everyTransactionPlan(p, predicate));\n}\n\n/**\n * Transforms a transaction plan tree using a bottom-up approach.\n *\n * This function recursively traverses the transaction plan tree, applying the\n * transformation function to each plan. The transformation is applied bottom-up,\n * meaning nested plans are transformed first, then the parent plans receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed plans are frozen using `Object.freeze` to ensure immutability.\n *\n * @param transactionPlan - The transaction plan tree to transform.\n * @param fn - A function that transforms each plan and returns a new plan.\n * @return A new transformed transaction plan tree.\n *\n * @example\n * Removing parallelism by converting parallel plans to sequential.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB, messageC]);\n *\n * const transformed = transformTransactionPlan(plan, (p) => {\n *   if (p.kind === 'parallel') {\n *     return sequentialTransactionPlan(p.plans);\n *   }\n *   return p;\n * });\n * ```\n *\n * @example\n * Updating the fee payer on all transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n *\n * const transformed = transformTransactionPlan(plan, (p) => {\n *   if (p.kind === 'single') {\n *     return singleTransactionPlan({ ...p.message, feePayer: newFeePayer });\n *   }\n *   return p;\n * });\n * ```\n *\n * @see {@link TransactionPlan}\n * @see {@link findTransactionPlan}\n * @see {@link everyTransactionPlan}\n * @see {@link flattenTransactionPlan}\n */\nexport function transformTransactionPlan(\n    transactionPlan: TransactionPlan,\n    fn: (plan: TransactionPlan) => TransactionPlan,\n): TransactionPlan {\n    if (transactionPlan.kind === 'single') {\n        return Object.freeze(fn(transactionPlan));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...transactionPlan,\n                plans: transactionPlan.plans.map(p => transformTransactionPlan(p, fn)),\n            }),\n        ),\n    );\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND,\n    SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { getSignatureFromTransaction, Transaction } from '@solana/transactions';\n\n/**\n * The result of executing a transaction plan.\n *\n * This is structured as a recursive tree of results that mirrors the structure\n * of the original transaction plan, capturing the execution status at each level.\n *\n * Namely, the following result types are supported:\n * - {@link SingleTransactionPlanResult} - A result for a single transaction message\n *   containing its execution status.\n * - {@link ParallelTransactionPlanResult} - A result containing other results that\n *   were executed in parallel.\n * - {@link SequentialTransactionPlanResult} - A result containing other results that\n *   were executed sequentially. It also retains the divisibility property from the\n *   original plan.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link TransactionPlanResultStatus}\n */\nexport type TransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = ParallelTransactionPlanResult<TContext, TSingle> | SequentialTransactionPlanResult<TContext, TSingle> | TSingle;\n\n/**\n * A {@link TransactionPlanResult} where all single transaction results are successful.\n *\n * This type represents a transaction plan result tree where every\n * {@link SingleTransactionPlanResult} has a 'successful' status. It can be used\n * to ensure that an entire execution completed without any failures or cancellations.\n *\n * Note: This is different from {@link SuccessfulSingleTransactionPlanResult} which\n * represents a single successful transaction, whereas this type represents an entire\n * plan result tree (which may contain parallel/sequential structures) where all\n * leaf nodes are successful.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @see {@link isSuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulTransactionPlanResult}\n * @see {@link SuccessfulSingleTransactionPlanResult}\n */\nexport type SuccessfulTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = TransactionPlanResult<TContext, SuccessfulSingleTransactionPlanResult<TContext>>;\n\n/** A context object that may be passed along with successful results. */\nexport type TransactionPlanResultContext = Record<number | string | symbol, unknown>;\n\n/**\n * A result for a sequential transaction plan.\n *\n * This represents the execution result of a {@link SequentialTransactionPlan} and\n * contains child results that were executed sequentially. It also retains the\n * divisibility property from the original plan.\n *\n * You may use the {@link sequentialTransactionPlanResult} and\n * {@link nonDivisibleSequentialTransactionPlanResult} helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult;\n * ```\n *\n * @example\n * Non-divisible sequential result.\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link sequentialTransactionPlanResult}\n * @see {@link nonDivisibleSequentialTransactionPlanResult}\n */\nexport type SequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlanResult<TContext, TSingle>[];\n}>;\n\n/**\n * A result for a parallel transaction plan.\n *\n * This represents the execution result of a {@link ParallelTransactionPlan} and\n * contains child results that were executed in parallel.\n *\n * You may use the {@link parallelTransactionPlanResult} helper to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TSingle - The type of single transaction plan results in this tree\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link parallelTransactionPlanResult}\n */\nexport type ParallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TSingle extends SingleTransactionPlanResult<TContext> = SingleTransactionPlanResult<TContext>,\n> = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlanResult<TContext, TSingle>[];\n}>;\n\n/**\n * A result for a single transaction plan.\n *\n * This represents the execution result of a {@link SingleTransactionPlan} and\n * contains the original transaction message along with its execution status.\n *\n * You may use the {@link successfulSingleTransactionPlanResult},\n * {@link failedSingleTransactionPlanResult}, or {@link canceledSingleTransactionPlanResult}\n * helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TTransactionMessage - The type of the transaction message\n *\n * @example\n * Successful result with a transaction and context.\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Failed result with an error.\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Canceled result.\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link successfulSingleTransactionPlanResult}\n * @see {@link failedSingleTransactionPlanResult}\n * @see {@link canceledSingleTransactionPlanResult}\n */\nexport type SingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n    status: TransactionPlanResultStatus<TContext>;\n}>;\n\n/**\n * The status of a single transaction plan execution.\n *\n * This represents the outcome of executing a single transaction message and can be one of:\n * - `successful` - The transaction was successfully executed. Contains the transaction\n *   and an optional context object.\n * - `failed` - The transaction execution failed. Contains the error that caused the failure.\n * - `canceled` - The transaction execution was canceled.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n */\nexport type TransactionPlanResultStatus<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | Readonly<{ context: TContext; kind: 'successful'; signature: Signature; transaction?: Transaction }>\n    | Readonly<{ error: Error; kind: 'failed' }>\n    | Readonly<{ kind: 'canceled' }>;\n\n/**\n * Creates a divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `true`,\n * indicating that the nested plans were executed sequentially but could have been\n * split into separate transactions or batches.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: true };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function sequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `false`,\n * indicating that the nested plans were executed sequentially and could not have been\n * split into separate transactions or batches (e.g., they were executed as a transaction bundle).\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function nonDivisibleSequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans });\n}\n\n/**\n * Creates a {@link ParallelTransactionPlanResult} from an array of nested results.\n *\n * This function creates a parallel result indicating that the nested plans\n * were executed in parallel.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed in parallel\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n */\nexport function parallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): ParallelTransactionPlanResult<TContext> {\n    return Object.freeze({ kind: 'parallel', plans });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and transaction.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param transaction - The successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    transaction: Transaction,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({\n            context: context ?? ({} as TContext),\n            kind: 'successful',\n            signature: getSignatureFromTransaction(transaction),\n            transaction,\n        }),\n    });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and signature.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the signature of the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param signature - The signature of the successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   signature\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResultFromSignature<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    signature: Signature,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ context: context ?? ({} as TContext), kind: 'successful', signature }),\n    });\n}\n\n/**\n * Creates a failed {@link SingleTransactionPlanResult} from a transaction message and error.\n *\n * This function creates a single result with a 'failed' status, indicating that\n * the transaction execution failed. It includes the original transaction message\n * and the error that caused the failure.\n *\n * @template TContext - The type of the context object (not used in failed results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param error - The error that caused the transaction to fail\n *\n * @example\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError({\n *     code: 123,\n *     message: 'Transaction simulation failed',\n *   }),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function failedSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage, error: Error): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ error, kind: 'failed' }),\n    });\n}\n\n/**\n * Creates a canceled {@link SingleTransactionPlanResult} from a transaction message.\n *\n * This function creates a single result with a 'canceled' status, indicating that\n * the transaction execution was canceled. It includes the original transaction message.\n *\n * @template TContext - The type of the context object (not used in canceled results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n *\n * @example\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function canceledSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends TransactionMessage & TransactionMessageWithFeePayer = TransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ kind: 'canceled' }),\n    });\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * if (isSingleTransactionPlanResult(result)) {\n *   console.log(result.status.kind); // TypeScript knows this is a SingleTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link assertIsSingleTransactionPlanResult}\n */\nexport function isSingleTransactionPlanResult(plan: TransactionPlanResult): plan is SingleTransactionPlanResult {\n    return plan.kind === 'single';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * assertIsSingleTransactionPlanResult(result);\n * console.log(result.status.kind); // TypeScript knows this is a SingleTransactionPlanResult.\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link isSingleTransactionPlanResult}\n */\nexport function assertIsSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SingleTransactionPlanResult {\n    if (!isSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a successful {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a successful single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * if (isSuccessfulSingleTransactionPlanResult(result)) {\n *   console.log(result.status.signature); // TypeScript knows this is a successful result.\n * }\n * ```\n *\n * @see {@link SuccessfulSingleTransactionPlanResult}\n * @see {@link assertIsSuccessfulSingleTransactionPlanResult}\n */\nexport function isSuccessfulSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SuccessfulSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'successful';\n}\n\n/**\n * Asserts that the given transaction plan result is a successful {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a successful single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = successfulSingleTransactionPlanResult(message, transaction);\n *\n * assertIsSuccessfulSingleTransactionPlanResult(result);\n * console.log(result.status.signature); // TypeScript knows this is a successful result.\n * ```\n *\n * @see {@link SuccessfulSingleTransactionPlanResult}\n * @see {@link isSuccessfulSingleTransactionPlanResult}\n */\nexport function assertIsSuccessfulSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SuccessfulSingleTransactionPlanResult {\n    if (!isSuccessfulSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'successful single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a failed {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a failed single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = failedSingleTransactionPlanResult(message, error);\n *\n * if (isFailedSingleTransactionPlanResult(result)) {\n *   console.log(result.status.error); // TypeScript knows this is a failed result.\n * }\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link assertIsFailedSingleTransactionPlanResult}\n */\nexport function isFailedSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is FailedSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'failed';\n}\n\n/**\n * Asserts that the given transaction plan result is a failed {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a failed single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = failedSingleTransactionPlanResult(message, error);\n *\n * assertIsFailedSingleTransactionPlanResult(result);\n * console.log(result.status.error); // TypeScript knows this is a failed result.\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link isFailedSingleTransactionPlanResult}\n */\nexport function assertIsFailedSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is FailedSingleTransactionPlanResult {\n    if (!isFailedSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'failed single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a canceled {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a canceled single transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = canceledSingleTransactionPlanResult(message);\n *\n * if (isCanceledSingleTransactionPlanResult(result)) {\n *   console.log('Transaction was canceled'); // TypeScript knows this is a canceled result.\n * }\n * ```\n *\n * @see {@link CanceledSingleTransactionPlanResult}\n * @see {@link assertIsCanceledSingleTransactionPlanResult}\n */\nexport function isCanceledSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is CanceledSingleTransactionPlanResult {\n    return plan.kind === 'single' && plan.status.kind === 'canceled';\n}\n\n/**\n * Asserts that the given transaction plan result is a canceled {@link SingleTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a canceled single transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = canceledSingleTransactionPlanResult(message);\n *\n * assertIsCanceledSingleTransactionPlanResult(result);\n * console.log('Transaction was canceled'); // TypeScript knows this is a canceled result.\n * ```\n *\n * @see {@link CanceledSingleTransactionPlanResult}\n * @see {@link isCanceledSingleTransactionPlanResult}\n */\nexport function assertIsCanceledSingleTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is CanceledSingleTransactionPlanResult {\n    if (!isCanceledSingleTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'single' ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: 'canceled single',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SequentialTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a sequential transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = sequentialTransactionPlanResult([resultA, resultB]);\n *\n * if (isSequentialTransactionPlanResult(result)) {\n *   console.log(result.divisible); // TypeScript knows this is a SequentialTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link assertIsSequentialTransactionPlanResult}\n */\nexport function isSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SequentialTransactionPlanResult {\n    return plan.kind === 'sequential';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SequentialTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a sequential transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = sequentialTransactionPlanResult([resultA, resultB]);\n *\n * assertIsSequentialTransactionPlanResult(result);\n * console.log(result.divisible); // TypeScript knows this is a SequentialTransactionPlanResult.\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link isSequentialTransactionPlanResult}\n */\nexport function assertIsSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SequentialTransactionPlanResult {\n    if (!isSequentialTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'sequential',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a non-divisible {@link SequentialTransactionPlanResult}.\n *\n * A non-divisible sequential result indicates that the transactions were executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a non-divisible sequential transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = nonDivisibleSequentialTransactionPlanResult([resultA, resultB]);\n *\n * if (isNonDivisibleSequentialTransactionPlanResult(result)) {\n *   // Transactions were executed atomically.\n * }\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link assertIsNonDivisibleSequentialTransactionPlanResult}\n */\nexport function isNonDivisibleSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SequentialTransactionPlanResult & { divisible: false } {\n    return plan.kind === 'sequential' && plan.divisible === false;\n}\n\n/**\n * Asserts that the given transaction plan result is a non-divisible {@link SequentialTransactionPlanResult}.\n *\n * A non-divisible sequential result indicates that the transactions were executed\n * atomically  usually in a transaction bundle.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a non-divisible sequential transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = nonDivisibleSequentialTransactionPlanResult([resultA, resultB]);\n *\n * assertIsNonDivisibleSequentialTransactionPlanResult(result);\n * // Transactions were executed atomically.\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link isNonDivisibleSequentialTransactionPlanResult}\n */\nexport function assertIsNonDivisibleSequentialTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SequentialTransactionPlanResult & { divisible: false } {\n    if (!isNonDivisibleSequentialTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === 'sequential' ? 'divisible sequential' : plan.kind,\n            expectedKind: 'non-divisible sequential',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link ParallelTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if the result is a parallel transaction plan result, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([resultA, resultB]);\n *\n * if (isParallelTransactionPlanResult(result)) {\n *   console.log(result.plans.length); // TypeScript knows this is a ParallelTransactionPlanResult.\n * }\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link assertIsParallelTransactionPlanResult}\n */\nexport function isParallelTransactionPlanResult(plan: TransactionPlanResult): plan is ParallelTransactionPlanResult {\n    return plan.kind === 'parallel';\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link ParallelTransactionPlanResult}.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT` if the result is not a parallel transaction plan result.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([resultA, resultB]);\n *\n * assertIsParallelTransactionPlanResult(result);\n * console.log(result.plans.length); // TypeScript knows this is a ParallelTransactionPlanResult.\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link isParallelTransactionPlanResult}\n */\nexport function assertIsParallelTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is ParallelTransactionPlanResult {\n    if (!isParallelTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: 'parallel',\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Checks if the given transaction plan result is a {@link SuccessfulTransactionPlanResult}.\n *\n * This function verifies that the entire transaction plan result tree contains only\n * successful single transaction results. It recursively checks all nested results\n * to ensure every {@link SingleTransactionPlanResult} has a 'successful' status.\n *\n * Note: This is different from {@link isSuccessfulSingleTransactionPlanResult} which\n * checks if a single result is successful. This function checks that the entire\n * plan result tree (including all nested parallel/sequential structures) contains\n * only successful transactions.\n *\n * @param plan - The transaction plan result to check.\n * @return `true` if all single transaction results in the tree are successful, `false` otherwise.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * if (isSuccessfulTransactionPlanResult(result)) {\n *   // All transactions were successful.\n *   result satisfies SuccessfulTransactionPlanResult;\n * }\n * ```\n *\n * @see {@link SuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulTransactionPlanResult}\n * @see {@link isSuccessfulSingleTransactionPlanResult}\n */\nexport function isSuccessfulTransactionPlanResult(\n    plan: TransactionPlanResult,\n): plan is SuccessfulTransactionPlanResult {\n    return everyTransactionPlanResult(\n        plan,\n        r => !isSingleTransactionPlanResult(r) || isSuccessfulSingleTransactionPlanResult(r),\n    );\n}\n\n/**\n * Asserts that the given transaction plan result is a {@link SuccessfulTransactionPlanResult}.\n *\n * This function verifies that the entire transaction plan result tree contains only\n * successful single transaction results. It throws if any {@link SingleTransactionPlanResult}\n * in the tree has a 'failed' or 'canceled' status.\n *\n * Note: This is different from {@link assertIsSuccessfulSingleTransactionPlanResult} which\n * asserts that a single result is successful. This function asserts that the entire\n * plan result tree (including all nested parallel/sequential structures) contains\n * only successful transactions.\n *\n * @param plan - The transaction plan result to assert.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT` if\n * any single transaction result in the tree is not successful.\n *\n * @example\n * ```ts\n * const result: TransactionPlanResult = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * assertIsSuccessfulTransactionPlanResult(result);\n * // All transactions were successful.\n * result satisfies SuccessfulTransactionPlanResult;\n * ```\n *\n * @see {@link SuccessfulTransactionPlanResult}\n * @see {@link isSuccessfulTransactionPlanResult}\n * @see {@link assertIsSuccessfulSingleTransactionPlanResult}\n */\nexport function assertIsSuccessfulTransactionPlanResult(\n    plan: TransactionPlanResult,\n): asserts plan is SuccessfulTransactionPlanResult {\n    if (!isSuccessfulTransactionPlanResult(plan)) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT, {\n            transactionPlanResult: plan,\n        });\n    }\n}\n\n/**\n * Finds the first transaction plan result in the tree that matches the given predicate.\n *\n * This function performs a depth-first search through the transaction plan result tree,\n * returning the first result that satisfies the predicate. It checks the root result\n * first, then recursively searches through nested results.\n *\n * @param transactionPlanResult - The transaction plan result tree to search.\n * @param predicate - A function that returns `true` for the result to find.\n * @returns The first matching transaction plan result, or `undefined` if no match is found.\n *\n * @example\n * Finding a failed transaction result.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   failedSingleTransactionPlanResult(messageB, error),\n * ]);\n *\n * const failed = findTransactionPlanResult(\n *   result,\n *   (r) => r.kind === 'single' && r.status.kind === 'failed',\n * );\n * // Returns the failed single transaction plan result for messageB.\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function findTransactionPlanResult<TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionPlanResult: TransactionPlanResult<TContext>,\n    predicate: (result: TransactionPlanResult<TContext>) => boolean,\n): TransactionPlanResult<TContext> | undefined {\n    if (predicate(transactionPlanResult)) {\n        return transactionPlanResult;\n    }\n    if (transactionPlanResult.kind === 'single') {\n        return undefined;\n    }\n    for (const subResult of transactionPlanResult.plans) {\n        const foundResult = findTransactionPlanResult(subResult, predicate);\n        if (foundResult) {\n            return foundResult;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Retrieves the first failed transaction plan result from a transaction plan result tree.\n *\n * This function searches the transaction plan result tree using a depth-first traversal\n * and returns the first single transaction result with a 'failed' status. If no failed\n * result is found, it throws a {@link SolanaError}.\n *\n * @param transactionPlanResult - The transaction plan result tree to search.\n * @return The first failed single transaction plan result.\n * @throws Throws a {@link SolanaError} with code\n * `SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND` if no\n * failed transaction plan result is found. The error context contains a non-enumerable\n * `transactionPlanResult` property for recovery purposes.\n *\n * @example\n * Retrieving the first failed result from a parallel execution.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   failedSingleTransactionPlanResult(messageB, error),\n *   failedSingleTransactionPlanResult(messageC, anotherError),\n * ]);\n *\n * const firstFailed = getFirstFailedSingleTransactionPlanResult(result);\n * // Returns the failed result for messageB.\n * ```\n *\n * @see {@link FailedSingleTransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n */\nexport function getFirstFailedSingleTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n): FailedSingleTransactionPlanResult {\n    const result = findTransactionPlanResult(\n        transactionPlanResult,\n        r => r.kind === 'single' && r.status.kind === 'failed',\n    );\n\n    if (!result) {\n        // Here we want the `transactionPlanResult` to be available in the error context\n        // so applications can recover but we don't want this object to be\n        // serialized with the error. This is why we set it as a non-enumerable property.\n        const context = {};\n        Object.defineProperty(context, 'transactionPlanResult', {\n            configurable: false,\n            enumerable: false,\n            value: transactionPlanResult,\n            writable: false,\n        });\n        throw new SolanaError(\n            SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND,\n            context,\n        );\n    }\n\n    return result as FailedSingleTransactionPlanResult;\n}\n\n/**\n * Checks if every transaction plan result in the tree satisfies the given predicate.\n *\n * This function performs a depth-first traversal through the transaction plan result tree,\n * returning `true` only if the predicate returns `true` for every result in the tree\n * (including the root result and all nested results).\n *\n * @param transactionPlanResult - The transaction plan result tree to check.\n * @param predicate - A function that returns `true` if the result satisfies the condition.\n * @return `true` if every result in the tree satisfies the predicate, `false` otherwise.\n *\n * @example\n * Checking if all transactions were successful.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   successfulSingleTransactionPlanResult(messageB, transactionB),\n * ]);\n *\n * const allSuccessful = everyTransactionPlanResult(\n *   result,\n *   (r) => r.kind !== 'single' || r.status.kind === 'successful',\n * );\n * // Returns true because all single results are successful.\n * ```\n *\n * @example\n * Checking if no transactions were canceled.\n * ```ts\n * const result = sequentialTransactionPlanResult([resultA, resultB, resultC]);\n *\n * const noCanceled = everyTransactionPlanResult(\n *   result,\n *   (r) => r.kind !== 'single' || r.status.kind !== 'canceled',\n * );\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function everyTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n    predicate: (plan: TransactionPlanResult) => boolean,\n): boolean {\n    if (!predicate(transactionPlanResult)) {\n        return false;\n    }\n    if (transactionPlanResult.kind === 'single') {\n        return true;\n    }\n    return transactionPlanResult.plans.every(p => everyTransactionPlanResult(p, predicate));\n}\n\n/**\n * Transforms a transaction plan result tree using a bottom-up approach.\n *\n * This function recursively traverses the transaction plan result tree, applying the\n * transformation function to each result. The transformation is applied bottom-up,\n * meaning nested results are transformed first, then the parent results receive\n * the already-transformed children before being transformed themselves.\n *\n * All transformed results are frozen using `Object.freeze` to ensure immutability.\n *\n * @param transactionPlanResult - The transaction plan result tree to transform.\n * @param fn - A function that transforms each result and returns a new result.\n * @return A new transformed transaction plan result tree.\n *\n * @example\n * Converting all canceled results to failed results.\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   successfulSingleTransactionPlanResult(messageA, transactionA),\n *   canceledSingleTransactionPlanResult(messageB),\n * ]);\n *\n * const transformed = transformTransactionPlanResult(result, (r) => {\n *   if (r.kind === 'single' && r.status.kind === 'canceled') {\n *     return failedSingleTransactionPlanResult(r.message, new Error('Execution canceled'));\n *   }\n *   return r;\n * });\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link flattenTransactionPlanResult}\n */\nexport function transformTransactionPlanResult(\n    transactionPlanResult: TransactionPlanResult,\n    fn: (plan: TransactionPlanResult) => TransactionPlanResult,\n): TransactionPlanResult {\n    if (transactionPlanResult.kind === 'single') {\n        return Object.freeze(fn(transactionPlanResult));\n    }\n    return Object.freeze(\n        fn(\n            Object.freeze({\n                ...transactionPlanResult,\n                plans: transactionPlanResult.plans.map(p => transformTransactionPlanResult(p, fn)),\n            }),\n        ),\n    );\n}\n\n/**\n * Retrieves all individual {@link SingleTransactionPlanResult} instances from a transaction plan result tree.\n *\n * This function recursively traverses any nested structure of transaction plan results and extracts\n * all the single results they contain. It's useful when you need to access all the individual\n * transaction results, regardless of their organization in the result tree (parallel or sequential).\n *\n * @param result - The transaction plan result to extract single results from\n * @returns An array of all single transaction plan results contained in the tree\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   sequentialTransactionPlanResult([resultA, resultB]),\n *   nonDivisibleSequentialTransactionPlanResult([resultC, resultD]),\n *   resultE,\n * ]);\n *\n * const singleResults = flattenTransactionPlanResult(result);\n * // Array of `SingleTransactionPlanResult` containing:\n * // resultA, resultB, resultC, resultD and resultE.\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link findTransactionPlanResult}\n * @see {@link everyTransactionPlanResult}\n * @see {@link transformTransactionPlanResult}\n */\nexport function flattenTransactionPlanResult(result: TransactionPlanResult): SingleTransactionPlanResult[] {\n    if (result.kind === 'single') {\n        return [result];\n    }\n    return result.plans.flatMap(flattenTransactionPlanResult);\n}\n\n/**\n * A {@link SingleTransactionPlanResult} with 'successful' status.\n */\nexport type SuccessfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = SingleTransactionPlanResult<TContext> & { status: { kind: 'successful' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'failed' status.\n */\nexport type FailedSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'failed' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'canceled' status.\n */\nexport type CanceledSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'canceled' } };\n\n/**\n * A summary of a {@link TransactionPlanResult}, categorizing transactions by their execution status.\n * - `successful`: Indicates whether all transactions were successful (i.e., no failed or canceled transactions).\n * - `successfulTransactions`: An array of successful transactions, each including its signature.\n * - `failedTransactions`: An array of failed transactions, each including the error that caused the failure.\n * - `canceledTransactions`: An array of canceled transactions.\n */\nexport type TransactionPlanResultSummary = Readonly<{\n    canceledTransactions: CanceledSingleTransactionPlanResult[];\n    failedTransactions: FailedSingleTransactionPlanResult[];\n    successful: boolean;\n    successfulTransactions: SuccessfulSingleTransactionPlanResult[];\n}>;\n\n/**\n * Summarize a {@link TransactionPlanResult} into a {@link TransactionPlanResultSummary}.\n * @param result The transaction plan result to summarize\n * @returns A summary of the transaction plan result\n */\nexport function summarizeTransactionPlanResult(result: TransactionPlanResult): TransactionPlanResultSummary {\n    const successfulTransactions: TransactionPlanResultSummary['successfulTransactions'] = [];\n    const failedTransactions: TransactionPlanResultSummary['failedTransactions'] = [];\n    const canceledTransactions: TransactionPlanResultSummary['canceledTransactions'] = [];\n\n    const flattenedResults = flattenTransactionPlanResult(result);\n\n    for (const singleResult of flattenedResults) {\n        switch (singleResult.status.kind) {\n            case 'successful': {\n                successfulTransactions.push(singleResult as SuccessfulSingleTransactionPlanResult);\n                break;\n            }\n            case 'failed': {\n                failedTransactions.push(singleResult as FailedSingleTransactionPlanResult);\n                break;\n            }\n            case 'canceled': {\n                canceledTransactions.push(singleResult as CanceledSingleTransactionPlanResult);\n                break;\n            }\n        }\n    }\n\n    return Object.freeze({\n        canceledTransactions,\n        failedTransactions,\n        successful: failedTransactions.length === 0 && canceledTransactions.length === 0,\n        successfulTransactions,\n    });\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport { getAbortablePromise } from '@solana/promises';\nimport { TransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\nimport type {\n    ParallelTransactionPlan,\n    SequentialTransactionPlan,\n    SingleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\nimport {\n    canceledSingleTransactionPlanResult,\n    failedSingleTransactionPlanResult,\n    parallelTransactionPlanResult,\n    sequentialTransactionPlanResult,\n    SingleTransactionPlanResult,\n    successfulSingleTransactionPlanResult,\n    successfulSingleTransactionPlanResultFromSignature,\n    type TransactionPlanResult,\n    type TransactionPlanResultContext,\n} from './transaction-plan-result';\n\n/**\n * Executes a transaction plan and returns the execution results.\n *\n * This function traverses the transaction plan tree, executing each transaction\n * message and collecting results that mirror the structure of the original plan.\n *\n * @typeParam TContext - The type of the context object that may be passed along with successful results.\n * @param transactionPlan - The transaction plan to execute.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel execution.\n * @return A promise that resolves to the execution results.\n *\n * @see {@link TransactionPlan}\n * @see {@link TransactionPlanResult}\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutor<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> = (\n    transactionPlan: TransactionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlanResult<TContext>>;\n\ntype ExecuteResult<TContext extends TransactionPlanResultContext> = {\n    context?: TContext;\n} & ({ signature: Signature } | { transaction: Transaction });\n\ntype ExecuteTransactionMessage = <TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<ExecuteResult<TContext>>;\n\n/**\n * Configuration object for creating a new transaction plan executor.\n *\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutorConfig = {\n    /** Called whenever a transaction message must be sent to the blockchain. */\n    executeTransactionMessage: ExecuteTransactionMessage;\n};\n\n/**\n * Creates a new transaction plan executor based on the provided configuration.\n *\n * The executor will traverse the provided `TransactionPlan` sequentially or in parallel,\n * executing each transaction message using the `executeTransactionMessage` function.\n *\n * - If that function is successful, the executor will return a successful `TransactionPlanResult`\n * for that message including the transaction and any custom context.\n * - If that function throws an error, the executor will stop processing and cancel all\n * remaining transaction messages in the plan.\n * - If the `abortSignal` is triggered, the executor will immediately stop processing the plan and\n * return a `TransactionPlanResult` with the status set to `canceled`.\n *\n * @param config - Configuration object containing the transaction message executor function.\n * @return A {@link TransactionPlanExecutor} function that can execute transaction plans.\n *\n * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN}\n *   if any transaction in the plan fails to execute. The error context contains a\n *   `transactionPlanResult` property with the partial results up to the point of failure.\n * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED}\n *   if the transaction plan contains non-divisible sequential plans, which are not\n *   supported by this executor.\n *\n * @example\n * ```ts\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * const transactionPlanExecutor = createTransactionPlanExecutor({\n *   executeTransactionMessage: async (message) => {\n *     const transaction = await signTransactionMessageWithSigners(message);\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n *     return { transaction };\n *   }\n * });\n * ```\n *\n * @see {@link TransactionPlanExecutorConfig}\n */\nexport function createTransactionPlanExecutor(config: TransactionPlanExecutorConfig): TransactionPlanExecutor {\n    return async (plan, { abortSignal } = {}): Promise<TransactionPlanResult> => {\n        const context: TraverseContext = {\n            ...config,\n            abortSignal: abortSignal,\n            canceled: abortSignal?.aborted ?? false,\n        };\n\n        // Fail early if there are non-divisible sequential plans in the\n        // transaction plan as they are not supported by this executor.\n        assertDivisibleSequentialPlansOnly(plan);\n\n        const cancelHandler = () => {\n            context.canceled = true;\n        };\n        abortSignal?.addEventListener('abort', cancelHandler);\n        const transactionPlanResult = await traverse(plan, context);\n        abortSignal?.removeEventListener('abort', cancelHandler);\n\n        if (context.canceled) {\n            const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;\n            const context = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };\n            // Here we want the `transactionPlanResult` to be available in the error context\n            // so applications can create recovery plans but we don't want this object to be\n            // serialized with the error. This is why we set it as a non-enumerable property.\n            Object.defineProperty(context, 'transactionPlanResult', {\n                configurable: false,\n                enumerable: false,\n                value: transactionPlanResult,\n                writable: false,\n            });\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context);\n        }\n\n        return transactionPlanResult;\n    };\n}\n\ntype TraverseContext = TransactionPlanExecutorConfig & {\n    abortSignal?: AbortSignal;\n    canceled: boolean;\n};\n\nasync function traverse(transactionPlan: TransactionPlan, context: TraverseContext): Promise<TransactionPlanResult> {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(transactionPlan, context);\n        case 'parallel':\n            return await traverseParallel(transactionPlan, context);\n        case 'single':\n            return await traverseSingle(transactionPlan, context);\n        default:\n            transactionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    transactionPlan: SequentialTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (!transactionPlan.divisible) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n    }\n\n    const results: TransactionPlanResult[] = [];\n\n    for (const subPlan of transactionPlan.plans) {\n        const result = await traverse(subPlan, context);\n        results.push(result);\n    }\n\n    return sequentialTransactionPlanResult(results);\n}\n\nasync function traverseParallel(\n    transactionPlan: ParallelTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results = await Promise.all(transactionPlan.plans.map(plan => traverse(plan, context)));\n    return parallelTransactionPlanResult(results);\n}\n\nasync function traverseSingle(\n    transactionPlan: SingleTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (context.canceled) {\n        return canceledSingleTransactionPlanResult(transactionPlan.message);\n    }\n\n    try {\n        const result = await getAbortablePromise(\n            context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }),\n            context.abortSignal,\n        );\n        if ('transaction' in result) {\n            return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);\n        } else {\n            return successfulSingleTransactionPlanResultFromSignature(\n                transactionPlan.message,\n                result.signature,\n                result.context,\n            );\n        }\n    } catch (error) {\n        context.canceled = true;\n        return failedSingleTransactionPlanResult(transactionPlan.message, error as Error);\n    }\n}\n\nfunction findErrorFromTransactionPlanResult(result: TransactionPlanResult): Error | undefined {\n    if (result.kind === 'single') {\n        return result.status.kind === 'failed' ? result.status.error : undefined;\n    }\n    for (const plan of result.plans) {\n        const error = findErrorFromTransactionPlanResult(plan);\n        if (error) {\n            return error;\n        }\n    }\n}\n\nfunction assertDivisibleSequentialPlansOnly(transactionPlan: TransactionPlan): void {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            if (!transactionPlan.divisible) {\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n            }\n            for (const subPlan of transactionPlan.plans) {\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case 'parallel':\n            for (const subPlan of transactionPlan.plans) {\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case 'single':\n        default:\n            return;\n    }\n}\n\n/**\n * Wraps a transaction plan execution promise to return a\n * {@link TransactionPlanResult} even on execution failure.\n *\n * When a transaction plan executor throws a\n * {@link SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN}\n * error, this helper catches it and returns the `TransactionPlanResult`\n * from the error context instead of throwing.\n *\n * This allows us to handle the result of an execution in a single unified way\n * instead of using try/catch and examine the `TransactionPlanResult` in both\n * success and failure cases.\n *\n * Any other errors are re-thrown as normal.\n *\n * @param promise - A promise returned by a transaction plan executor.\n * @return A promise that resolves to the transaction plan result, even if some transactions failed.\n *\n * @example\n * Handling failures using a single result object:\n * ```ts\n * const result = await passthroughFailedTransactionPlanExecution(\n *   transactionPlanExecutor(transactionPlan)\n * );\n *\n * const summary = summarizeTransactionPlanResult(result);\n * if (summary.successful) {\n *   console.log('All transactions executed successfully');\n * } else {\n *   console.log(`${summary.successfulTransactions.length} succeeded`);\n *   console.log(`${summary.failedTransactions.length} failed`);\n *   console.log(`${summary.canceledTransactions.length} canceled`);\n * }\n * ```\n *\n * @see {@link TransactionPlanResult}\n * @see {@link createTransactionPlanExecutor}\n * @see {@link summarizeTransactionPlanResult}\n */\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<SingleTransactionPlanResult>,\n): Promise<SingleTransactionPlanResult>;\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<TransactionPlanResult>,\n): Promise<TransactionPlanResult>;\nexport async function passthroughFailedTransactionPlanExecution(\n    promise: Promise<TransactionPlanResult>,\n): Promise<TransactionPlanResult> {\n    try {\n        return await promise;\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN)) {\n            return error.context.transactionPlanResult as TransactionPlanResult;\n        }\n        throw error;\n    }\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport {\n    appendTransactionMessageInstructions,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\nimport {\n    InstructionPlan,\n    MessagePackerInstructionPlan,\n    ParallelInstructionPlan,\n    SequentialInstructionPlan,\n    SingleInstructionPlan,\n} from './instruction-plan';\nimport {\n    flattenTransactionPlan,\n    nonDivisibleSequentialTransactionPlan,\n    parallelTransactionPlan,\n    sequentialTransactionPlan,\n    SingleTransactionPlan,\n    singleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\n\n/**\n * Plans one or more transactions according to the provided instruction plan.\n *\n * @param instructionPlan - The instruction plan to be planned and executed.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel the planning process.\n *\n * @see {@link InstructionPlan}\n * @see {@link TransactionPlan}\n */\nexport type TransactionPlanner = (\n    instructionPlan: InstructionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlan>;\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\ntype CreateTransactionMessage = (config?: {\n    abortSignal?: AbortSignal;\n}) =>\n    | Promise<TransactionMessage & TransactionMessageWithFeePayer>\n    | (TransactionMessage & TransactionMessageWithFeePayer);\n\ntype OnTransactionMessageUpdated = (\n    transactionMessage: TransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) =>\n    | Promise<TransactionMessage & TransactionMessageWithFeePayer>\n    | (TransactionMessage & TransactionMessageWithFeePayer);\n\n/**\n * Configuration object for creating a new transaction planner.\n *\n * @see {@link createTransactionPlanner}\n */\nexport type TransactionPlannerConfig = {\n    /** Called whenever a new transaction message is needed. */\n    createTransactionMessage: CreateTransactionMessage;\n    /**\n     * Called whenever a transaction message is updated  e.g. new instructions were added.\n     * This function must return the updated transaction message back  even if no changes were made.\n     */\n    onTransactionMessageUpdated?: OnTransactionMessageUpdated;\n};\n\n/**\n * Creates a new transaction planner based on the provided configuration.\n *\n * At the very least, the `createTransactionMessage` function must be provided.\n * This function is used to create new transaction messages whenever needed.\n *\n * Additionally, the `onTransactionMessageUpdated` function can be provided\n * to update transaction messages during the planning process. This function will\n * be called whenever a transaction message is updated, e.g. when new instructions\n * are added to a transaction message. It accepts the updated transaction message\n * and must return a transaction message back, even if no changes were made.\n *\n * @example\n * ```ts\n * const transactionPlanner = createTransactionPlanner({\n *   createTransactionMessage: () => pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(mySigner, message),\n *   )\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanner(config: TransactionPlannerConfig): TransactionPlanner {\n    return async (instructionPlan, { abortSignal } = {}): Promise<TransactionPlan> => {\n        const plan = await traverse(instructionPlan, {\n            abortSignal,\n            createTransactionMessage: config.createTransactionMessage,\n            onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? (msg => msg),\n            parent: null,\n            parentCandidates: [],\n        });\n\n        if (!plan) {\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);\n        }\n\n        return freezeTransactionPlan(plan);\n    };\n}\n\ntype MutableTransactionPlan = Mutable<TransactionPlan>;\ntype MutableSingleTransactionPlan = Mutable<SingleTransactionPlan>;\n\ntype TraverseContext = {\n    abortSignal?: AbortSignal;\n    createTransactionMessage: CreateTransactionMessage;\n    onTransactionMessageUpdated: OnTransactionMessageUpdated;\n    parent: InstructionPlan | null;\n    parentCandidates: MutableSingleTransactionPlan[];\n};\n\nasync function traverse(\n    instructionPlan: InstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    context.abortSignal?.throwIfAborted();\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(instructionPlan, context);\n        case 'parallel':\n            return await traverseParallel(instructionPlan, context);\n        case 'single':\n            return await traverseSingle(instructionPlan, context);\n        case 'messagePacker':\n            return await traverseMessagePacker(instructionPlan, context);\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    instructionPlan: SequentialInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    let candidate: MutableSingleTransactionPlan | null = null;\n\n    // Check if the sequential plan must fit entirely in its parent candidates\n    // due to constraints like being inside a parallel plan or not being divisible.\n    const mustEntirelyFitInParentCandidate =\n        context.parent && (context.parent.kind === 'parallel' || !instructionPlan.divisible);\n\n    // If so, try to fit the entire plan inside one of the parent candidates.\n    if (mustEntirelyFitInParentCandidate) {\n        const candidate = await selectAndMutateCandidate(context, context.parentCandidates, message =>\n            fitEntirePlanInsideMessage(instructionPlan, message),\n        );\n        // If that's possible, we the candidate is mutated and we can return null.\n        // Otherwise, we proceed with the normal traversal and no parent candidate.\n        if (candidate) {\n            return null;\n        }\n    } else {\n        // Otherwise, we can use the first parent candidate, if any,\n        // since we know it must be a divisible sequential plan.\n        candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;\n    }\n\n    const transactionPlans: TransactionPlan[] = [];\n    for (const plan of instructionPlan.plans) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidate ? [candidate] : [],\n        });\n        if (transactionPlan) {\n            candidate = getSequentialCandidate(transactionPlan);\n            const newPlans =\n                transactionPlan.kind === 'sequential' && (transactionPlan.divisible || !instructionPlan.divisible)\n                    ? transactionPlan.plans\n                    : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a sequential plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        divisible: instructionPlan.divisible,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nasync function traverseParallel(\n    instructionPlan: ParallelInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const candidates: MutableSingleTransactionPlan[] = [...context.parentCandidates];\n    const transactionPlans: TransactionPlan[] = [];\n\n    // Reorder children so message packer plans are last.\n    const sortedChildren = Array.from(instructionPlan.plans).sort(\n        (a, b) => Number(a.kind === 'messagePacker') - Number(b.kind === 'messagePacker'),\n    );\n\n    for (const plan of sortedChildren) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidates,\n        });\n        if (transactionPlan) {\n            candidates.push(...getParallelCandidates(transactionPlan));\n            const newPlans = transactionPlan.kind === 'parallel' ? transactionPlan.plans : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a parallel plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return { kind: 'parallel', plans: transactionPlans };\n}\n\nasync function traverseSingle(\n    instructionPlan: SingleInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const predicate = (message: TransactionMessage & TransactionMessageWithFeePayer) =>\n        appendTransactionMessageInstructions([instructionPlan.instruction], message);\n    const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);\n    if (candidate) {\n        return null;\n    }\n    const message = await createNewMessage(context, predicate);\n    return { kind: 'single', message };\n}\n\nasync function traverseMessagePacker(\n    instructionPlan: MessagePackerInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const messagePacker = instructionPlan.getMessagePacker();\n    const transactionPlans: SingleTransactionPlan[] = [];\n    const candidates = [...context.parentCandidates];\n\n    while (!messagePacker.done()) {\n        const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);\n        if (!candidate) {\n            const message = await createNewMessage(context, messagePacker.packMessageToCapacity);\n            const newPlan: MutableSingleTransactionPlan = { kind: 'single', message };\n            transactionPlans.push(newPlan);\n        }\n    }\n\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    if (context.parent?.kind === 'parallel') {\n        return { kind: 'parallel', plans: transactionPlans };\n    }\n    return {\n        divisible: context.parent?.kind === 'sequential' ? context.parent.divisible : true,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nfunction getSequentialCandidate(latestPlan: MutableTransactionPlan): MutableSingleTransactionPlan | null {\n    if (latestPlan.kind === 'single') {\n        return latestPlan;\n    }\n    if (latestPlan.kind === 'sequential' && latestPlan.plans.length > 0) {\n        return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);\n    }\n    return null;\n}\n\nfunction getParallelCandidates(latestPlan: TransactionPlan): MutableSingleTransactionPlan[] {\n    return flattenTransactionPlan(latestPlan);\n}\n\nasync function selectAndMutateCandidate(\n    context: Pick<TraverseContext, 'abortSignal' | 'onTransactionMessageUpdated'>,\n    candidates: MutableSingleTransactionPlan[],\n    predicate: (\n        message: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer,\n): Promise<MutableSingleTransactionPlan | null> {\n    for (const candidate of candidates) {\n        try {\n            const message = await getAbortablePromise(\n                Promise.resolve(\n                    context.onTransactionMessageUpdated(predicate(candidate.message), {\n                        abortSignal: context.abortSignal,\n                    }),\n                ),\n                context.abortSignal,\n            );\n            if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {\n                candidate.message = message;\n                return candidate;\n            }\n        } catch (error) {\n            if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN)) {\n                // Try the next candidate.\n            } else {\n                throw error;\n            }\n        }\n    }\n    return null;\n}\n\nasync function createNewMessage(\n    context: Pick<TraverseContext, 'abortSignal' | 'createTransactionMessage' | 'onTransactionMessageUpdated'>,\n    predicate: (\n        message: TransactionMessage & TransactionMessageWithFeePayer,\n    ) => TransactionMessage & TransactionMessageWithFeePayer,\n): Promise<TransactionMessage & TransactionMessageWithFeePayer> {\n    const newMessage = await getAbortablePromise(\n        Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })),\n        context.abortSignal,\n    );\n    const updatedMessage = await getAbortablePromise(\n        Promise.resolve(\n            context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal }),\n        ),\n        context.abortSignal,\n    );\n    const updatedMessageSize = getTransactionMessageSize(updatedMessage);\n    if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {\n        const newMessageSize = getTransactionMessageSize(newMessage);\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n            numBytesRequired: updatedMessageSize - newMessageSize,\n            numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize,\n        });\n    }\n    return updatedMessage;\n}\n\nfunction freezeTransactionPlan(plan: MutableTransactionPlan): TransactionPlan {\n    const kind = plan.kind;\n    switch (kind) {\n        case 'single':\n            return singleTransactionPlan(plan.message);\n        case 'sequential':\n            return plan.divisible\n                ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan))\n                : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        case 'parallel':\n            return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        default:\n            plan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nfunction fitEntirePlanInsideMessage(\n    instructionPlan: InstructionPlan,\n    message: TransactionMessage & TransactionMessageWithFeePayer,\n): TransactionMessage & TransactionMessageWithFeePayer {\n    let newMessage: TransactionMessage & TransactionMessageWithFeePayer = message;\n\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n        case 'parallel':\n            for (const plan of instructionPlan.plans) {\n                newMessage = fitEntirePlanInsideMessage(plan, newMessage);\n            }\n            return newMessage;\n        case 'single':\n            newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);\n            // eslint-disable-next-line no-case-declarations\n            const newMessageSize = getTransactionMessageSize(newMessage);\n            if (newMessageSize > TRANSACTION_SIZE_LIMIT) {\n                const baseMessageSize = getTransactionMessageSize(message);\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                    numBytesRequired: newMessageSize - baseMessageSize,\n                    numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize,\n                });\n            }\n            return newMessage;\n        case 'messagePacker':\n            // eslint-disable-next-line no-case-declarations\n            const messagePacker = instructionPlan.getMessagePacker();\n            while (!messagePacker.done()) {\n                newMessage = messagePacker.packMessageToCapacity(newMessage);\n            }\n            return newMessage;\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n"],"names":["appendTransactionMessageInstruction","SolanaError","context","traverse","traverseSequential","traverseParallel","traverseSingle","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND","candidate","message","appendTransactionMessageInstructions","getAbortablePromise","getTransactionMessageSize","TRANSACTION_SIZE_LIMIT","isSolanaError","SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND"],"mappings":"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"}},
    {"offset": {"line": 10950, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-spec-types/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-spec-types/src/parse-json-with-bigints.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-spec-types/src/rpc-message.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-spec-types/src/stringify-json-with-bigints.ts"],"sourcesContent":["/**\n * This function is a replacement for `JSON.parse` that can handle large\n * unsafe integers by parsing them as BigInts. It transforms every\n * numerical value into a BigInt without loss of precision.\n */\nexport function parseJsonWithBigInts(json: string): unknown {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\n\nfunction wrapIntegersInBigIntValueObject(json: string): string {\n    const out = [];\n    let inQuote = false;\n    for (let ii = 0; ii < json.length; ii++) {\n        let isEscaped = false;\n        if (json[ii] === '\\\\') {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                // Don't wrap numbers that contain a decimal point or a negative exponent.\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n\n    return out.join('');\n}\n\nfunction consumeNumber(json: string, ii: number): string | null {\n    /** @see https://stackoverflow.com/a/13340826/11440277 */\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n\n    // Stop early if the first character isn't a digit or a minus sign.\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n\n    // Otherwise, check if the next characters form a valid JSON number.\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: string): string {\n    return `{\"$n\":\"${value}\"}`;\n}\n\nfunction unwrapBigIntValueObject({ $n }: BigIntValueObject): bigint {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\n\nfunction isBigIntValueObject(value: unknown): value is BigIntValueObject {\n    return !!value && typeof value === 'object' && '$n' in value && typeof value.$n === 'string';\n}\n","import { RpcRequest } from './rpc-request';\n\nlet _nextMessageId = 0n;\nfunction getNextMessageId(): string {\n    const id = _nextMessageId;\n    _nextMessageId++;\n    return id.toString();\n}\n\n/**\n * Returns a spec-compliant JSON RPC 2.0 message, given a method name and some params.\n *\n * Generates a new `id` on each call by incrementing a `bigint` and casting it to a string.\n */\nexport function createRpcMessage<TParams>(request: RpcRequest<TParams>) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: '2.0',\n        method: request.methodName,\n        params: request.params,\n    };\n}\n","/**\n * Transforms a value into a JSON string, whilst rendering bigints as large unsafe integers.\n */\nexport function stringifyJsonWithBigInts(value: unknown, space?: number | string): string {\n    return unwrapBigIntValueObject(\n        JSON.stringify(value, (_, v) => (typeof v === 'bigint' ? wrapBigIntValueObject(v) : v), space),\n    );\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: bigint): BigIntValueObject {\n    return { $n: `${value}` };\n}\n\nfunction unwrapBigIntValueObject(value: string): string {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, '$1');\n}\n"],"names":["unwrapBigIntValueObject","wrapBigIntValueObject"],"mappings":"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"}},
    {"offset": {"line": 11051, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-spec/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-spec/src/rpc.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-spec/src/rpc-api.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-spec/src/rpc-transport.ts"],"sourcesContent":["import { SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\n\nimport { RpcApi, RpcPlan } from './rpc-api';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcMethods`.\n *\n * Calling each method returns a {@link PendingRpcRequest | PendingRpcRequest<TResponse>} where\n * `TResponse` is that method's response type.\n */\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\n/**\n * Pending requests are the result of calling a supported method on a {@link Rpc} object. They\n * encapsulate all of the information necessary to make the request without actually making it.\n *\n * Calling the {@link PendingRpcRequest.send | `send(options)`} method on a\n * {@link PendingRpcRequest | PendingRpcRequest<TResponse>} will trigger the request and return a\n * promise for `TResponse`.\n */\nexport type PendingRpcRequest<TResponse> = {\n    send(options?: RpcSendOptions): Promise<TResponse>;\n};\n\nexport type RpcSendOptions = Readonly<{\n    /**\n     * An optional signal that you can supply when triggering a {@link PendingRpcRequest} that you\n     * might later need to abort.\n     */\n    abortSignal?: AbortSignal;\n}>;\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link Rpc} instance given a {@link RpcApi | RpcApi<TRpcMethods>} and a\n * {@link RpcTransport} capable of fulfilling them.\n */\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams,\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    { transport }: RpcConfig<TRpcMethods, TRpcTransport>,\n    plan: RpcPlan<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            return await plan.execute({ signal: options?.abortSignal, transport });\n        },\n    };\n}\n","import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n    /**\n     * An optional function that transforms the {@link RpcResponse} before it is returned to the\n     * caller.\n     *\n     * Use cases for this include constructing complex data types from serialized data, and throwing\n     * exceptions.\n     */\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\n/**\n * This type allows an {@link RpcApi} to describe how a particular request should be issued to the\n * JSON RPC server.\n *\n * Given a function that was called on a {@link Rpc}, this object exposes an `execute` function that\n * dictates which request will be sent, how the underlying transport will be used, and how the\n * responses will be transformed.\n *\n * This function accepts a {@link RpcTransport} and an `AbortSignal` and asynchronously returns a\n * {@link RpcResponse}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   transport.\n * - call the underlying transport zero, one or multiple times depending on the use-case (e.g.\n *   caching or aggregating multiple responses).\n * - transform the response from the JSON RPC server, in case it does not match the `TResponse`\n *   specified by the {@link PendingRpcRequest | PendingRpcRequest<TResponse>} returned from that\n *   function.\n */\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * For each of `TRpcMethods`, this object exposes a method with the same name that maps between its\n * input arguments and a {@link RpcPlan | RpcPlan<TResponse>} that implements the execution of a\n * JSON RPC request to fetch `TResponse`.\n */\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a {@link RpcPlan} by\n * creating an `execute` function that:\n *\n * - sets the transport payload to a JSON RPC v2 payload object with the requested `methodName` and\n *   `params` properties, optionally transformed by {@link RpcApiConfig.requestTransformer}.\n * - transforms the transport's response using the {@link RpcApiConfig.responseTransformer}\n *   function, if provided.\n *\n * @example\n * ```ts\n * // For example, given this `RpcApi`:\n * const rpcApi = createJsonRpcApi({\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n *     responseTransformer: response => response.result,\n * });\n *\n * // ...the following function call:\n * rpcApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Returns the \"result\" property of the RPC response.\n * ```\n */\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n","import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    /** A value of arbitrary type to be sent to a RPC server */\n    payload: unknown;\n    /**\n     * An optional `AbortSignal` on which the `'abort'` event will be fired if the request should be\n     * cancelled.\n     */\n    signal?: AbortSignal;\n}>;\n\n/**\n * A function that can act as a transport for a {@link Rpc}. It need only return a promise for a\n * response given the supplied config.\n */\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * Returns `true` if the given payload is a JSON RPC v2 payload.\n *\n * This means, the payload is an object such that:\n *\n * - It has a `jsonrpc` property with a value of `'2.0'`.\n * - It has a `method` property that is a string.\n * - It has a `params` property of any type.\n *\n * @example\n * ```ts\n * import { isJsonRpcPayload } from '@solana/rpc-spec';\n *\n * if (isJsonRpcPayload(payload)) {\n *     const payloadMethod: string = payload.method;\n *     const payloadParams: unknown = payload.params;\n * }\n * ```\n */\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAyDO,SAAS,UACZ,SAAA,EACgB;IAChB,OAAO,UAAU,SAAS,CAAA;AAC9B;AAEA,SAAS,UACL,SAAA,EACgB;IAChB,OAAO,IAAI,KAAA,CAAM,SAAA,CAAU,GAAA,EAAK;QAC5B,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,GAAA,EAAI,MAAA,EAAQ,CAAA,EAAG,QAAA,EAAU;YACrB,IAAI,MAAM,MAAA,EAAQ;gBACd,OAAO,KAAA,CAAA;YACX;YACA,OAAO,SAAA,GAAa,SAAA,EAAsB;gBACtC,MAAM,UAAA,GAAa,EAAE,QAAA,EAAS;gBAC9B,MAAM,UAAA,GAAa,OAAA,CAAQ,GAAA,CAAI,MAAA,EAAQ,YAAY,QAAQ,CAAA;gBAC3D,IAAI,CAAC,UAAA,EAAY;oBACb,MAAM,IAAI,2KAAA,CAAY,kNAAA,EAAoD;wBACtE,MAAA,EAAQ,UAAA;wBACR,MAAA,EAAQ;oBAAA,CACX,CAAA;gBACL;gBACA,MAAM,OAAA,GAAU,UAAA,CAAW,GAAG,SAAS,CAAA;gBACvC,OAAO,uBAAA,CAAwB,WAAW,OAAO,CAAA;YACrD,CAAA;QACJ;IAAA,CACH,CAAA;AACL;AAEA,SAAS,uBAAA,CACL,EAAE,SAAA,EAAU,EACZ,IAAA,EAC4B;IAC5B,OAAO;QACH,MAAM,MAAK,OAAA,EAA8C;YACrD,OAAO,MAAM,KAAK,OAAA,CAAQ;gBAAE,QAAQ,OAAA,EAAS,WAAA;gBAAa;YAAA,CAAW,CAAA;QACzE;IAAA,CACJ;AACJ;ACAO,SAAS,iBAAoD,MAAA,EAA4C;IAC5G,OAAO,IAAI,KAAA,CAAM,CAAA,CAAC,EAA0B;QACxC,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,KAAA,GACO,IAAA,EACL;YACE,MAAM,CAAC,CAAA,EAAG,CAAC,CAAA,GAAI,IAAA;YACf,MAAM,UAAA,GAAa,EAAE,QAAA,EAAS;YAC9B,OAAO,SAAA,GACA,SAAA,EAG0C;gBAC7C,MAAM,aAAa,MAAA,CAAO,MAAA,CAAO;oBAAE,UAAA;oBAAY,MAAA,EAAQ;gBAAA,CAAW,CAAA;gBAClE,MAAM,UAAU,MAAA,EAAQ,kBAAA,GAAqB,MAAA,EAAQ,kBAAA,CAAmB,UAAU,CAAA,GAAI,UAAA;gBACtF,OAAO,OAAO,MAAA,CAAsD;oBAChE,OAAA,EAAS,OAAO,EAAE,MAAA,EAAQ,SAAA,EAAU,KAAM;wBACtC,MAAM,OAAA,OAAU,8LAAA,EAAiB,OAAO,CAAA;wBACxC,MAAM,WAAW,MAAM,SAAA,CAAU;4BAAE,OAAA;4BAAS;wBAAA,CAAQ,CAAA;wBACpD,IAAI,CAAC,QAAQ,mBAAA,EAAqB;4BAC9B,OAAO,QAAA;wBACX;wBACA,OAAO,MAAA,CAAO,mBAAA,CAAoB,QAAA,EAAU,OAAO,CAAA;oBACvD;gBAAA,CACH,CAAA;YACL,CAAA;QACJ;IAAA,CACH,CAAA;AACL;;AChGO,SAAS,iBAAiB,OAAA,EAI9B;IACC,IAAI,OAAA,IAAW,QAAQ,OAAO,OAAA,KAAY,YAAY,KAAA,CAAM,OAAA,CAAQ,OAAO,CAAA,EAAG;QAC1E,OAAO,KAAA;IACX;IACA,OACI,SAAA,IAAa,OAAA,IACb,OAAA,CAAQ,OAAA,KAAY,KAAA,IACpB,QAAA,IAAY,OAAA,IACZ,OAAO,OAAA,CAAQ,MAAA,KAAW,QAAA,IAC1B,QAAA,IAAY,OAAA;AAEpB"}},
    {"offset": {"line": 11152, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-transformers/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer-bigint-downcast-internal.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/tree-traversal.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer-bigint-downcast.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer-default-commitment-internal.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer-default-commitment.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer-integer-overflow-internal.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer-integer-overflow.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer-options-object-position-config.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/request-transformer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/response-transformer-bigint-upcast-internal.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/response-transformer-bigint-upcast.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/response-transformer-result.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/response-transformer-allowed-numeric-values.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/response-transformer-throw-solana-error.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transformers/src/response-transformer.ts"],"sourcesContent":["export function downcastNodeToNumberIfBigint(value: bigint): number;\nexport function downcastNodeToNumberIfBigint<T>(value: T): T;\nexport function downcastNodeToNumberIfBigint(value: unknown): unknown {\n    return typeof value === 'bigint'\n        ? // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the Solana\n          // JSON RPC implementation so that we can throw away this entire patcher instead of unsafely\n          // downcasting `bigints` to `numbers`.\n          Number(value)\n        : value;\n}\n","import { RpcRequest, RpcRequestTransformer, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nexport type KeyPathWildcard = { readonly ['__keyPathWildcard:@solana/kit']: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nfunction getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided visitors at\n * each node. A custom initial state can be provided but must at least provide `{ keyPath: [] }`.\n *\n * @example\n * ```ts\n * import { getTreeWalkerRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getTreeWalkerRequestTransformer(\n *     [\n *         // Replaces foo.bar with \"baz\".\n *         (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n *         // Increments all numbers by 1.\n *         node => (typeof node === number ? node + 1 : node),\n *     ],\n *     { keyPath: [] },\n * );\n * ```\n */\nexport function getTreeWalkerRequestTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState),\n        });\n    };\n}\n\nexport function getTreeWalkerResponseTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcResponseTransformer {\n    return json => getTreeWalker(visitors)(json, initialState);\n}\n","import { downcastNodeToNumberIfBigint } from './request-transformer-bigint-downcast-internal';\nimport { getTreeWalkerRequestTransformer } from './tree-traversal';\n\n/**\n * Creates a transformer that downcasts all `BigInt` values to `Number`.\n *\n * @example\n * ```ts\n * import { getBigIntDowncastRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getBigIntDowncastRequestTransformer();\n * ```\n *\n */\nexport function getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });\n}\n","import { Commitment } from '@solana/rpc-types';\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n","import type { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { applyDefaultCommitment } from './request-transformer-default-commitment-internal';\n\n/**\n * Creates a transformer that adds the provided default commitment to the configuration object of the request when applicable.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getDefaultCommitmentRequestTransformer, OPTIONS_OBJECT_POSITION_BY_METHOD } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultCommitmentRequestTransformer({\n *     defaultCommitment: 'confirmed',\n *     optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n * });\n */\nexport function getDefaultCommitmentRequestTransformer({\n    defaultCommitment,\n    optionsObjectPositionByMethod,\n}: Readonly<{\n    defaultCommitment?: Commitment;\n    optionsObjectPositionByMethod: Record<string, number>;\n}>): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const { params, methodName } = request;\n\n        // We only apply default commitment to array parameters.\n        if (!Array.isArray(params)) {\n            return request;\n        }\n\n        // Find the position of the options object in the parameters and abort if not found.\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params,\n            }),\n        });\n    };\n}\n","import { KeyPath, TraversalState } from './tree-traversal';\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: (keyPath: KeyPath, value: bigint) => void) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n","import { RpcRequest } from '@solana/rpc-spec-types';\n\nimport { getIntegerOverflowNodeVisitor } from './request-transformer-integer-overflow-internal';\nimport { getTreeWalkerRequestTransformer, KeyPath } from './tree-traversal';\n\nexport type IntegerOverflowHandler = (request: RpcRequest, keyPath: KeyPath, value: bigint) => void;\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided handler\n * when an integer overflow is detected.\n *\n * @example\n * ```ts\n * import { getIntegerOverflowRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getIntegerOverflowRequestTransformer((request, keyPath, value) => {\n *     throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n * });\n * ```\n */\nexport function getIntegerOverflowRequestTransformer(onIntegerOverflow: IntegerOverflowHandler) {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const transformer = getTreeWalkerRequestTransformer(\n            [getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))],\n            { keyPath: [] },\n        );\n        return transformer(request);\n    };\n}\n","export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { Commitment } from '@solana/rpc-types';\n\nimport { getBigIntDowncastRequestTransformer } from './request-transformer-bigint-downcast';\nimport { getDefaultCommitmentRequestTransformer } from './request-transformer-default-commitment';\nimport { getIntegerOverflowRequestTransformer, IntegerOverflowHandler } from './request-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './request-transformer-options-object-position-config';\n\nexport type RequestTransformerConfig = Readonly<{\n    /**\n     * An optional {@link Commitment} value to use as the default when none is supplied by the\n     * caller.\n     */\n    defaultCommitment?: Commitment;\n    /**\n     * An optional function that will be called whenever a `bigint` input exceeds that which can be\n     * expressed using JavaScript numbers.\n     *\n     * This is used in the default {@link SolanaRpcSubscriptionsApi} to throw an exception rather\n     * than to allow truncated values to propagate through a program.\n     */\n    onIntegerOverflow?: IntegerOverflowHandler;\n}>;\n\n/**\n * Returns the default request transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcRequestTransformer | RpcRequestTransformers} together such as the\n * {@link getDefaultCommitmentTransformer}, the {@link getIntegerOverflowRequestTransformer} and the\n * {@link getBigIntDowncastRequestTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultRequestTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultRequestTransformerForSolanaRpc({\n *     defaultCommitment: 'confirmed',\n *     onIntegerOverflow: (request, keyPath, value) => {\n *         throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n *     },\n * });\n * ```\n */\nexport function getDefaultRequestTransformerForSolanaRpc(config?: RequestTransformerConfig): RpcRequestTransformer {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request: RpcRequest): RpcRequest => {\n        return pipe(\n            request,\n            handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : r => r,\n            getBigIntDowncastRequestTransformer(),\n            getDefaultCommitmentRequestTransformer({\n                defaultCommitment: config?.defaultCommitment,\n                optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n            }),\n        );\n    };\n}\n","import { KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        const isInteger = (typeof value === 'number' && Number.isInteger(value)) || typeof value === 'bigint';\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n","import { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath } from './tree-traversal';\n\n/**\n * Returns a transformer that upcasts all `Number` values to `BigInts` unless they match within the\n * provided {@link KeyPath | KeyPaths}. In other words, the provided {@link KeyPath | KeyPaths} will\n * remain as `Number` values, any other numeric value will be upcasted to a `BigInt`.\n *\n * Note that you can use {@link KEYPATH_WILDCARD} to match any key within a {@link KeyPath}.\n *\n * @example\n * ```ts\n * import { getBigIntUpcastResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getBigIntUpcastResponseTransformer([\n *     ['index'],\n *     ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n *     ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n *     ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n * ]);\n * ```\n */\nexport function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });\n}\n","import { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { result: unknown };\n\n/**\n * Returns a transformer that extracts the `result` field from the body of the RPC response.\n *\n * For instance, we go from `{ jsonrpc: '2.0', result: 'foo', id: 1 }` to `'foo'`.\n *\n * @example\n * ```ts\n * import { getResultResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getResultResponseTransformer();\n * ```\n */\nexport function getResultResponseTransformer(): RpcResponseTransformer {\n    return json => (json as JsonRpcResponse).result;\n}\n","import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\nexport const innerInstructionsConfigs = [\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n];\nexport const messageConfig = [\n    ['addressTableLookups', KEYPATH_WILDCARD, 'writableIndexes', KEYPATH_WILDCARD],\n    ['addressTableLookups', KEYPATH_WILDCARD, 'readonlyIndexes', KEYPATH_WILDCARD],\n    ['header', 'numReadonlySignedAccounts'],\n    ['header', 'numReadonlyUnsignedAccounts'],\n    ['header', 'numRequiredSignatures'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n] as const;\n","import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { innerInstructionsConfigs, jsonParsedAccountsConfigs } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\ntype JsonRpcResponse = { error: Parameters<typeof getSolanaErrorFromJsonRpcError>[0] } | { result: unknown };\n\n// Keypaths for simulateTransaction result that should remain as Number (not BigInt)\n// Note: These are relative to the error.data root, not result.value like in success responses\nfunction getSimulateTransactionAllowedNumericKeypaths(): readonly KeyPath[] {\n    return [\n        ['loadedAccountsDataSize'],\n        ...jsonParsedAccountsConfigs.map(c => ['accounts', KEYPATH_WILDCARD, ...c]),\n        ...innerInstructionsConfigs.map(c => ['innerInstructions', KEYPATH_WILDCARD, ...c]),\n    ];\n}\n\n/**\n * Returns a transformer that throws a {@link SolanaError} with the appropriate RPC error code if\n * the body of the RPC response contains an error.\n *\n * @example\n * ```ts\n * import { getThrowSolanaErrorResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getThrowSolanaErrorResponseTransformer();\n * ```\n */\nexport function getThrowSolanaErrorResponseTransformer(): RpcResponseTransformer {\n    return (json, request) => {\n        const jsonRpcResponse = json as JsonRpcResponse;\n        if ('error' in jsonRpcResponse) {\n            const { error } = jsonRpcResponse;\n\n            // Check if this is a sendTransaction preflight failure (error code -32002)\n            // These errors contain RpcSimulateTransactionResult in error.data which needs\n            // BigInt values downcast to Number for fields that should be numbers\n            const isSendTransactionPreflightFailure =\n                error &&\n                typeof error === 'object' &&\n                'code' in error &&\n                (error.code === -32002 || error.code === -32002n);\n\n            if (isSendTransactionPreflightFailure && 'data' in error && error.data) {\n                // Apply BigInt downcast transformation to error.data\n                const treeWalker = getTreeWalkerResponseTransformer(\n                    [getBigIntUpcastVisitor(getSimulateTransactionAllowedNumericKeypaths())],\n                    { keyPath: [] },\n                );\n                const transformedData = treeWalker(error.data, request);\n\n                // Reconstruct error with transformed data\n                const transformedError = { ...error, data: transformedData };\n                throw getSolanaErrorFromJsonRpcError(transformedError);\n            }\n\n            throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcResponse, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastResponseTransformer } from './response-transformer-bigint-upcast';\nimport { getResultResponseTransformer } from './response-transformer-result';\nimport { getThrowSolanaErrorResponseTransformer } from './response-transformer-throw-solana-error';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    /**\n     * An optional map from the name of an API method to an array of {@link KeyPath | KeyPaths}\n     * pointing to values in the response that should materialize in the application as `Number`\n     * instead of `BigInt`.\n     */\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\n/**\n * Returns the default response transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcResponseTransformer | RpcResponseTransformers} together such as the\n * {@link getThrowSolanaErrorResponseTransformer}, the {@link getResultResponseTransformer} and the\n * {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpc({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(\n            response,\n            r => getThrowSolanaErrorResponseTransformer()(r, request),\n            r => getResultResponseTransformer()(r, request),\n            r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request),\n        );\n    };\n}\n\n/**\n * Returns the default response transformer for the Solana RPC Subscriptions API.\n *\n * Under the hood, this function composes the {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpcSubscriptions } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpcSubscriptions<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(response, r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n"],"names":["pipe"],"mappings":"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"}},
    {"offset": {"line": 11718, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-api/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-api/src/index.ts"],"sourcesContent":["/**\n * This package contains types that describe the [methods](https://solana.com/docs/rpc/http) of the\n * Solana JSON RPC API, and utilities for creating a {@link RpcApi} implementation with sensible\n * defaults. It can be used standalone, but it is also exported as part of Kit\n * [`@solana/kit`](https://github.com/anza-xyz/kit/tree/main/packages/kit).\n *\n * @example\n * Each RPC method is described in terms of a TypeScript type of the following form:\n *\n * ```ts\n * type ExampleApi = {\n *     getSomething(address: Address): Something;\n * };\n * ```\n *\n * A {@link RpcApi} that implements `ExampleApi` will ultimately expose its defined methods on any\n * {@link Rpc} that uses it.\n *\n * ```ts\n * const rpc: Rpc<ExampleApi> = createExampleRpc(/* ... *\\/);\n * const something: Something = await rpc.getSomething(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN')).send();\n * ```\n *\n * @packageDocumentation\n */\nimport { createJsonRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    innerInstructionsConfigs,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    messageConfig,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\n/**\n * Represents the RPC methods available on test clusters.\n *\n * For instance, the test clusters support the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the devnet cluster.\n *\n * For instance, the devnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the testnet cluster.\n *\n * For instance, the testnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the mainnet cluster.\n *\n * For instance, the mainnet cluster does not support the {@link RequestAirdropApi} whereas test\n * clusters do.\n */\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = RequestTransformerConfig;\n\n/**\n * Creates a {@link RpcApi} implementation of the Solana JSON RPC API with some default behaviours.\n *\n * The default behaviours include:\n * - A transform that converts `bigint` inputs to `number` for compatibility with version 1.0 of the\n *   Solana JSON RPC.\n * - A transform that calls the config's {@link Config.onIntegerOverflow | onIntegerOverflow}\n *   handler whenever a `bigint` input would overflow a JavaScript IEEE 754 number. See\n *   [this](https://github.com/solana-labs/solana-web3.js/issues/1116) GitHub issue for more\n *   information.\n * - A transform that applies a default commitment wherever not specified\n */\nexport function createSolanaRpcApi<\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createJsonRpcApi<TRpcMethods>({\n        requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    ...c,\n                ]),\n                ...messageConfig.map(c => ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', ...c] as const),\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => ['meta', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n                ...messageConfig.map(c => ['transaction', 'message', ...c] as const),\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: [\n                ['value', 'loadedAccountsDataSize'],\n                ...jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n                ...innerInstructionsConfigs.map(c => ['value', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n            ],\n        };\n    }\n    return memoizedKeypaths;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12010, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-transport-http/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transport-http/src/http-transport-headers.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transport-http/src/http-transport.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transport-http/src/is-solana-request.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc-transport-http/src/http-transport-for-solana-rpc.ts"],"sourcesContent":["import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    // Though technically forbidden in non-Node environments, we don't have a way to target\n    // TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is\n    // therefore omitted from the forbidden headers type, but is still a runtime error in dev mode\n    // when supplied in a non-Node context.\n    // | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    // Similar to `Accept-Encoding`, we don't have a way to target TypeScript types depending on\n    // which platform you are authoring for. `Origin` is therefore omitted from the forbidden\n    // headers type, but is still a runtime error in dev mode when supplied in a browser context.\n    // | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = /* @__PURE__ */ Object.assign(\n    {\n        'accept-charset': true,\n        'access-control-request-headers': true,\n        'access-control-request-method': true,\n        connection: true,\n        'content-length': true,\n        cookie: true,\n        date: true,\n        dnt: true,\n        expect: true,\n        host: true,\n        'keep-alive': true,\n        'permissions-policy': true,\n        // Prefix matching is implemented in code, below.\n        // 'proxy-': true,\n        // 'sec-': true,\n        referer: true,\n        te: true,\n        trailer: true,\n        'transfer-encoding': true,\n        upgrade: true,\n        via: true,\n    },\n    __NODEJS__ ? undefined : { 'accept-encoding': true },\n    __BROWSER__ ? { origin: true } : undefined,\n);\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n// Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n// in the `DisallowedHeaders` type.\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport { HttpTransportConfig as Config } from './http-transport-config';\nimport { assertIsAllowedHttpRequestHeaders, normalizeHeaders } from './http-transport-headers';\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\n/**\n * Creates a function you can use to make `POST` requests with headers suitable for sending JSON\n * data to a server.\n *\n * @example\n * ```ts\n * import { createHttpTransport } from '@solana/rpc-transport-http';\n *\n * const transport = createHttpTransport({ url: 'https://api.mainnet-beta.solana.com' });\n * const response = await transport({\n *     payload: { id: 1, jsonrpc: '2.0', method: 'getSlot' },\n * });\n * const data = await response.json();\n * ```\n */\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { fromJson, headers, toJson, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<RpcResponse<TResponse>> {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                headers: response.headers,\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload) as TResponse;\n        }\n        return await response.json();\n    };\n}\n","import { isJsonRpcPayload } from '@solana/rpc-spec';\n\nconst SOLANA_RPC_METHODS = [\n    'getAccountInfo',\n    'getBalance',\n    'getBlock',\n    'getBlockCommitment',\n    'getBlockHeight',\n    'getBlockProduction',\n    'getBlocks',\n    'getBlocksWithLimit',\n    'getBlockTime',\n    'getClusterNodes',\n    'getEpochInfo',\n    'getEpochSchedule',\n    'getFeeForMessage',\n    'getFirstAvailableBlock',\n    'getGenesisHash',\n    'getHealth',\n    'getHighestSnapshotSlot',\n    'getIdentity',\n    'getInflationGovernor',\n    'getInflationRate',\n    'getInflationReward',\n    'getLargestAccounts',\n    'getLatestBlockhash',\n    'getLeaderSchedule',\n    'getMaxRetransmitSlot',\n    'getMaxShredInsertSlot',\n    'getMinimumBalanceForRentExemption',\n    'getMultipleAccounts',\n    'getProgramAccounts',\n    'getRecentPerformanceSamples',\n    'getRecentPrioritizationFees',\n    'getSignaturesForAddress',\n    'getSignatureStatuses',\n    'getSlot',\n    'getSlotLeader',\n    'getSlotLeaders',\n    'getStakeMinimumDelegation',\n    'getSupply',\n    'getTokenAccountBalance',\n    'getTokenAccountsByDelegate',\n    'getTokenAccountsByOwner',\n    'getTokenLargestAccounts',\n    'getTokenSupply',\n    'getTransaction',\n    'getTransactionCount',\n    'getVersion',\n    'getVoteAccounts',\n    'index',\n    'isBlockhashValid',\n    'minimumLedgerSlot',\n    'requestAirdrop',\n    'sendTransaction',\n    'simulateTransaction',\n] as const;\n\n/**\n * Helper function that checks if a given `RpcRequest` comes from the Solana RPC API.\n */\nexport function isSolanaRequest(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: (typeof SOLANA_RPC_METHODS)[number];\n    params: unknown;\n}> {\n    return isJsonRpcPayload(payload) && (SOLANA_RPC_METHODS as readonly string[]).includes(payload.method);\n}\n","import { RpcTransport } from '@solana/rpc-spec';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\n\nimport { createHttpTransport } from './http-transport';\nimport { HttpTransportConfig } from './http-transport-config';\nimport { isSolanaRequest } from './is-solana-request';\n\ntype Config = Pick<HttpTransportConfig, 'dispatcher_NODE_ONLY' | 'headers' | 'url'>;\n\n/**\n * Creates a {@link RpcTransport} that uses JSON HTTP requests  much like the\n * {@link createHttpTransport} function - except that it also uses custom `toJson` and `fromJson`\n * functions in order to allow `bigint` values to be serialized and deserialized correctly over the\n * wire.\n *\n * Since this is something specific to the Solana RPC API, these custom JSON functions are only\n * triggered when the request is recognized as a Solana RPC request. Normal RPC APIs should aim to\n * wrap their `bigint` values  e.g. `u64` or `i64`  in special value objects that represent the\n * number as a string to avoid numerical values going above `Number.MAX_SAFE_INTEGER`.\n *\n * It has the same configuration options as {@link createHttpTransport}, but without the `fromJson`\n * and `toJson` options.\n */\nexport function createHttpTransportForSolanaRpc(config: Config): RpcTransport {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse: string, payload: unknown) =>\n            isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload: unknown) =>\n            isSolanaRequest(payload) ? stringifyJsonWithBigInts(payload) : JSON.stringify(payload),\n    });\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 12185, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/fast-stable-stringify/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/fast-stable-stringify/src/index.ts"],"sourcesContent":["/**\n * This project is a fork of [nickyout/fast-stable-stringify](https://github.com/nickyout/fast-stable-stringify)\n *\n * The most popular repository providing this feature is [substack's json-stable-stringify](https://www.npmjs.com/package/json-stable-stringify). The intent of this library is to provide a faster alternative for when performance is more important than features. It assumes you provide basic javascript values without circular references, and returns a non-indented string.\n *\n * Just like substack's, it:\n *\n * - handles all variations of all basic javascript values (number, string, boolean, array, object, null, Date, BigInt)\n * - handles undefined _and_ function in the same way as `JSON.stringify`\n * - **does not support ie8 (and below) with complete certainty**.\n *\n * Unlike substack's, it:\n *\n * - does not implement the 'replacer' or 'space' arguments of the JSON.stringify method\n * - does not check for circular references\n *\n * @example\n * ```js\n * import stringify from '@solana/fast-stable-stringify';\n * stringify({ d: 0, c: 1, a: 2, b: 3, e: 4 }); // '{\"a\":2,\"b\":3,\"c\":1,\"d\":0,\"e\":4}'\n * ```\n *\n * @packageDocumentation\n */\nconst objToString = Object.prototype.toString;\nconst objKeys =\n    Object.keys ||\n    function (obj) {\n        const keys = [];\n        for (const name in obj) {\n            keys.push(name);\n        }\n        return keys;\n    };\n\nfunction stringify(val: unknown, isArrayProp: boolean) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return 'true';\n    }\n    if (val === false) {\n        return 'false';\n    }\n    switch (typeof val) {\n        case 'object':\n            if (val === null) {\n                return null;\n            } else if ('toJSON' in val && typeof val.toJSON === 'function') {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === '[object Array]') {\n                    str = '[';\n                    max = (val as unknown[]).length - 1;\n                    for (i = 0; i < max; i++) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true) + ',';\n                    }\n                    if (max > -1) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true);\n                    }\n                    return str + ']';\n                } else if (toStr === '[object Object]') {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = '';\n                    i = 0;\n                    while (i < max) {\n                        key = keys[i];\n                        propVal = stringify((val as Record<typeof key, unknown>)[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += ',';\n                            }\n                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                            str += JSON.stringify(key) + ':' + propVal;\n                        }\n                        i++;\n                    }\n                    return '{' + str + '}';\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case 'function':\n        case 'undefined':\n            return isArrayProp ? null : undefined;\n        case 'bigint':\n            return `${val.toString()}n`;\n        case 'string':\n            return JSON.stringify(val);\n        default:\n            return isFinite(val as number) ? val : null;\n    }\n}\n\nexport default function (\n    val:\n        | Function // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n        | undefined,\n): undefined;\nexport default function (val: unknown): string;\nexport default function (val: unknown): string | undefined {\n    const returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        return '' + returnVal;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12269, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc/dist/index.node.mjs","sources":["file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc/src/rpc-integer-overflow-error.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc/src/rpc-default-config.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/event-target-impl/src/index.node.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc/src/rpc-request-coalescer.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc/src/rpc-request-deduplication.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc/src/rpc-transport.ts","file:///Users/boriskaborisenko/Desktop/HarborYield-F/node_modules/%40solana/rpc/src/rpc.ts"],"sourcesContent":["import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\n/**\n * When you create {@link Rpc} instances with custom transports but otherwise the default RPC API\n * behaviours, use this.\n *\n * @example\n * ```ts\n * const myCustomRpc = createRpc({\n *     api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n *     transport: myCustomTransport,\n * });\n * ```\n */\nexport const DEFAULT_RPC_CONFIG: Partial<NonNullable<Parameters<typeof createSolanaRpcApi>[0]>> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import { setMaxListeners } from 'node:events';\n\nexport const AbortController = class extends globalThis.AbortController {\n    constructor(...args: ConstructorParameters<typeof globalThis.AbortController>) {\n        super(...args);\n        setMaxListeners(Number.MAX_SAFE_INTEGER, this.signal);\n    }\n};\n\nexport const EventTarget = class extends globalThis.EventTarget {\n    constructor(...args: ConstructorParameters<typeof globalThis.EventTarget>) {\n        super(...args);\n        setMaxListeners(Number.MAX_SAFE_INTEGER, this);\n    }\n};\n","import { AbortController } from '@solana/event-target-impl';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<RpcResponse>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nlet EXPLICIT_ABORT_TOKEN: ReturnType<typeof createExplicitAbortToken>;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return process.env.NODE_ENV !== \"production\"\n        ? {\n              EXPLICIT_ABORT_TOKEN:\n                  'This object is thrown from the request that underlies a series of coalesced ' +\n                  'requests when the last request in that series aborts',\n          }\n        : {};\n}\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(\n        request: Parameters<RpcTransport>[0],\n    ): Promise<RpcResponse<TResponse>> {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...request,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<RpcResponse<TResponse>>;\n            return await new Promise<RpcResponse<TResponse>>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(() => {\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise\n                    .then(resolve)\n                    .catch(reject)\n                    .finally(() => {\n                        signal.removeEventListener('abort', handleAbort);\n                    });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as RpcResponse<TResponse>;\n        }\n    } as TTransport;\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n","import { pipe } from '@solana/functional';\nimport { createHttpTransport, createHttpTransportForSolanaRpc } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\ninterface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        // Lowercasing header names makes it easier to override user-supplied headers.\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\n/**\n * Creates a {@link RpcTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - An automatically-set `Solana-Client` request header, containing the version of `@solana/kit`\n * - Logic that coalesces multiple calls in the same runloop, for the same methods with the same\n *   arguments, into a single network request.\n * - [node-only] An automatically-set `Accept-Encoding` request header asking the server to compress\n *   responses\n *\n * @param config\n */\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransportForSolanaRpc({\n            ...config,\n            headers: {\n                ...(__NODEJS__ &&\n                    ({\n                        // Keep these headers lowercase so they will be overridden by any user-supplied headers below.\n                        'accept-encoding':\n                            // Natively supported by Node LTS v20.18.0 and above.\n                            'br,gzip,deflate', // Brotli, gzip, and Deflate, in that order.\n                    } as { [overrideHeader: string]: string })),\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': __VERSION__ ? `js/${__VERSION__}` : 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n","import { createSolanaRpcApi } from '@solana/rpc-api';\nimport { createRpc, RpcTransport } from '@solana/rpc-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport type { RpcFromTransport, SolanaRpcApiFromTransport } from './rpc-clusters';\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport { createDefaultRpcTransport } from './rpc-transport';\n\ntype DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> = Parameters<\n    typeof createDefaultRpcTransport<TClusterUrl>\n>[0];\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given a cluster URL and some\n * optional transport config. See {@link createDefaultRpcTransport} for the shape of the transport\n * config.\n */\nexport function createSolanaRpc<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));\n}\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given the supplied\n * {@link RpcTransport}.\n */\nexport function createSolanaRpcFromTransport<TTransport extends RpcTransport>(transport: TTransport) {\n    return createRpc({\n        api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n        transport,\n    }) as RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport>;\n}\n"],"names":["AbortController","args","setMaxListeners","e"],"mappings":"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"}}]
}